<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>webInterview | Hexo</title><meta name="author" content="MaxLi"><meta name="copyright" content="MaxLi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前端面试个人总结1. html5新特性[html5新特性]（https:&#x2F;&#x2F;www.cnblogs.com&#x2F;vicky1018&#x2F;p&#x2F;7705223.html）12345678910(1)语义标签(2)增强型表单(3)视频和音频(4)Canvas绘图(5)SVG绘图(6)地理定位(7)拖放API(8)Web Worker(9)Web Storage(10)WebSocket 2. CSS3新特性12">
<meta property="og:type" content="article">
<meta property="og:title" content="webInterview">
<meta property="og:url" content="http://example.com/2022/05/14/webInterview/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="前端面试个人总结1. html5新特性[html5新特性]（https:&#x2F;&#x2F;www.cnblogs.com&#x2F;vicky1018&#x2F;p&#x2F;7705223.html）12345678910(1)语义标签(2)增强型表单(3)视频和音频(4)Canvas绘图(5)SVG绘图(6)地理定位(7)拖放API(8)Web Worker(9)Web Storage(10)WebSocket 2. CSS3新特性12">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-05-13T17:58:08.000Z">
<meta property="article:modified_time" content="2022-07-16T04:16:12.510Z">
<meta property="article:author" content="MaxLi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/05/14/webInterview/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'webInterview',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-16 12:16:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">webInterview</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-05-13T17:58:08.000Z" title="Created 2022-05-14 01:58:08">2022-05-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-07-16T04:16:12.510Z" title="Updated 2022-07-16 12:16:12">2022-07-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="webInterview"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前端面试个人总结"><a href="#前端面试个人总结" class="headerlink" title="前端面试个人总结"></a>前端面试个人总结</h2><h3 id="1-html5新特性-html5新特性-（https-www-cnblogs-com-vicky1018-p-7705223-html）"><a href="#1-html5新特性-html5新特性-（https-www-cnblogs-com-vicky1018-p-7705223-html）" class="headerlink" title="1. html5新特性[html5新特性]（https://www.cnblogs.com/vicky1018/p/7705223.html）"></a>1. html5新特性[html5新特性]（<a target="_blank" rel="noopener" href="https://www.cnblogs.com/vicky1018/p/7705223.html%EF%BC%89">https://www.cnblogs.com/vicky1018/p/7705223.html）</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(1)语义标签</span><br><span class="line">(2)增强型表单</span><br><span class="line">(3)视频和音频</span><br><span class="line">(4)Canvas绘图</span><br><span class="line">(5)SVG绘图</span><br><span class="line">(6)地理定位</span><br><span class="line">(7)拖放API</span><br><span class="line">(8)Web Worker</span><br><span class="line">(9)Web Storage</span><br><span class="line">(10)WebSocket</span><br></pre></td></tr></table></figure>
<h3 id="2-CSS3新特性"><a href="#2-CSS3新特性" class="headerlink" title="2. CSS3新特性"></a>2. CSS3新特性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">一：CSS3选择器</span><br><span class="line">1.基本选择器</span><br><span class="line">2.属性选择器</span><br><span class="line">3.伪类选择器</span><br><span class="line">二：CSS3边框与圆角</span><br><span class="line">1.CSS3圆角border-radius</span><br><span class="line">2.盒阴影box-shadow</span><br><span class="line">三：CSS3背景与渐变</span><br><span class="line">1.CSS3背景</span><br><span class="line">2.CSS3渐变background-image</span><br><span class="line"></span><br><span class="line">定义：可以在两个或者多个指定颜色之间显示平移的过渡</span><br><span class="line">四：CSS3过渡</span><br><span class="line">定义：允许css的属性值在一定时间区间内平滑的过渡，在鼠标点击，</span><br><span class="line">鼠标滑过或对元素任何改变中触发，并圆滑地以动画形式改变css的属性值。</span><br><span class="line">五：CSS3变换</span><br><span class="line">定义：让一个元素在一个坐标系统中变形，这个属性包含一系列的变形函数，可以移动，旋转，缩放元素。</span><br><span class="line">六：CSS3动画</span><br><span class="line">定义：使元素从一种样式逐渐变化到另外一种样式的效果。</span><br></pre></td></tr></table></figure>
<h3 id="3-取随机数50-到100随机数"><a href="#3-取随机数50-到100随机数" class="headerlink" title="3.取随机数50 到100随机数"></a>3.取随机数50 到100随机数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  &lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> ranDom=<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">50</span>)+<span class="number">50</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(ranDom);</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-Js里面this指向"><a href="#4-Js里面this指向" class="headerlink" title="4. Js里面this指向"></a>4. Js里面this指向</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">箭头函数：指向外部，</span><br><span class="line">事件调用：指向标签</span><br><span class="line">构造函数：<span class="keyword">new</span> 出来的函数，指向调用它所在方法的对象。</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">        <span class="keyword">const</span> time=<span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">            <span class="comment">// 构造函数中 this 指向的是正在创建对象的本身</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> st1= <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;FY&#x27;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(st1.<span class="property">name</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(st1);</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="5-原型和原型链"><a href="#5-原型和原型链" class="headerlink" title="5. 原型和原型链"></a>5. 原型和原型链</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">每个对象都有一个关联对象，这个关联对象就是它的原型，</span><br><span class="line">①所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象</span><br><span class="line">②所有函数都有一个prototype(原型)属性，属性值是一个普通的对象</span><br><span class="line">③所有引用类型的__proto__属性指向它构造函数的prototype</span><br><span class="line">var a = [1,2,3]; a.__proto__ === Array.prototype; // true</span><br><span class="line">原型链</span><br><span class="line">	当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，</span><br><span class="line">	则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，</span><br><span class="line">	如果还没有找到就会再在构造函数的prototype的__proto__中查找，</span><br><span class="line">	这样一层一层向上查找就会形成一个链式结构，我们称为原型链</span><br></pre></td></tr></table></figure>

<h3 id="6-原型的作用？-传在于-（https-blog-csdn-net-hgzzzz-article-details-81530563）"><a href="#6-原型的作用？-传在于-（https-blog-csdn-net-hgzzzz-article-details-81530563）" class="headerlink" title="6.原型的作用？[传在于]（https://blog.csdn.net/hgzzzz/article/details/81530563）"></a>6.原型的作用？[传在于]（<a target="_blank" rel="noopener" href="https://blog.csdn.net/hgzzzz/article/details/81530563%EF%BC%89">https://blog.csdn.net/hgzzzz/article/details/81530563）</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>数据共享，节省空间：</span><br><span class="line">在函数作为构造函数时，在构造函数内部用<span class="variable language_">this</span>.<span class="property">method</span> 初始化对象方法会使得每一个实例化出来的对象都有一个相同的但是占用不同内存的方法</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">当我们去实例化对象时，每一个对象都有一个say方法，虽然作用相同，但是是不同的方法，占用不同的内存空间。</span><br><span class="line">我们可以这样改进</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">say</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">function Person()&#123;</span></span><br><span class="line"><span class="string">    this.say = say;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">这样可以让每个实例对象只是得到函数say的一个指针，指向同一个say函数，节省了空间，但是显然这个类失去了封装性。</span></span><br><span class="line"><span class="string">所以我们要用到原型</span></span><br><span class="line"><span class="string">function Person()&#123;&#125;</span></span><br><span class="line"><span class="string">Person.prototype.say = function()&#123;</span></span><br><span class="line"><span class="string">    console.log(&#x27;</span><span class="title class_">Hi</span><span class="string">&#x27;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">利用原型可以使得每一个实例对象都可以调用原型上的say方法，而且节省了内存.</span></span><br><span class="line"><span class="string">2.继承：</span></span><br><span class="line"><span class="string"> 组合式继承 = 原型继承 + 借用构造函数继承</span></span><br><span class="line"><span class="string">  function Person(name) &#123;</span></span><br><span class="line"><span class="string">        this.name = name;</span></span><br><span class="line"><span class="string">        this.friends = [&#x27;</span><span class="title class_">Mike</span><span class="string">&#x27;,&#x27;</span><span class="title class_">Jack</span><span class="string">&#x27;];</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    function Chinese(name,age) &#123;</span></span><br><span class="line"><span class="string">        Person.call(this,name);</span></span><br><span class="line"><span class="string">        this.age = age;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    Chinese.prototype = new Person();</span></span><br><span class="line"><span class="string">在子类构造函数中借用父类构造函数，再通过原型继承父类的原型属性和方法，模拟继承的效果</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>


<h3 id="7-Cookie默认存放20分钟"><a href="#7-Cookie默认存放20分钟" class="headerlink" title="7. Cookie默认存放20分钟"></a>7. Cookie默认存放20分钟</h3><h3 id="8-Vue框架和jQuery、原生js有什么区别"><a href="#8-Vue框架和jQuery、原生js有什么区别" class="headerlink" title="8. Vue框架和jQuery、原生js有什么区别"></a>8. Vue框架和jQuery、原生js有什么区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jQuery操作的是<span class="variable constant_">DOM</span>对象，vue操作的是数据</span><br><span class="line"><span class="number">1.</span>javaScript是运行在浏览器端的脚本语言，<span class="title class_">JavaScript</span>主要解决的是前端与用户交互的问题，</span><br><span class="line">  包括使用交互与数据交互，<span class="title class_">JavaScript</span>是浏览器解释执行的。</span><br><span class="line"><span class="number">2.</span>jQuery就是javascript中的一个函数库，一个js文件，是把js中比较复杂的东西封装成一个库，</span><br><span class="line">  能够让人们在开发过程中尽可能的少写多做。</span><br><span class="line"><span class="number">3.</span><span class="title class_">Vue</span>.<span class="property">js</span>可以作为一个js库来使用，也可以用它全套的工具来构建系统界面，</span><br><span class="line">  这些可以根据项目的需要灵活选择，所以说，<span class="title class_">Vue</span>.<span class="property">js</span>是一套构建用户界面的渐进式框架。</span><br><span class="line">  <span class="title class_">Vue</span>的核心库只关注视图层，<span class="title class_">Vue</span>的目标是通过尽可能简单的 <span class="variable constant_">API</span> 实现响应的数据绑定，</span><br><span class="line">  在这一点上<span class="title class_">Vue</span>.<span class="property">js</span>类似于后台的模板语言。其本质上来说也是js代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="9-插槽的使用"><a href="#9-插槽的使用" class="headerlink" title="9. 插槽的使用"></a>9. 插槽的使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">默认插槽：任何标签都可以插入进去</span><br><span class="line">具名插槽：只有v-slot 符合其name的时候才能插入</span><br><span class="line">作用域插槽</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="10-常用指令"><a href="#10-常用指令" class="headerlink" title="10. 常用指令"></a>10. 常用指令</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v-model、v-<span class="keyword">if</span>、v-<span class="keyword">else</span>、v-<span class="keyword">for</span>、v-on、v-once、</span><br><span class="line">v-bind：动态绑定属性</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="11-计算属性和侦听器"><a href="#11-计算属性和侦听器" class="headerlink" title="11. 计算属性和侦听器"></a>11. 计算属性和侦听器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">计算属性：默认页面渲染时执行一次，可以监听多个值，同步，且有区分为get、set方法</span><br><span class="line">侦听器：页面渲染时，默认不执行，一次只能监听一个值，异步，没有区分、set方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="12-V-for为什么要加个-key-福建光通互联通信有限公司-get"><a href="#12-V-for为什么要加个-key-福建光通互联通信有限公司-get" class="headerlink" title="12. V-for为什么要加个 key (福建光通互联通信有限公司)get"></a>12. V-for为什么要加个 key (福建光通互联通信有限公司)get</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Key是唯一标识符</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="13-单向数据流"><a href="#13-单向数据流" class="headerlink" title="13. 单向数据流"></a>13. 单向数据流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父组件向子组件传递数据，子组件只有访问权，没有修改权</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="14-虚拟DOM是用来干嘛的"><a href="#14-虚拟DOM是用来干嘛的" class="headerlink" title="14. 虚拟DOM是用来干嘛的"></a>14. 虚拟DOM是用来干嘛的</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">虚拟 DOM 是一个普通的js对象，用来描述真实DOM结构的js对象</span><br><span class="line">作用：我们都知道传统的dom数据发生变化的时候，我们都需要不断的去操作dom，</span><br><span class="line">才能更新dom数据，虽然后面出现了模板引擎，可以让我们一次性更新多个dom。</span><br><span class="line">但模板引擎依旧没有一种可以追踪状态的机制，当引擎内某个数据发生变化时，</span><br><span class="line">它依然操作dom去重新渲染整个引擎。</span><br><span class="line">而虚拟dom可以很好地跟踪当前dom状态，因为它会根据当前数据生成一个描述当前dom结构的虚拟dom，</span><br><span class="line">然后数据发生变化时，有生成一个新的虚拟dom，而两个虚拟dom恰好保存了变化前后的状态。</span><br><span class="line">然后通过diff算法，计算出当前两个虚拟dom之间的差异，得出一个更好的替换方案。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="15-守卫"><a href="#15-守卫" class="headerlink" title="15. 守卫"></a>15. 守卫</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">前置守卫，后置守卫，组件内守卫，路由独享守卫</span><br><span class="line">一.全局守卫</span><br><span class="line">1. router.beforeEach((to,from,next)=&gt;&#123;&#125;)</span><br><span class="line">2. 回调函数中的参数，to：进入到哪个路由去，from：从哪个路由离开，next：函数，决定是否展示你要看到的路由页面。</span><br><span class="line">二.组件内的守卫</span><br><span class="line">beforeRouteEnter:(to,from,next)=&gt;&#123;&#125;</span><br><span class="line">三.路由独享的守卫</span><br><span class="line">1. beforeEnter:(to,from,next)=&gt;&#123;&#125;，用法与全局守卫一致。只是，将其写进其中一个路由对象中，只在这个路由下起作用。</span><br><span class="line">15-1 路由独享守卫干什么用的？</span><br><span class="line">（https://www.kancloud.cn/yanmingfei/vue07/1219185）</span><br><span class="line">路由独享守卫：路由独享守卫故名思议，就是当前的守卫只能给路由自己使用。</span><br><span class="line">如果说某个路由需要自己独特的功能。比如当前页面只能登录成功才可以访问，那么我们就要考虑如何拦截。</span><br><span class="line">作用：</span><br><span class="line">实现登录拦截：实现的页面中用户登录后才可以访问。同样的我们也可以做其它操作。比如购物车页面，必须登录后才可以访问。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="16-路由中配置-404-页面"><a href="#16-路由中配置-404-页面" class="headerlink" title="16.路由中配置 404 页面"></a>16.路由中配置 404 页面</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">在router.<span class="property">js</span>中，</span><br><span class="line">由于路由是从上到下执行的，只要在路由配置中最后面放个*号就可以了，最后两个是<span class="number">404</span>的两种写法，根据具体情况使用</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;HelloWorld&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">HelloWorld</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/hello&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Hello</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//路由中的404</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;NotFound&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">NotFound</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//路由中的重定向，404之后重定向</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">      <span class="attr">redirect</span>: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="17-Vuex中的模块（5）"><a href="#17-Vuex中的模块（5）" class="headerlink" title="17. Vuex中的模块（5）"></a>17. Vuex中的模块（5）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">State</span>：公共数据（放置状态相关的信息，vue是使用单一状态树的，</span><br><span class="line">       也就是单一数据源，也就是说我们的state只能有一个）</span><br><span class="line"><span class="title class_">Getters</span>：类似于vue中的计算属性</span><br><span class="line"><span class="title class_">Mutations</span>：操作数据的方法（）</span><br><span class="line">		其实就相当于我们vue里面的methods，也是定义方法的，</span><br><span class="line">		只不过这个方法可以在多个组件调用就是了</span><br><span class="line"><span class="title class_">Actions</span>：</span><br><span class="line">	mutations是写同步操作的，在他里面是不能写异步操作的，</span><br><span class="line">	那我们就需要在actions里面来写我们的异步操作。并且写异步操作的话，</span><br><span class="line">	调用的话就不是使用commit了，二十使用我们的dispatch</span><br><span class="line"><span class="title class_">Modules</span>：</span><br><span class="line">	最后一个就是我们的modules，就是模块化的意思，因为是单一状态树，</span><br><span class="line">	怕我们在state里面写的东西太多了，不好进行查找，</span><br><span class="line">	那我们可以在我们的modules里面重新定义我们的一个模块，就是相当于一个store，</span><br><span class="line">	里面也有我们所需要的五个属性，所进行的操作也是一样的。</span><br><span class="line"><span class="number">17</span>-<span class="number">1</span> vuex中action和mutation的区别</span><br><span class="line">action的功能和mutation是类似的，都是去变更store里的state，不过action和mutation有两点不同：</span><br><span class="line">～action主要处理的是异步的操作，mutation只能同步</span><br><span class="line">～<span class="title class_">Action</span> 提交的是 mutation，而不是直接变更状态。</span><br><span class="line">～<span class="title class_">Mutation</span> 在组件中使用 <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;xxx&#x27;</span>) 提交 mutation，</span><br><span class="line"> 或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.<span class="property">commit</span> 调用（需要在根节点注入 store）</span><br><span class="line">～<span class="title class_">Action</span> 通过 store.<span class="property">dispatch</span> 方法触发：在组件中使用 <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;xxx&#x27;</span>) 分发 action，</span><br><span class="line">  或者使用 mapActions 辅助函数将组件的 methods 映射为 store.<span class="property">dispatch</span> 调用（需要先在根节点注入 store）</span><br></pre></td></tr></table></figure>

<h3 id="18-如何提高首屏加载速度"><a href="#18-如何提高首屏加载速度" class="headerlink" title="18. 如何提高首屏加载速度"></a>18. 如何提高首屏加载速度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">路由懒加载、异步加载、cdn、按需加载、分屏加载、webpack</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>—————-Add——————</p>
<h3 id="19-路由懒加载"><a href="#19-路由懒加载" class="headerlink" title="19. 路由懒加载"></a>19. 路由懒加载</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> vue异步组件技术</span><br><span class="line">在大型应用中，我们可能需要将应用分割成小一些的代码块，</span><br><span class="line">并且只在需要的时候才从服务器加载一个模块。为了简化，<span class="title class_">Vue</span>允许你以一个工厂函数的方式定义你的组件，</span><br><span class="line">这个工厂函数会异步解析你的组件定义。<span class="title class_">Vue</span>只有在这个组件需要被渲染的时候才会触发该工厂函数，</span><br><span class="line">且会把结果缓存起来供未来重渲染</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;<span class="attr">routers</span>: [</span><br><span class="line"><span class="attr">path</span>: <span class="string">&quot;/login&#x27;;</span></span><br><span class="line"><span class="string">component: (resolve) =&gt; &#123; require([&#x27;@/components/login/Login&#x27;], resolve)&#125;&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">path: &#x27;/home&#x27;,</span></span><br><span class="line"><span class="string">component: (resolve) =&gt; &#123; require([&#x27;@/components/home/Home&#x27;], resolve)&#125;</span></span><br><span class="line"><span class="string">]))</span></span><br><span class="line"><span class="string">2.路由懒加载(官方方把组件按组分块)</span></span><br><span class="line"><span class="string">每个()=&gt; import()都会生成一个独立的JS文件</span></span><br><span class="line"><span class="string">也就是说:只要使用这个语法，就是告诉webpack这就是一个代码分割点，</span></span><br><span class="line"><span class="string">这样生成一个独立的js文件，来实现按需加载的功能</span></span><br><span class="line"><span class="string">无需import导入组件</span></span><br><span class="line"><span class="string">  &#123; path: &#x27;msg&#x27;,component: () =&gt; import(&#x27;../pages/MainMsg.vue&#x27;), meta: &#123; title: &#x27;我的消息&#x27; &#125; &#125;,</span></span><br><span class="line"><span class="string">  &#123; path: &#x27;order&#x27;,component: () =&gt; import(&#x27;../pages/MainOrder.vue&#x27;), meta: &#123; title: &#x27;我的订单&#x27; &#125; &#125;,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3.webpack提供的require.ensure（）</span></span><br><span class="line"><span class="string">const router = new Router(&#123;routers: [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">path: &quot;</span>/login<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">component: r =&gt; require.ensure([, () =&gt; r(require(@/components/login/Login&#x27;</span>)), <span class="string">&quot;login&#x27;)),</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">path: &#x27;/home&#x27;,</span></span><br><span class="line"><span class="string">component: r =&gt; require.ensure([, () =&gt; r(require(&#x27;@/components/home/Home&#x27;)), &#x27;home&#x27;)&#125;,</span></span><br><span class="line"><span class="string">l]&#125;)</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h2 id="20-DOM-与BOM-的理解？-BOIM和DOM的区别？"><a href="#20-DOM-与BOM-的理解？-BOIM和DOM的区别？" class="headerlink" title="20.DOM 与BOM 的理解？ BOIM和DOM的区别？"></a>20.DOM 与BOM 的理解？ BOIM和DOM的区别？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">BOM</span>:</span><br><span class="line">浏览器对象模型 (<span class="variable language_">document</span> alert loaction.<span class="property">href</span> screen)</span><br><span class="line">常用属性：location.<span class="property">href</span> 获取当前页面的url 跳转到指定url</span><br><span class="line"><span class="title class_">Location</span>.<span class="property">hostname</span> 获取url主机部分</span><br><span class="line"><span class="title class_">Loaction</span>.<span class="property">pathname</span> 获取url 主机部分</span><br><span class="line"><span class="title class_">Location</span>.<span class="title function_">reload</span>()刷新当前页面</span><br><span class="line"><span class="title class_">Window</span>.<span class="property">history</span></span><br><span class="line"><span class="title class_">History</span>.<span class="title function_">back</span>() history.<span class="title function_">forward</span>() history. <span class="title function_">go</span>()</span><br><span class="line"><span class="title class_">History</span>.<span class="title function_">pushState</span>(data,title,url) 手动添加历史记录 并保持状态</span><br><span class="line"><span class="title class_">History</span>.<span class="title function_">replaceState</span>(data,title,url)</span><br><span class="line"><span class="variable constant_">DOM</span> 也属于<span class="variable constant_">BOM</span>的一部分，<span class="variable constant_">DOM</span>（docment）</span><br><span class="line"></span><br><span class="line"><span class="attr">DOM</span>:文档对象模型（<span class="variable language_">document</span> object model）</span><br><span class="line">在浏览器中以对象呈现文档，可以使用js对其操作</span><br><span class="line">以为<span class="variable constant_">DOM</span>中的元素一树状表示层级关系，所以又称为<span class="variable constant_">DOM</span>树 </span><br><span class="line"><span class="title class_">Document</span>类型 代表整个页面文档（选择元素或者创建新的元素）</span><br><span class="line"><span class="title class_">NodeList</span> 类型 代表<span class="variable constant_">DOM</span>节点的集合</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="21-捕获和冒泡？中途中阻止冒泡执行？"><a href="#21-捕获和冒泡？中途中阻止冒泡执行？" class="headerlink" title="21.捕获和冒泡？中途中阻止冒泡执行？"></a>21.捕获和冒泡？中途中阻止冒泡执行？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.事件冒泡</span><br><span class="line">微软提出了名为事件冒泡的事件流。这个事件流是从内而外的去触发事件，</span><br><span class="line">即从触发事件的那个节点一直到document。也可以理解为自下而上。</span><br><span class="line">上述代码，如果在事件冒泡的情况下，触发p元素的click事件的顺序应该是：p-&gt;div-&gt;body-&gt;html-&gt;document</span><br><span class="line">2.事件捕获</span><br><span class="line">网景提出了另一种事件流名为事件捕获（event capturing）。</span><br><span class="line">与事件冒泡相反，事件捕获的事件流是从最外层开始发生，直到被触发的具体元素。也可以理解为自上而下。</span><br><span class="line">上述代码中，如果在事件捕获的情况下，触发p元素的click事件的顺序应该是：document-&gt;html-&gt;body-&gt;div-&gt;p</span><br><span class="line">22.vue双向数据绑定怎么实现？</span><br><span class="line">Vue的双向绑定是指数据变化能引起界面的变化，界面数据的变化也能驱动数据的改变。</span><br><span class="line">vue2 的双向数据绑定是利用ES5 的一个 API Object.definePropert()对数据进行劫持 结合 发布订阅模式的方式来实现的。</span><br><span class="line">vue3 中使用了 es6 的 ProxyAPI 对数据代理。</span><br><span class="line">相比于vue2.x，使用proxy的优势如下</span><br><span class="line"> 1.vue2的defineProperty只能监听某个属性，不能对全对象监听</span><br><span class="line"> vue3可以直接监听对象而非属性</span><br><span class="line">2.可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）</span><br><span class="line">3.可以监听数组，不用再去单独的对数组做特异性操作 vue3.x可以检测到数组内部数据的变化</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="23-如何何让计算属性设置值？"><a href="#23-如何何让计算属性设置值？" class="headerlink" title="23.如何何让计算属性设置值？"></a>23.如何何让计算属性设置值？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="title function_">uploadImages</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>.<span class="property">refundImages</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">newValue</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">refundImages</span>= newValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="24-组件之间通信方式有哪些-福建光通互联通信有限公司"><a href="#24-组件之间通信方式有哪些-福建光通互联通信有限公司" class="headerlink" title="24.组件之间通信方式有哪些(福建光通互联通信有限公司)"></a>24.组件之间通信方式有哪些(福建光通互联通信有限公司)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>父传子 props</span><br><span class="line"><span class="number">2.</span>子传父 emit</span><br><span class="line"><span class="number">3.</span>使用 event-bus 事件总线，进行任意组件的通信(兄弟组件通信)</span><br><span class="line"><span class="number">4.</span>使用 <span class="title class_">Vuex</span> 共享数据，进行任意组件的通信</span><br><span class="line"><span class="number">5.</span>使用 provide / inject  (不论组件层次有多深，并在其上下游关系成立的时间里始终生效)</span><br></pre></td></tr></table></figure>
<h3 id="25-props-接受字段-只想接受数组类型，怎么配置"><a href="#25-props-接受字段-只想接受数组类型，怎么配置" class="headerlink" title="25.props 接受字段 只想接受数组类型，怎么配置"></a>25.props 接受字段 只想接受数组类型，怎么配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;com&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">                &#123;&#123; age &#125;&#125; </span></span><br><span class="line"><span class="string">                &#123;&#123; sex &#125;&#125;   </span></span><br><span class="line"><span class="string">                &#123;&#123; name &#125;&#125;</span></span><br><span class="line"><span class="string">                &#123;&#123; h &#125;&#125;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        `</span>,</span><br><span class="line">        <span class="attr">props</span>: &#123;</span><br><span class="line">            <span class="comment">// 属性验证就是有属性类型的指定要求</span></span><br><span class="line">             <span class="comment">// 基础的类型检查 (`null` 和 `undefined` 值会通过任何类型验证)</span></span><br><span class="line">            <span class="attr">age</span>: <span class="title class_">Number</span>,</span><br><span class="line">            <span class="comment">// 多个可能的类型</span></span><br><span class="line">            <span class="attr">sex</span>: [<span class="title class_">Boolean</span>,<span class="title class_">String</span>],</span><br><span class="line">            <span class="comment">// 必填的字符串</span></span><br><span class="line">            <span class="attr">name</span>: &#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">                <span class="comment">// 配置为必填的字符串</span></span><br><span class="line">                <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 带有默认值的数字</span></span><br><span class="line">            <span class="attr">h</span>: &#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">                <span class="comment">// 配置默认值</span></span><br><span class="line">                <span class="attr">default</span>: <span class="number">170</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="26-插槽和具名插槽的区别"><a href="#26-插槽和具名插槽的区别" class="headerlink" title="26.插槽和具名插槽的区别"></a>26.插槽和具名插槽的区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">默认插槽就是是匿名插槽，</span><br><span class="line">具名插槽：具名插槽这个和匿名插槽区别就是这个是由名字在标签上加一个slot属性起一个自定义的名字</span><br><span class="line">&lt;body&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">nav-com</span>&gt;</span><span class="tag">&lt;/<span class="name">nav-com</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">nav-com</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:left</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>返回<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">nav-com</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">nav-com</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:left</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>返回<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:right</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- </span></span></span><br><span class="line"><span class="comment"><span class="language-xml">            按照正常理解，一个插槽只能插入一个标签，然而现在一个插槽可以</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">            插入无限个标签。</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">            解决此问题，使得一个插槽只能插入一个标签</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">            需要给插槽起个名字，将指定的标签插入到指定的名字中</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">         --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">nav-com</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/html&quot;</span> <span class="attr">id</span>=<span class="string">&quot;com&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span> 首页 <span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">return</span> &#123;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">created</span>(<span class="params"></span>)&#123;&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">methods</span>:&#123;&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">computed</span>:&#123;&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    app.<span class="title function_">component</span>(<span class="string">&#x27;nav-com&#x27;</span>,&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">template</span>: <span class="string">&#x27;#com&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="27-作用域插槽干什么用？"><a href="#27-作用域插槽干什么用？" class="headerlink" title="27.作用域插槽干什么用？"></a>27.作用域插槽干什么用？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.简单来说，就是子组件data中的数据不能在父组件中使用，很明显，</span><br><span class="line">子组件也不能直接使用父组件的数据【可以使用父子组件通信间接使用】;</span><br><span class="line">2.当子组件做循环，或者某一部分dom结构应该由外部传递进来的时候用作用域插槽。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="28-vue-生命周期有哪些？-福建光通互联通信有限公司"><a href="#28-vue-生命周期有哪些？-福建光通互联通信有限公司" class="headerlink" title="28.vue 生命周期有哪些？(福建光通互联通信有限公司)"></a>28.vue 生命周期有哪些？(福建光通互联通信有限公司)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> beforeCreate（创建前）</span><br><span class="line"><span class="number">2.</span> created （创建后）</span><br><span class="line"><span class="number">3.</span> beforeMount (载入前)</span><br><span class="line"><span class="number">4.</span> mounted （载入后）</span><br><span class="line"><span class="number">5.</span> beforeUpdate （更新前）</span><br><span class="line"><span class="number">6.</span> updated   （更新后）</span><br><span class="line"><span class="number">7.</span> beforeDestroy（ 销毁前）</span><br><span class="line"><span class="number">8.</span> destroyed （销毁后）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="29-父子组件生命周期的执行顺序？"><a href="#29-父子组件生命周期的执行顺序？" class="headerlink" title="29.父子组件生命周期的执行顺序？"></a>29.父子组件生命周期的执行顺序？</h3><p><img src="/2022/05/14/webInterview/web1.png"></p>
<h3 id="30-防抖节流"><a href="#30-防抖节流" class="headerlink" title="30.防抖节流"></a>30.防抖节流</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">防抖：</span><br><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;label for=&quot;btn&quot;&gt;你的快乐我买单&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; id=&quot;btn&quot;&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line"></span><br><span class="line">  const btn=document.querySelector(&#x27;input[type=button]&#x27;)</span><br><span class="line">   </span><br><span class="line">  function payMoney()&#123;</span><br><span class="line">      console.log(&#x27;买单&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//   创建一个防抖函数</span><br><span class="line">function debounce(func,delay)&#123;</span><br><span class="line">    let timer</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">        let context=this</span><br><span class="line">        let args=arguments</span><br><span class="line">        clearInterval(timer)</span><br><span class="line"></span><br><span class="line">        timer=setTimeout(function (params) &#123;</span><br><span class="line">            func.apply(context,arguments)</span><br><span class="line">            console.log(context);</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.addEventListener(&#x27;click&#x27;,debounce(payMoney,2000))</span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">节流：</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function coloring()&#123;</span><br><span class="line">            let r=Math.floor(Math.random()*255)</span><br><span class="line">            let g=Math.floor(Math.random()*255)</span><br><span class="line">            let b=Math.floor(Math.random()*255)</span><br><span class="line">            document.body.style.background=`rgb($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;)`</span><br><span class="line">        &#125;</span><br><span class="line">        function throttle(func,delay)&#123;</span><br><span class="line">            let pre=0</span><br><span class="line">            return function()&#123;</span><br><span class="line">               let now=new Date()</span><br><span class="line">                let context=this</span><br><span class="line">                let args=arguments</span><br><span class="line">                if(now -pre &gt;delay)&#123;</span><br><span class="line">                    func.apply(context,args)</span><br><span class="line">                    pre=now</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    window.addEventListener(&#x27;resize&#x27;,throttle(coloring,2000))</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="31-hash模式和history-有什么区别？"><a href="#31-hash模式和history-有什么区别？" class="headerlink" title="31.hash模式和history 有什么区别？"></a>31.hash模式和history 有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">1.hash: 即地址栏 URL 中的#符号（此 hash 不是密码学里的散列运算）。</span><br><span class="line">	 比如这个 URL：http://www.abc.com/#/hello， hash 的值为 #/hello。</span><br><span class="line">	 它的特点在于：hash 虽然出现在 URL 中， 但不会被包括在 HTTP 请求中，</span><br><span class="line">	 对后端完全没有影响，因此改变 hash 不会重新加载页面。</span><br><span class="line">2.history: 利用了 HTML5 History Interface 中新增的pushState()和replaceState()方法。</span><br><span class="line">	（需要特定浏览器支持） 这两个方法应用于浏览器的历史记录栈，</span><br><span class="line">	在当前已有的back、forward、go的基础之上， 它们提供了对历史记录进行修改的功能。</span><br><span class="line">	只是当它们执行修改时，虽然改变了当前的 URL， 但浏览器不会立即向后端发送请求。</span><br><span class="line">3.hash 就是指 url 尾巴后的 # 号以及后面的字符，history没有底带#，外观上比hash 模式好看些</span><br><span class="line">4. 原理不同：</span><br><span class="line">	 hash原理：hash通过监听浏览器的onhashchange()事件变化，查找对应的路由规则</span><br><span class="line">	 history原理： 利用H5的 history中新增的两个API pushState() 和 replaceState() </span><br><span class="line">	和一个事件onpopstate监听URL变化</span><br><span class="line">	32.axios 的请求方式？请求过程？</span><br><span class="line">axios的请求方法：get、post、put、patch、delete</span><br><span class="line">get：获取数据</span><br><span class="line">post：提交数据（表单提交+文件上传）</span><br><span class="line">put：更新数据（所有数据推送到后端）</span><br><span class="line">patch：更新数据（只将更改的数据推送到后端）</span><br><span class="line">delete：删除数据</span><br><span class="line"></span><br><span class="line">请求步骤（https://www.csdn.net/tags/MtjaYgysNTIxNTMtYmxvZwO0O0OO0O0O.html）：</span><br><span class="line">1.下载依赖，命令行输入下列命令</span><br><span class="line">npm install axios -S</span><br><span class="line">2.在main.js里引入axios</span><br><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">Vue.prototype.$http = axios</span><br><span class="line">3. 在mounted内部进行axios请求</span><br><span class="line">mounted()&#123;</span><br><span class="line">            this.$http.get(&#x27;数据源文件的路径，其路径相对于index.html&#x27;)</span><br><span class="line">            .then((response)=&gt; &#123;</span><br><span class="line">                // 成功以后的执行的代码</span><br><span class="line">                console.log(response);</span><br><span class="line">                // axios请求是异步，this指向了别的地方，需要使用箭头函数</span><br><span class="line">                this.当前文件的数据=response.data.数据;</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(function (error) &#123;</span><br><span class="line">                //失败的时候，执行代码</span><br><span class="line">                console.log(error);</span><br><span class="line">            &#125;)</span><br><span class="line">            .then(function () &#123;</span><br><span class="line">                // always executed</span><br><span class="line">            &#125;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="33-MVVM-MVC-？-福建光通互联通信有限公司"><a href="#33-MVVM-MVC-？-福建光通互联通信有限公司" class="headerlink" title="33.MVVM  MVC ？(福建光通互联通信有限公司)"></a>33.MVVM  MVC ？(福建光通互联通信有限公司)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MVC: MVC即model-view-controller(模型-视图-控制器)是项自的一种分层架构思想，</span><br><span class="line">它把复杂的业务逻辑，抽离为职能单一的小模块，每个模块看似相互独立，</span><br><span class="line">其实又各自有相互依赖关系。它的好处是:保证了模块的智能单一性，方便程序的开发、维护、耦合度低。(react)</span><br><span class="line">MWVVM: MVVM即 Model-View-ViewModel，(模型-视图-控制器)它是一种双向数据绑定的模式，</span><br><span class="line">用viewModel来建立起model数据层和view视图层的连接，数据改变会影响视图，视图改变会影响数据(VUE 双向数据绑定)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="34-讲讲虚拟-DOM"><a href="#34-讲讲虚拟-DOM" class="headerlink" title="34.讲讲虚拟 DOM"></a>34.讲讲虚拟 DOM</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">虚拟 DOM ：虚拟dom本质上就是一个普通的JS对象，用于描述视图的界面结构</span><br><span class="line">			理解：在vue中，每个组件都有一个render函数，每个render函数都会返回一个虚拟dom树，</span><br><span class="line">			这也就意味着每个组件都对应一棵虚拟DOM树</span><br><span class="line">18-1 为什么需要虚拟dom？</span><br><span class="line">	在vue中，渲染视图会调用render函数，这种渲染不仅发生在组件创建时，</span><br><span class="line">	同时发生在视图依赖的数据更新时。如果在渲染时，直接使用真实DOM，</span><br><span class="line">	由于真实DOM的创建、更新、插入等操作会带来大量的性能损耗，从而就会极大的降低渲染效率。</span><br><span class="line">	因此，vue在渲染时，使用虚拟dom来替代真实dom，主要为解决渲染效率的问题</span><br></pre></td></tr></table></figure>

<h3 id="35-link-和import的区别？-福建光通互联通信有限公司"><a href="#35-link-和import的区别？-福建光通互联通信有限公司" class="headerlink" title="35.link 和import的区别？(福建光通互联通信有限公司)"></a>35.link 和import的区别？(福建光通互联通信有限公司)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">1、从属关系区别</span><br><span class="line">@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，</span><br><span class="line">s不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。</span><br><span class="line">2、加载顺序区别</span><br><span class="line">加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。</span><br><span class="line">3、兼容性区别</span><br><span class="line">@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。</span><br><span class="line">4、DOM可控性区别</span><br><span class="line">可以通过 JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。</span><br><span class="line">以上就是link和@import的区别有哪些的详细内容。</span><br><span class="line">36.React和Vue的区别？(福建光通互联通信有限公司)</span><br><span class="line">1.监听数据变化的实现原理不同</span><br><span class="line">Vue本质是MVVM框架，由MVC发展而来；</span><br><span class="line">React是前端组件化框架，由后端组件化发展而来。</span><br><span class="line">2.数据流不同</span><br><span class="line">Vue实现双向绑定：props可以双响绑定，组件与Dom之间可以通过v-moudel绑定。</span><br><span class="line">React不支持双向绑定：提倡单向数据流，称之为onChange/setState模式。</span><br><span class="line">3.组件通信的区别</span><br><span class="line">	Vue中有三种方式可以实现组件通信：</span><br><span class="line">	a. 父组件通过props向子组件传递数据或者回调，虽然可以传递回调，但是一般只传递数据；</span><br><span class="line">	b. 子组件通过事件向父组件发送消息；</span><br><span class="line">	c. 通过Vue2.2中新增的provide/inject来实现父组件向子组件注入数据，可以跨越多个层级。</span><br><span class="line">React中有三种方式实现组件通信：</span><br><span class="line">	a. 父组件通过props向子组件传递数据或者回调；</span><br><span class="line">	b. 可以通过context进行跨层级的通信；</span><br><span class="line">	c. React本身不支持自定义事件，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数。</span><br><span class="line">4.模板渲染方式不同</span><br><span class="line">	在表层上，模板的语法不同。React是通过jsx来渲染模板，Vue是通过一种拓展的html语法来进行渲染，</span><br><span class="line">	但其实这只是表面现象，毕竟React并不必依赖jsx.</span><br><span class="line">	在深层上，模板的原理不同。本质的区别在于：React是在组件js代码中，</span><br><span class="line">	通过原生js实现模板汇总的常见语法，比如插值、条件、循环等，都是通过js语法实现，</span><br><span class="line">	更加纯粹、原生；而Vue是在和组件js代码分离的单独模板中，通过指令来实现的，比如条件语句v-if。</span><br><span class="line">5.模板渲染过程不同</span><br><span class="line">	Vue可以更快的计算出Virtual Dom的差异，这是由于它在渲染过程中，会跟踪每个组件的依赖关系，不需要更新渲染整个组件树。</span><br><span class="line">	React在应用的状态被改变时，全部子组件都会重新渲染。</span><br><span class="line">	通过shouldComponentUpdate这个生命周期函数可以进行控制，但Vue将次视为默认的优化。</span><br><span class="line">	如果应用中交互复杂，需要处理大量的UI变化，那么使用Virtual Dom是一个好主意，如果更新不频繁，可以直接操控DOM。</span><br><span class="line">6.框架本质不同</span><br><span class="line">Vue本职是MVVM框架，有MVC发展而来。</span><br><span class="line">React是前端组件框架，有都断组件演化而来。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="37-http-创建状态码？"><a href="#37-http-创建状态码？" class="headerlink" title="37.http 创建状态码？"></a>37.http 创建状态码？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">100-199 用于指定客户端应相应的某些动作。</span><br><span class="line">200-299 用于表示请求成功。</span><br><span class="line">300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。（重定向）</span><br><span class="line">400-499 用于指出客户端的错误。</span><br><span class="line">500-599 用于支持服务器错误。  </span><br></pre></td></tr></table></figure>
<h3 id="38-什么是跨域？解决跨域的方法有哪些？"><a href="#38-什么是跨域？解决跨域的方法有哪些？" class="headerlink" title="38.什么是跨域？解决跨域的方法有哪些？"></a>38.什么是跨域？解决跨域的方法有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制。</span><br><span class="line">所谓同源是指，域名，协议，端口均相同，不明白没关系，举个栗子：</span><br><span class="line">http://www.123.com/index.html 调用 http://www.123.com/server.php （非跨域）</span><br><span class="line">http://www.123.com/index.html 调用 http://www.456.com/server.php （主域名不同:123/456，跨域）</span><br><span class="line">http://abc.123.com/index.html 调用 http://def.123.com/server.php （子域名不同:abc/def，跨域）</span><br><span class="line">http://www.123.com:8080/index.html 调用 http://www.123.com:8081/server.php （端口不同:8080/8081，跨域）</span><br><span class="line">http://www.123.com/index.html 调用 https://www.123.com/server.php （协议不同:http/https，跨域）</span><br><span class="line">请注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。</span><br><span class="line">浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。</span><br><span class="line">解决办法：</span><br><span class="line">1、JSONP：</span><br><span class="line">使用方式就不赘述了，但是要注意JSONP只支持GET请求，不支持POST请求。</span><br><span class="line">2、代理：</span><br><span class="line">例如www.123.com/index.html需要调用www.456.com/server.php，可以写一个接口www.123.com/server.php，</span><br><span class="line">由这个接口在后端去调用www.456.com/server.php并拿到返回值，然后再返回给index.html，</span><br><span class="line">这就是一个代理的模式。相当于绕过了浏览器端，自然就不存在跨域问题。</span><br><span class="line">3、PHP端修改header（XHR2方式）</span><br><span class="line">在php接口脚本中加入以下两句即可：</span><br><span class="line">header(&#x27;Access-Control-Allow-Origin:*&#x27;);//允许所有来源访问</span><br><span class="line">header(&#x27;Access-Control-Allow-Method:POST,GET&#x27;);//允许访问的方式</span><br></pre></td></tr></table></figure>
<h3 id="39-http-与https？-福建光通互联通信有限公司-（）"><a href="#39-http-与https？-福建光通互联通信有限公司-（）" class="headerlink" title="39.http 与https？(福建光通互联通信有限公司)（）"></a>39.http 与https？(福建光通互联通信有限公司)（）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">https://www.runoob.com/w3cnote/http-vs-https.html</span><br><span class="line">HTTP 明文传输，数据都是未加密的，安全性较差，</span><br><span class="line">HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</span><br><span class="line">使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构）</span><br><span class="line">申请证书，一般免费证书较少，因而需要一定费用。</span><br><span class="line">证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</span><br><span class="line">HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，</span><br><span class="line">客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，</span><br><span class="line">还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</span><br><span class="line">http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</span><br><span class="line">HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="40-get请求和post请求的区别？-福建光通互联通信有限公司"><a href="#40-get请求和post请求的区别？-福建光通互联通信有限公司" class="headerlink" title="40.get请求和post请求的区别？(福建光通互联通信有限公司)"></a>40.get请求和post请求的区别？(福建光通互联通信有限公司)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1)get通过url传递，post放在body中</span><br><span class="line">(2)Get的url长度有限制</span><br><span class="line">(3)Get在浏览器回退是无害的，post会再次提交请求</span><br><span class="line">(4)get会主动被浏览器cache，post不会</span><br><span class="line">(5)Get请求信息暴露在url中，不安全</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="41-cookie-和localstorate-sessionstorage的区别（-福建光通互联通信有限公司-）"><a href="#41-cookie-和localstorate-sessionstorage的区别（-福建光通互联通信有限公司-）" class="headerlink" title="41.cookie 和localstorate sessionstorage的区别（(福建光通互联通信有限公司)）"></a>41.cookie 和localstorate sessionstorage的区别（(福建光通互联通信有限公司)）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>存储时间</span><br><span class="line">        cookie：可设置有效期。如果不设置有效期，关闭浏览器就会被清除（会话级别）    </span><br><span class="line">        sessionStorage：存储会话级的数据，关闭浏览器就会被清除</span><br><span class="line">        <span class="variable language_">localStorage</span>：持久化存储，除非手动删除，否则一直存在</span><br><span class="line"><span class="number">2.</span>存储体积</span><br><span class="line">        cookie：一般不超过4kb</span><br><span class="line">        web storage：<span class="title class_">IE8</span>下每个独立的存储空间为10M，其他浏览器实现略有不同，但都比<span class="title class_">Cookie</span>要大很多。</span><br><span class="line"><span class="number">3.</span>操作难易</span><br><span class="line">        cookie：相对麻烦</span><br><span class="line">        web storage：相对简单</span><br><span class="line"><span class="number">4.</span>其他</span><br><span class="line">        cookie数据始终在同源的http请求中携带(即使不需要)，即cookie在浏览器和服务器间来回传递</span><br><span class="line">        cookie数据还有路径（path）的概念，可以限制。cookie只属于某个路径下</span><br><span class="line">用法(增、删、改、查)：</span><br><span class="line"><span class="number">1.</span>cookie</span><br><span class="line">        创建 cookie 如下所示：</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">cookie</span>=<span class="string">&quot;username=XXX&quot;</span>;</span><br><span class="line">        您还可以为 cookie 添加一个过期时间（以 <span class="variable constant_">UTC</span> 或 <span class="variable constant_">GMT</span> 时间）。默认情况下，cookie 在浏览器关闭时删除：</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">cookie</span>=<span class="string">&quot;username=XXX; expires=Thu, 18 Dec 2043 12:00:00 GMT&quot;</span>;</span><br><span class="line">        您可以使用 path 参数告诉浏览器 cookie 的路径。默认情况下，cookie 属于当前页面。</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">cookie</span>=<span class="string">&quot;username=XXX; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;</span>;</span><br><span class="line"></span><br><span class="line">        读取 cookie：</span><br><span class="line">        <span class="keyword">var</span> x = <span class="variable language_">document</span>.<span class="property">cookie</span>;（数据格式 cookie1=value; cookie2=value; cookie3=value;）</span><br><span class="line"></span><br><span class="line">         修改cookie</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">cookie</span>=<span class="string">&quot;username=XXX; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;</span>;</span><br><span class="line"></span><br><span class="line">        删除 cookie 非常简单。您只需要设置 expires 参数为以前的时间即可，</span><br><span class="line">        如下所示，设置为 <span class="title class_">Thu</span>, <span class="number">01</span> <span class="title class_">Jan</span> <span class="number">1970</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="attr">GMT</span>:</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;username=XXX; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;</span>;</span><br><span class="line"></span><br><span class="line">        自定义封装函数</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params">key, value, day, path</span>) &#123;</span><br><span class="line">            <span class="comment">//为了防止用户传入一些影响后期获取cookie截取的字符 对用户传入的值进行转码</span></span><br><span class="line">            value = <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line">            <span class="comment">//现在的时间对象</span></span><br><span class="line">            <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">            <span class="comment">//获取现在的时间戳</span></span><br><span class="line">            <span class="keyword">var</span> time = date.<span class="title function_">getTime</span>();</span><br><span class="line">             <span class="comment">//加上有效期 得到未来的时间戳</span></span><br><span class="line">            time += <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * day;</span><br><span class="line">            <span class="comment">//得到未来的时间对象</span></span><br><span class="line">            date.<span class="title function_">setTime</span>(time);</span><br><span class="line">            <span class="comment">//转换成符合要求的有效期格式</span></span><br><span class="line">            <span class="keyword">var</span> expires = date.<span class="title function_">toGMTString</span>();</span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">cookie</span> = key + <span class="string">&quot;=&quot;</span> + value + <span class="string">&quot;;expires=&quot;</span> + expires + (path ? <span class="string">&quot;;path=&quot;</span> + path : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">getCookie</span>(<span class="params">key</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="property">cookie</span>;</span><br><span class="line">            <span class="keyword">var</span> arr = str.<span class="title function_">split</span>(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i].<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>)[<span class="number">0</span>].<span class="title function_">trim</span>() == key) &#123;</span><br><span class="line">                    <span class="comment">//存入的时候转码了  需要的时候转码回来</span></span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">decodeURIComponent</span>(arr[i].<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>)[<span class="number">1</span>].<span class="title function_">trim</span>()));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        原生js操作起来一般比较麻烦，一般可选用cookie插件提高效率</span><br><span class="line"><span class="number">2.</span>web storage</span><br><span class="line">        保存更改数据语法：</span><br><span class="line">        <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        读取数据语法：</span><br><span class="line">        <span class="keyword">var</span> lastname = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        删除数据语法：</span><br><span class="line">        <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        sessionStorage 亦是如此</span><br><span class="line"><span class="number">41.2</span> 前端 js 有没有封装过什么</span><br><span class="line"><span class="number">1.</span>sessionStorage <span class="variable language_">localStorage</span> 的封装</span><br><span class="line"><span class="comment">// ! 目的：将原来储存对象时出现的问题解决 [object Object]</span></span><br><span class="line"><span class="comment">// ！</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">FZstorage</span> = &#123;</span><br><span class="line">  <span class="attr">setSes</span>: <span class="function">(<span class="params">key, value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ! 传递过来的 value 可能是字符串 可能是其他类型</span></span><br><span class="line">    <span class="comment">// *！我们这里不管什么类型，都将其转换成为字符串</span></span><br><span class="line">    sessionStorage.<span class="title function_">setItem</span>(key, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(value))</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ? 取值</span></span><br><span class="line">  <span class="attr">getSes</span>: <span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value = sessionStorage.<span class="title function_">getItem</span>(key)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(value)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">setSLoc</span>: <span class="function">(<span class="params">key, value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ! 传递过来的 value 可能是字符串 可能是其他类型</span></span><br><span class="line">    <span class="comment">// *！我们这里不管什么类型，都将其转换成为字符串</span></span><br><span class="line">    <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(key, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(value))</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ? 取值</span></span><br><span class="line">  <span class="attr">getLoc</span>: <span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(key)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(value)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ! 删除的方法</span></span><br><span class="line">  <span class="attr">rmLoc</span>: <span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(key)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span>axio的分装</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line">    <span class="comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span></span><br><span class="line">    <span class="comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span></span><br><span class="line">    axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://127.0.0.1:3030&#x27;</span></span><br><span class="line">    <span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(config);</span><br><span class="line">    <span class="comment">// config.url =  &quot;/getUser?name=MAX力&quot;</span></span><br><span class="line">    <span class="comment">// 获取用户信息，判断用户是否登录，如果没有登录先提示用户登录</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 2xx 范围内的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 超出 2xx 范围的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(&#123;<span class="attr">error</span>: <span class="string">&#x27;你非得玩一下吗？&#x27;</span>&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">导出axios</span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url, params, type</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 1. 声明记录的变量</span></span><br><span class="line">            <span class="keyword">let</span> promise</span><br><span class="line">            <span class="comment">// 2. 判断请求的类型</span></span><br><span class="line">            <span class="keyword">if</span>(type.<span class="title function_">toUpperCase</span>() == <span class="string">&#x27;GET&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// get 请求</span></span><br><span class="line">                promise = <span class="title function_">axios</span>(&#123;</span><br><span class="line">                    url,</span><br><span class="line">                    params</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.<span class="title function_">toUpperCase</span>() == <span class="string">&#x27;POST&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// post 请求</span></span><br><span class="line">                promise = <span class="title function_">axios</span>(&#123;</span><br><span class="line">                    url,</span><br><span class="line">                    <span class="attr">data</span>: <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(params),</span><br><span class="line">                    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 处理响应</span></span><br><span class="line">            promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="title function_">resolve</span>(res)</span><br><span class="line">            &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">                <span class="title function_">reject</span>(err)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="42-关于-Promise-面试题"><a href="#42-关于-Promise-面试题" class="headerlink" title="42.关于 Promise 面试题"></a>42.关于 Promise 面试题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)Promise有三种状态，分别是pending、fulfilled和rejected;</span><br><span class="line">(2)Promise的状态一旦改变，就不能再次改变;</span><br><span class="line">(3)Promise中调用resolve或reject并不会终结 Promise 的参数函数的执行;</span><br><span class="line">(4)Promise是同步操作，只有当.then(), resove(),.catch()等操作后才会进入微任务。</span><br></pre></td></tr></table></figure>
<h3 id="43-宏任务包含哪些呢？"><a href="#43-宏任务包含哪些呢？" class="headerlink" title="43.宏任务包含哪些呢？"></a>43.宏任务包含哪些呢？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(1)script(整体代码)</span><br><span class="line">(2)setTimeout</span><br><span class="line">(3)setInterval</span><br><span class="line">(4)I/O</span><br><span class="line">(5)UI交互事件，click，mouseover，mouseleave，alert()等</span><br><span class="line">(6)MessageChannel</span><br><span class="line">(7)setImmediate(Node.js 环境)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="44-微任务包含哪些呢？"><a href="#44-微任务包含哪些呢？" class="headerlink" title="44.微任务包含哪些呢？"></a>44.微任务包含哪些呢？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="title class_">Promise</span>.<span class="title function_">then</span>() .<span class="title function_">catch</span>() .<span class="title function_">finnaly</span>()</span><br><span class="line">(<span class="number">2</span>)<span class="title class_">Object</span>.<span class="property">observe</span></span><br><span class="line">(<span class="number">3</span>)<span class="title class_">MutationObserver</span></span><br><span class="line">(<span class="number">4</span>)process.<span class="title function_">nextTick</span>(<span class="title class_">Node</span>.<span class="property">js</span> 环境)</span><br></pre></td></tr></table></figure>
<h3 id="45-async-await"><a href="#45-async-await" class="headerlink" title="45. async await"></a>45. async await</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">在上面中已经了解到setTimeout和promise的区别（一个是宏任务，一个是微任务）。</span><br><span class="line">那么async await又是怎么回事呢？</span><br><span class="line">async是AsyncFunction构造函数的实例，其中允许使用关键字await。</span><br><span class="line">async无论使用没使用await都会返回一个Promise。</span><br><span class="line">可以说async的函数体，可以看作0个或者多个await表达式构成，</span><br><span class="line">从第一行直到第一个await表达式（如果有）都是同步运行，直到遇到await。</span><br><span class="line">也可以说如果函数体有一个await，async就一定会异步，没有的话就是同步。</span><br><span class="line">  async function foo() &#123;</span><br><span class="line">            await 1</span><br><span class="line">        &#125;</span><br><span class="line">        //等价于</span><br><span class="line">        function foo() &#123;</span><br><span class="line">            return Promise.resolve(1).then(() =&gt; undefined)</span><br><span class="line">        &#125;</span><br><span class="line">做题的时候可以将async await 转换成等价的promise 然后用事件循环去判断执行哪一部。</span><br><span class="line">        async function async1() &#123;</span><br><span class="line">            console.log(&#x27;async1 start&#x27;);</span><br><span class="line">            await async2();</span><br><span class="line">            console.log(&#x27;async1 end&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        async function async2() &#123;</span><br><span class="line">            console.log(&#x27;async2&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        async1()</span><br><span class="line"></span><br><span class="line">        // 上述等价于</span><br><span class="line">        async function async1() &#123;</span><br><span class="line">            console.log(&#x27;async1 start&#x27;);</span><br><span class="line">            new Promise((resolved) =&gt; &#123;</span><br><span class="line">                async2();</span><br><span class="line">                resolved();</span><br><span class="line">            &#125;).then(() =&gt; &#123;</span><br><span class="line">                console.log(&#x27;async1 end&#x27;);</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="46-promise-和settimeout-的区别？"><a href="#46-promise-和settimeout-的区别？" class="headerlink" title="46.promise 和settimeout 的区别？"></a>46.promise 和settimeout 的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)setTimeout 宏任务</span><br><span class="line">(2)promise 微任务</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="47-同步请求和异步请求的区别？"><a href="#47-同步请求和异步请求的区别？" class="headerlink" title="47.同步请求和异步请求的区别？"></a>47.同步请求和异步请求的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)同步就是等这个方法请求完成后，再执行下一个请求方法</span><br><span class="line">(2)异步就是在你请求这个方法的时候，可以在当前的页面写一个ajax请求后台查询对应数据，</span><br><span class="line">然后在后台返回数据，这就在请求页面同时也在请求数据返回其数据，这就是异步请求</span><br></pre></td></tr></table></figure>
<h3 id="48-文档数据库和结构数据库的区别"><a href="#48-文档数据库和结构数据库的区别" class="headerlink" title="48.文档数据库和结构数据库的区别"></a>48.文档数据库和结构数据库的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(1)键值对数据库：redis、memcache</span><br><span class="line">(2)列存储数据库：hbase</span><br><span class="line">(3)文档型数据库：mongdb</span><br><span class="line">(4)图形数据库：graph</span><br><span class="line">文档型数据库：mongdb</span><br><span class="line">？--- 区</span><br><span class="line"> 1. 关系型数据库通过外键关联来建立表与表之间的关系，</span><br><span class="line"> 2. 非关系型数据库通常指数据以对象的形式存储在数据库中，</span><br><span class="line">	而对象之间的关系通过每个对象自身的属性来决定，</span><br><span class="line">	NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，</span><br><span class="line">	尤其是大数据应用难题，包括超大规模数据的存储。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="49-v-html-的作用？-v-text？"><a href="#49-v-html-的作用？-v-text？" class="headerlink" title="49.v-html 的作用？ v-text？"></a>49.v-html 的作用？ v-text？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;插值表达式 把&#123;&#123;&#125;&#125;里面的值插入包含它的标签里面的！</span><br><span class="line">v-text和v-html的区别：v-html可以转义标签和渲染数据，v-text不能转义标签只能渲染数据</span><br><span class="line">&lt;template #content=&quot;&#123;item&#125;&quot;&gt;</span><br><span class="line">&lt;div v-htm1=&quot;item.row.contentt&gt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="50-vue事件监听有哪些修饰符？"><a href="#50-vue事件监听有哪些修饰符？" class="headerlink" title="50.vue事件监听有哪些修饰符？"></a>50.vue事件监听有哪些修饰符？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">事件</span><br><span class="line">	事件执行描述</span><br><span class="line">.stop	阻止事件冒泡</span><br><span class="line">.prevent	阻止浏览器默认事件</span><br><span class="line">.capture	事件捕获</span><br><span class="line">.once	事件只触发一次</span><br><span class="line">.self	只执行自身事件</span><br><span class="line">.passive	告知浏览器不想阻止事件的默认行为</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="51-MVVM-和-MVC的区别？理解？"><a href="#51-MVVM-和-MVC的区别？理解？" class="headerlink" title="51.MVVM 和 MVC的区别？理解？"></a>51.MVVM 和 MVC的区别？理解？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">(1)MVC 是 Model View Controller 的缩写</span><br><span class="line">(2)Model：模型层，是应用程序中用于处理应用程序数据逻辑的部分。</span><br><span class="line">         通常模型对象负责在数据库中存取数据。</span><br><span class="line">(3)View：视图层，用户界面渲染逻辑，通常视图是依据模型数据创建的。</span><br><span class="line">(4)Controller：控制器，数据模型和视图之间通信的桥梁，</span><br><span class="line">              通常控制器负责从事图读取数据，控制用户输入，并向模型发送数据。</span><br><span class="line">MVC的思想：Controller负责将Model的数据用View显示出来，</span><br><span class="line">          换句话说就是在Controller里面把Model的数据赋值给View。</span><br><span class="line">MVC的特点：实现关注点分离，即应用程序中的数据模型与业务和展示逻辑解耦。</span><br><span class="line">          就是将模型和视图之间实现代码分离，松散耦合，使之成为一个更容易开发</span><br><span class="line">		  、维护和测试的客户端应用程序。</span><br><span class="line">MVC的优点：</span><br><span class="line">耦合度低，视图层和业务层分离</span><br><span class="line">重用度高</span><br><span class="line">生命周期成本低</span><br><span class="line">可维护性高</span><br><span class="line">部署快</span><br><span class="line">MVC的缺点：</span><br><span class="line">	不适合小型项目的开发</span><br><span class="line">	视图与控制器间的过于紧密的连接，视图与控制器是相互分离，</span><br><span class="line">	但却是联系紧密的部件，妨碍了他们的独立重用</span><br><span class="line">	降低了视图对模型数据的访问，依据模型操作接口的不同，</span><br><span class="line">	视图可能需要多次调用才能获得足够的显示数据。</span><br><span class="line">	对未变化数据的不必要的频繁访问，也将损害操作性能。</span><br><span class="line">MVC的应用：主要用于中大型项目的分层开发。</span><br><span class="line">MVC的例子： 举一个例子，页面有一个 id 为 container 的 span，点击按钮会让其内容加 1：</span><br><span class="line">view：</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;span id=&quot;container&quot;&gt;0&lt;/span&gt;</span><br><span class="line">            &lt;button id=&quot;btn&quot;&gt;+&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">controller：</span><br><span class="line">    const button = document.getElementById(&#x27;btn&#x27;);</span><br><span class="line">        // 响应视图指令</span><br><span class="line">        button.addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">            const container = document.getElementById(&#x27;container&#x27;);</span><br><span class="line"></span><br><span class="line">            // 调用模型</span><br><span class="line">            add(container);</span><br><span class="line">        &#125;, false);</span><br><span class="line">model：..</span><br><span class="line">function add (node) &#123;</span><br><span class="line">  // 业务逻辑处理</span><br><span class="line">  const currentValue = parseInt(node.innerText);</span><br><span class="line">  const newValue = currentValue + 1;</span><br><span class="line">  </span><br><span class="line">  // 更新视图</span><br><span class="line">  node.innerText = current + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. MVVM</span><br><span class="line">MVVM是Model-View-ViewModel的简写，即模型-视图-视图模型。</span><br><span class="line">Modal：模型，指的是后端传递的数据。</span><br><span class="line">View：视图，指的是所看到的页面。</span><br><span class="line">ViewModal：视图模型，mvvm模式的核心，它是连接view和model的桥梁。主要用来处理业务逻辑</span><br><span class="line">它有两个方向：</span><br><span class="line">一是将模型转化成视图，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。</span><br><span class="line">二是将视图转化成模型，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。</span><br><span class="line">这两个方向都实现的，就是数据的双向绑定。</span><br><span class="line">MVVM的特点： 在MVVM的框架下，视图和模型是不能直接通信的，</span><br><span class="line">			它们通过ViewModal来通信，ViewModel通常要实现一个observer观察者，</span><br><span class="line">			当数据发生变化，ViewModel能够监听到数据的这种变化，</span><br><span class="line">			然后通知到对应的视图做自动更新，而当用户操作视图，</span><br><span class="line">			ViewModel也能监听到视图的变化，然后通知数据做改动，</span><br><span class="line">			这实际上就实现了数据的双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。</span><br><span class="line"></span><br><span class="line">MVVM的优点：</span><br><span class="line"></span><br><span class="line">MVVM模式的主要目的是分离视图（View）和模型（Model），有几大优点：</span><br><span class="line"></span><br><span class="line">	低耦合，视图（View）可以独立于Model变化和修改，</span><br><span class="line">	一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，</span><br><span class="line">	当Model变化的时候View也可以不变。</span><br><span class="line"></span><br><span class="line">	可重用性，可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</span><br><span class="line"></span><br><span class="line">	独立开发，开发人员可以专注于业务逻辑和数据的开发（ViewModel），</span><br><span class="line">	设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xml代码。</span><br><span class="line"></span><br><span class="line">	可测试，界面向来是比较难于测试的，而现在测试可以针对ViewModel来写</span><br><span class="line"></span><br><span class="line">	双向数据绑定，它实现了View和Model的自动同步，当Model的属性改变时，</span><br><span class="line">	不需要手动操作Dom元素，来改变View的显示，而是改变属性后该属性对应View层显示会自动改变</span><br><span class="line"></span><br><span class="line">MVVM适用场景： 适合数据驱动的场景，数据操作比较多的场景</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="52-数据类型有哪些？"><a href="#52-数据类型有哪些？" class="headerlink" title="52.数据类型有哪些？"></a>52.数据类型有哪些？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）基本数据类型</span><br><span class="line">(<span class="number">1</span>)<span class="title class_">String</span></span><br><span class="line">(<span class="number">2</span>)<span class="title class_">Number</span></span><br><span class="line">(<span class="number">3</span>)<span class="title class_">Boolean</span></span><br><span class="line">(<span class="number">4</span>)<span class="literal">undefined</span></span><br><span class="line">(<span class="number">5</span>)<span class="title class_">Null</span></span><br><span class="line">(<span class="number">6</span>)<span class="title class_">Symbol</span></span><br><span class="line">(<span class="number">2</span>)引用数据类型</span><br><span class="line">引用数据类型是值对象类型<span class="title class_">Object</span> type,最常用的是对象<span class="title class_">Object</span>,数组<span class="title class_">Array</span>，函数<span class="title class_">Function</span>和<span class="title class_">Date</span></span><br><span class="line">两种数据类型的区别：</span><br><span class="line"><span class="number">1</span>）声明变量时不同的分配内存</span><br><span class="line"></span><br><span class="line">基本数据类型是存储在栈中的简单数据段，也就是说，他们的值直接存储在变量访问的位置</span><br><span class="line"></span><br><span class="line">引用数据类型是存储在堆中的对象，存储在变量处的值是一个指针，指针存储对象的内存地址</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）不同的访问机制</span><br><span class="line"></span><br><span class="line">	基本数据类型可以直接访问</span><br><span class="line"></span><br><span class="line">	引用数据类型不可以直接访问，在需要访问时首先得到这个对象在堆中的内存地址，</span><br><span class="line">	然后再通过地址去获取对象中的值。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）复制变量时不同</span><br><span class="line"></span><br><span class="line">	基本数据类型再复制完成后是完全独立的，一个改变不影响另一个改变。</span><br><span class="line">	引用数据类型在复制时只是将对象的内存地址赋值给了新变量，</span><br><span class="line">	也就是说两变量都指向了堆内存中的同一个对象，一个的改变会影响另外一个。</span><br><span class="line">	实现互不影响，需要进行深拷贝。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）参数传递时不同</span><br><span class="line"></span><br><span class="line">	js中的参数都是按值传递的</span><br><span class="line">	基本数据类型将变量的值传递给参数后，变量和参数互不影响</span><br><span class="line">	引用数据类型只是将内存地址传进去，因此函数内存参数的改变会体现在外部</span><br><span class="line"><span class="number">3.</span>检验数据类型的方法有哪些？</span><br><span class="line"><span class="number">1</span>)<span class="keyword">typeof</span></span><br><span class="line">返回全部小写字符串，如：‘object’ ‘string’</span><br><span class="line"><span class="keyword">typeof</span>可以判断除了<span class="literal">null</span>以外的基本数据类型</span><br><span class="line"><span class="keyword">typeof</span>只能判断对象类型中的<span class="keyword">function</span>，其它都为objecct</span><br><span class="line"><span class="number">2</span>)<span class="keyword">instanceof</span></span><br><span class="line">A <span class="keyword">instanceof</span> B 返回的是<span class="title class_">Boolean</span>类型的值</span><br><span class="line">B的prototype是否出现在A的原型链（proto）上</span><br><span class="line"><span class="keyword">instanceof</span>可以准确判断对象类型数据，但不能准确检测原始类型。</span><br><span class="line"><span class="number">3</span>)<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">1</span>) 也可以判断<span class="title function_">call</span>()括号里的数据类型</span><br><span class="line"><span class="number">4</span>)<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;1&#x27;</span>).<span class="property">constructor</span>==<span class="title class_">Function</span>); 这种方法只能判断字符串和数字</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">23</span>;</span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;biu~&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>();</span><br><span class="line"><span class="keyword">let</span> bool = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">886</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> udf = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> nul = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="property">constructor</span>); <span class="comment">// [Function: Number]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="property">constructor</span>); <span class="comment">// [Function: Date]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="property">constructor</span>); <span class="comment">// [Function: String]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bool.<span class="property">constructor</span>); <span class="comment">// [Function: Boolean]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="property">constructor</span>); <span class="comment">// [Function: Function]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="property">constructor</span>); <span class="comment">// [Function: RegExp]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array.<span class="property">constructor</span>); <span class="comment">// [Function: Array]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nul.<span class="property">constructor</span>); <span class="comment">// [Function: Array]</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Null</span> 没有 consttructor 方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="53-虚拟dom实现原理"><a href="#53-虚拟dom实现原理" class="headerlink" title="53.虚拟dom实现原理"></a>53.虚拟dom实现原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟dom本质是JavaScript对象，是对真实dom的抽象，比较新老dom树，发现差异，将差异更新到真正的dom当中</span><br></pre></td></tr></table></figure>
<h3 id="54-route和router的区别"><a href="#54-route和router的区别" class="headerlink" title="54.route和router的区别"></a>54.route和router的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">route： “路由信息对象” ，path、params、hash、query、name等路由信息</span><br><span class="line">router： “路由实例对象”， 包括了路由跳转方法（push、replace），钩子函数</span><br><span class="line">router是new vueRouter的实例,route是当前路由的对象</span><br></pre></td></tr></table></figure>
<h3 id="55-v-model原理"><a href="#55-v-model原理" class="headerlink" title="55. v-model原理"></a>55. v-model原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v-bind：绑定响应式数据</span><br><span class="line">触发input事件并传递数据</span><br></pre></td></tr></table></figure>
<h3 id="56-怎么给vue定义全局方法"><a href="#56-怎么给vue定义全局方法" class="headerlink" title="56.怎么给vue定义全局方法"></a>56.怎么给vue定义全局方法</h3><p><a target="_blank" rel="noopener" href="https://github.com/haizlin/fe-interview/issues/556"></a></p>
<h3 id="57-vue-router怎么重定向页面"><a href="#57-vue-router怎么重定向页面" class="headerlink" title="57. vue-router怎么重定向页面"></a>57. vue-router怎么重定向页面</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">路由中配置redirect属性</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="58-路由中怎么配置404页面"><a href="#58-路由中怎么配置404页面" class="headerlink" title="58.路由中怎么配置404页面"></a>58.路由中怎么配置404页面</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path：“*”</span><br></pre></td></tr></table></figure>
<h3 id="59-Es5和es6的区别"><a href="#59-Es5和es6的区别" class="headerlink" title="59.Es5和es6的区别"></a>59.Es5和es6的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">es6特性： 块级作用域、let、const。箭头函数、赋值解构、对象字面量赋值简写、class、promise</span><br></pre></td></tr></table></figure>
<h3 id="60-闭包"><a href="#60-闭包" class="headerlink" title="60.闭包"></a>60.闭包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">闭包就是能读取其他函数内部变量的函数。</span><br><span class="line">优点： 避免全局变量的污染、缓存变量</span><br><span class="line">缺点： 容易造成内存泄漏、增加内存使用量</span><br></pre></td></tr></table></figure>

<h3 id="61-深拷贝的方法"><a href="#61-深拷贝的方法" class="headerlink" title="61.深拷贝的方法"></a>61.深拷贝的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">json.<span class="title function_">parse</span>(json.<span class="title function_">stringify</span>(a)) 此方法的缺点： 会忽略<span class="literal">undefined</span>、忽略symbol、不能处理正则、</span><br><span class="line">不能序列化函数、不能解决循环引用的对象、不能正确处理<span class="keyword">new</span> <span class="title class_">Date</span>（）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="62-数组去重"><a href="#62-数组去重" class="headerlink" title="62.数组去重"></a>62.数组去重</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">es6的set方法：arr2 = […new Set(arr) ];</span><br><span class="line">reduce： </span><br><span class="line">filter：</span><br></pre></td></tr></table></figure>
<h3 id="63-DOM事件分有："><a href="#63-DOM事件分有：" class="headerlink" title="63.DOM事件分有："></a>63.DOM事件分有：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">捕获阶段-目标阶段-冒泡阶段</span><br></pre></td></tr></table></figure>
<h3 id="64-事件代理："><a href="#64-事件代理：" class="headerlink" title="64.事件代理："></a>64.事件代理：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将要监听的元素将绑定到其父元素上，通过冒泡事件监听，提高性能。</span><br></pre></td></tr></table></figure>
<h3 id="65-JavaScript的垃圾回收机制"><a href="#65-JavaScript的垃圾回收机制" class="headerlink" title="65.JavaScript的垃圾回收机制"></a>65.JavaScript的垃圾回收机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。</span><br></pre></td></tr></table></figure>
<h3 id="66-常见的内存泄漏："><a href="#66-常见的内存泄漏：" class="headerlink" title="66.常见的内存泄漏："></a>66.常见的内存泄漏：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a. 全局变量不用var声明</span><br><span class="line">b.    未清除的定时器</span><br><span class="line">c.    闭包</span><br><span class="line">d.    没有清理的dom元素的引用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="67-性能优化"><a href="#67-性能优化" class="headerlink" title="67.性能优化"></a>67.性能优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1)减少请求数量</span><br><span class="line">(2)减小资源大小</span><br><span class="line">(3)优化网络连接</span><br><span class="line">(4)减少重绘回流</span><br><span class="line">(5)webpack优化</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="68-箭头函数的特点"><a href="#68-箭头函数的特点" class="headerlink" title="68.箭头函数的特点"></a>68.箭头函数的特点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.不能作为构造函数，不能使用new</span><br><span class="line">2.改变this指向</span><br><span class="line">3.箭头函数没有原型对象</span><br><span class="line">4.不能使用arguments，使用rest参赛解决</span><br></pre></td></tr></table></figure>
<h3 id="69-跨域解决方案"><a href="#69-跨域解决方案" class="headerlink" title="69.跨域解决方案"></a>69.跨域解决方案</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)jsonp原理</span><br><span class="line">(2)使用script标签没有跨域限制的漏洞，但是也需要服务器支持。优点简单兼容性好，缺点只能使用get请求，不安全（xss攻击）</span><br><span class="line">(3)Cors需要后端和浏览器支持</span><br><span class="line">(4)node中间件代理（两次跨域）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="70-输入url发生了什么"><a href="#70-输入url发生了什么" class="headerlink" title="70.输入url发生了什么"></a>70.输入url发生了什么</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.DNS域名解析</span><br><span class="line">2.Tcp连接（三次握手）</span><br><span class="line">3.浏览器向服务器发送http请求报文</span><br><span class="line">4.服务器向浏览器发送http响应报文</span><br><span class="line">5.浏览器渲染</span><br><span class="line">6.关闭tcp连接（四次握手）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="71-浏览器渲染步骤"><a href="#71-浏览器渲染步骤" class="headerlink" title="71.浏览器渲染步骤"></a>71.浏览器渲染步骤</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1)dom树</span><br><span class="line">2)css树</span><br><span class="line">3)render树</span><br><span class="line">4)遇到script阻塞</span><br><span class="line">5)渲染页面 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="72-304的过程"><a href="#72-304的过程" class="headerlink" title="72.304的过程"></a>72.304的过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1)返回200，直接使用本地缓存，不请求。 返回304，不确定是否可以使用缓存，</span><br><span class="line">请求服务器，服务器认为这次缓存还能用，就会返回304.</span><br></pre></td></tr></table></figure>
<h3 id="73-http常用的状态码"><a href="#73-http常用的状态码" class="headerlink" title="73.http常用的状态码"></a>73.http常用的状态码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1)304 未修改</span><br><span class="line">2)400 错误请求，服务器不理解请求的语法</span><br><span class="line">3)403 禁止 服务器拒绝请求</span><br><span class="line">4)402 无权限</span><br><span class="line">5)404 未找到，没有找到请求的网页</span><br><span class="line">6)405 方法禁用</span><br><span class="line">7)500 服务器错误</span><br><span class="line">8)502 错误网关</span><br><span class="line">9)505 服务器不支持http版本</span><br></pre></td></tr></table></figure>

<h3 id="74-es6的拓展运算符…"><a href="#74-es6的拓展运算符…" class="headerlink" title="74.es6的拓展运算符…"></a>74.es6的拓展运算符…</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对象中的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中</span><br><span class="line">(1)可以将数组转化为参数序列</span><br><span class="line">(2)复制数组</span><br><span class="line">(3)替代函数apply</span><br><span class="line">(4)合并数组</span><br><span class="line">(5)字符串转化为数组</span><br></pre></td></tr></table></figure>
<h3 id="75-New操作符具体做了什么"><a href="#75-New操作符具体做了什么" class="headerlink" title="75.New操作符具体做了什么"></a>75.New操作符具体做了什么</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)～创建一个空对象</span><br><span class="line">(2)～ 设置原型链</span><br><span class="line">(3)～让fn指向obj，并执行fn</span><br><span class="line">(4)～判断fn的类型，并返回</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="76-选用标签的标准"><a href="#76-选用标签的标准" class="headerlink" title="76.选用标签的标准"></a>76.选用标签的标准</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)如果要支持比较老的浏览器（通常是桌面版网页）则不使用新标签</span><br><span class="line">(2)手机平板等网页开发可以使用新标签</span><br><span class="line">(3)不管什么情况下，都应该优先根据语义来选用标签</span><br><span class="line">(4)根据搜索引擎优化的要求和建议选用标签</span><br></pre></td></tr></table></figure>
<h3 id="77-布局"><a href="#77-布局" class="headerlink" title="77.布局"></a>77.布局</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)流式布局</span><br><span class="line">(2)定位</span><br><span class="line">(3)浮动/清除</span><br><span class="line">(4)Flex</span><br><span class="line">(5)布局框架（如Bootstrap栅格）</span><br></pre></td></tr></table></figure>
<h3 id="78-CSS单位与计算"><a href="#78-CSS单位与计算" class="headerlink" title="78.CSS单位与计算"></a>78.CSS单位与计算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1)px</span><br><span class="line">(2)%</span><br><span class="line">(3)rem/em</span><br><span class="line">(4)vw/vh</span><br><span class="line">(5)mm/cm</span><br><span class="line">(6)calc()</span><br></pre></td></tr></table></figure>
<h3 id="79-CSS半透明-透明"><a href="#79-CSS半透明-透明" class="headerlink" title="79.CSS半透明/透明"></a>79.CSS半透明/透明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">大部分标签元素默认是背景透明的，但也有不透明的（如iframe、button、图片等）</span><br><span class="line">1)transparent</span><br><span class="line">2)RGBA</span><br><span class="line">3)HSLA</span><br><span class="line">4)opacity</span><br></pre></td></tr></table></figure>

<h3 id="80-动画"><a href="#80-动画" class="headerlink" title="80.动画"></a>80.动画</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  transition：transition能过渡大部分样式（http://dwz.cn/3NvjUN）而且支持多样式同时过渡，</span><br><span class="line">   注意标签元素上有多个样式类时，与过渡样式相关的最后2个样式会形成过渡效果。</span><br><span class="line">animation：注意使用animation-play-state:paused可以使动画就地暂停，</span><br><span class="line">animation-play-state: ‘’可以使动画在暂停的状态继续进行</span><br><span class="line">jQuery动画：jQuery动画与CSS3动画不同，jQuery动画是js驱动的，</span><br><span class="line">jQuery动画与CSS3动画是互补关系（而非谁取代谁）。jQuery内置了一些动画，</span><br><span class="line">如（fadeIn/slideUp等），也支持通过animate()方法自定义动画。</span><br><span class="line">而且提供了强大的动画控制API，如动画延迟、链式动画（上一个动画结束后开始下一下动画）</span><br><span class="line">、控制动画停止、关闭动画效果、动画频率调整、还可以指定回调函数参与每一个动画的每一步等。</span><br><span class="line">jQuery中的动画返回Deferred对象，因此支持Promise异步编程。jQuery默认不能过渡颜色，使用jQuery.Color插件可以解决问题。</span><br><span class="line">触发动画：CSS一般在页面加载时会自动进行transition和animation，</span><br><span class="line">可以在浏览器的查看器（动画窗格）中观察到标签元素上的动画帧并对动画进行控制及设置不同的速度进行预览。</span><br><span class="line">使用:hover、:active伪类可以配合鼠标指针触发动画效果。通过js添加删除标签元素的样式类时也会触发相应的动画。</span><br><span class="line">jQuery动画的触发和控制由jQuery动画API控制。</span><br><span class="line">动画结束事件/回调：CSS3动画支持DOM事件：animationstart（动画开始时）、animationend（动画结束时）</span><br><span class="line">、animationiteration（动画重复执行时），可以像普通click事件一样使用它们。</span><br><span class="line">jQuery动画通过回调函数获取执行完成通知，</span><br><span class="line">形如：$(..).animate(&#123;css&#125;&lt;, duration&gt;&lt;, easing&gt;&lt;, callbakc&gt;)，因为jQuery动画返回Deferred对象，</span><br><span class="line">所以也可以使用.then(success,fail)或.done(function)等方法得到通知。</span><br><span class="line">同时进行多个动画：在关键帧定义中可以定义多个样式，animation-name也可以指定多个关键帧动画名称。</span><br><span class="line">transition-property也可以指定多个样式。jQuery的animate方法中也可以指定多个样式。</span><br><span class="line">还可以在同一个标签元素上调多次animate方法（分开调用，而不是链式调用）</span><br><span class="line">顺序进行多个动画：可以通过animation-delay、transition-delay延迟，安排出顺序执行效果。</span><br><span class="line">还可以通过监听动画事件在动画结束后再触发下一个动画。jQuery中animate()的链式调用本身就是顺序执行的。</span><br><span class="line">requestAnimationFrame：会与浏览器呈现页面同步配合执行，因此比使用setInterval要更加流畅。</span><br><span class="line">requestAnimationFrame是H5新增的方法，与setInterval相比，没有提供频率的控制方法，</span><br><span class="line">因为它的频率与页面呈现频率是同步的，通常60次/s，相当于16.66667ms一次。</span><br><span class="line">矩阵与图形变换</span><br><span class="line">贝塞尔曲线与时间函数</span><br></pre></td></tr></table></figure>
<h3 id="81-媒体查询与响应式页面"><a href="#81-媒体查询与响应式页面" class="headerlink" title="81.媒体查询与响应式页面"></a>81.媒体查询与响应式页面</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">媒体查询@media赋予CSS探测设备类型和设备属性（如屏幕宽高等）的能力，</span><br><span class="line">之前媒体查询主要用来控制页面打印效果（即针对页面上打印部分定义打印专用样式）；</span><br><span class="line">在移动互联网时代媒体查询对于页面适配各种大小的屏幕至关重要，</span><br><span class="line">可以说媒体查询是响应式页面的核心技术。Bootstrap就是以媒体查询技术为基础的响应式UI框架。</span><br></pre></td></tr></table></figure>
<h3 id="82-浏览器兼容性和Web-App页面"><a href="#82-浏览器兼容性和Web-App页面" class="headerlink" title="82.浏览器兼容性和Web App页面"></a>82.浏览器兼容性和Web App页面</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    浏览器兼容性问题涉及的面比较广，从HTML标签、CSS样式到JS都存在兼容性问题。</span><br><span class="line">    兼容性问题给Web开发造成了额外的成本支出，在兼容性上要求越高，付出的代价越大。</span><br><span class="line">	浏览器的兼容性主要通过测试解决，桌面网页最为困难的是兼容IE6/7/8/</span><br><span class="line">	等老浏览器（可以使用IE Tester或IE11的开发者工具测试）！解决浏览器兼容性没有什么难度，</span><br><span class="line">	繁锁而已，如果要兼容老浏览器，则应放弃使用新功能或者对老浏览器显示友好的提示信息（使开发测试时间增长、成本增加）。</span><br><span class="line">	手机浏览器中最为困难的是Android版的UC浏览器，Android版的UC几乎不支持H5和CSS3，</span><br><span class="line">	甚至是常用的CSS样式有些都不支持，如果项目要兼容UC手机浏览器，那写CSS时，</span><br><span class="line">	就只能使用最基本的样式！也不要指望页面能做多漂亮多复杂了。</span><br><span class="line">	Android系统上除了UC这个奇葩之外，本身的碎片化、更新慢也是大问题。</span><br><span class="line">	如很多手机现在的Android系统还是4.4，甚至更古老（尽管Adnroid7都发布了）。</span><br><span class="line">	如果开发应用内嵌页面，可以建议Android工程师采用腾讯出的WebView控件，</span><br><span class="line">	能够使页面对H5的支持和微信及手机QQ一样好，从而达到和iOS同级别的效果。</span><br><span class="line">	</span><br><span class="line">	直接使用框架可以有效地避免兼容性问题，如各种UI框架和jQuery框架都会考虑兼容性。</span><br><span class="line">	另外使用重置样式表也可以抹平各浏览器的差异。</span><br><span class="line">	在开发Web App时需要注意，移动设备，无论是iOS还是Android都使用Webkit内核，尤其是iOS，需要使用以下样式：</span><br><span class="line">	-webkit-appearance: none;		禁用浏览器特定外观（如按扭等表单元素）</span><br><span class="line">	-webkit-tap-highlight-color: rgba(0,0,0,0);	将触摸时的高亮颜色设为完全透明</span><br><span class="line">	-webkit-touch-callout: none;   禁用页面上的上下文菜单（上面有复制、粘贴等功能）</span><br><span class="line">    -webkit-text-size-adjust: none;	禁用页面自动调整文字大小</span><br><span class="line">-webkit-user-select: none;  	禁止用户选择页面上的文字</span><br><span class="line">回弹滚动</span><br><span class="line">overflow: auto; /* auto | scroll */</span><br><span class="line">-webkit-overflow-scrolling: touch;</span><br><span class="line">另：有一些样式还需要使用-webkit前缀，如：</span><br><span class="line">CSS滤镜要写成-webkit-filter</span><br><span class="line">或者要兼容特别老的iOS或Android系统时CSS3样式要加-webkit前缀</span><br><span class="line">另：如果需要对某些标签进行深度控制，则需要使用-webkit伪类，如：</span><br><span class="line">input[type=range]::-webkit-slider-runnable-track&#123; &#125;</span><br><span class="line">input[type=range]::-webkit-slider-thumb&#123; &#125;</span><br><span class="line">可以控制滑动条的样式</span><br><span class="line">progress::-webkit-progress-bar &#123; &#125;</span><br><span class="line">progress::-webkit-progress-value  &#123; &#125;</span><br><span class="line">可以控制进度条的样式</span><br><span class="line">另：使用meta标签可以要求浏览器支持或关闭某些行为</span><br><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;		禁用手机号探测</span><br><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot;&gt;			禁用email探测</span><br><span class="line">固定到手机桌面（桌面书签）</span><br><span class="line">&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;常伟&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;57x57&quot; href=&quot;icon57.png&quot; /&gt;  </span><br><span class="line">&lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;launch6.png&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;mobile-web-app-title&quot; content=&quot;常伟&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;</span><br><span class="line">关闭iOS键盘首字母自动大写，自动修正</span><br><span class="line">&lt;input type=&quot;text&quot; autocapitalize=&quot;off&quot; /&gt; </span><br><span class="line">&lt;input type=&quot;text&quot; autocorrect=&quot;off&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="83-Vue2-和vue3的区别？"><a href="#83-Vue2-和vue3的区别？" class="headerlink" title="83.Vue2 和vue3的区别？"></a>83.Vue2 和vue3的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1.vue2.0和3.0的初始化就存在着一定区别，</span><br><span class="line">	比如vue3.0可以在安装脚手架同时提前安装好一些项目开发必备的插件，</span><br><span class="line">	并且3.0提供了可视化创建脚手架，可以更加方便的对插件和依赖进行管理和配置，</span><br><span class="line">	同时两个版本的目录结构也是有些许差别的。</span><br><span class="line"></span><br><span class="line">2.  在开发过程中两个版本的使用方法虽然在表面上没有太大的一个区别，</span><br><span class="line">	但是在他的底层方面去看的话区别还是很大的，其中就包括渲染方式，</span><br><span class="line">	数据监听，双向绑定，生命周期，vue3更精准变更通知，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这里着重说一下关于双向绑定的更新，</span><br><span class="line">vue2 的双向数据绑定是利用ES5 的一个 API ，</span><br><span class="line">Object.definePropert()对数据进行劫持 结合 发布订阅模式的方式来实现的。</span><br><span class="line">vue3 中使用了 es6 的 ProxyAPI 对数据代理，</span><br><span class="line">   通过 reactive() 函数给每一个对象都包一层 Proxy，通过 Proxy 监听属性的变化，从而实现对数据的监控。</span><br><span class="line"></span><br><span class="line">这里是引相比于vue2版本，使用proxy的优势如下</span><br><span class="line">1.defineProperty只能监听某个属性，不能对全对象监听</span><br><span class="line">可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）</span><br><span class="line">2.可以监听数组，不用再去单独的对数组做特异性操作,</span><br><span class="line"> 通过Proxy可以直接拦截所有对象类型数据的操作，完美支持对数组的监听。用</span><br><span class="line"></span><br><span class="line">3.另外vue3还新增了一些内置组件和方法，比如vue3可以默认进行懒观察，</span><br><span class="line">使用Function-based API，setup函数，对与插件或对象的一个按需引入，</span><br><span class="line">Computed Value ，新加入了 TypeScript 以及 PWA 的支持等等…</span><br><span class="line">这里着重说一下vue3的一个按需引入</span><br><span class="line"></span><br><span class="line">Vue2.x中new出的实例对象，所有的东西都在这个vue对象上，</span><br><span class="line">这样其实无论你用到还是没用到，都会跑一变，这样不仅提高了性能消耗，也无疑增加了用户加载时间。</span><br><span class="line">而vue3.0中可以用ES module imports按需引入，如：keep-alive内置组件、v-model指令，等等，</span><br><span class="line">不仅我们开发起来更加的便捷，减少了内存消耗，也同时减少了用户加载时间，优化用户体验。</span><br></pre></td></tr></table></figure>
<h3 id="84-插槽原理："><a href="#84-插槽原理：" class="headerlink" title="84.插槽原理："></a>84.插槽原理：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">也就是说在子组件app-layou初始化之前，先创建了子组件子节点对应的slot真实vnode，</span><br><span class="line">再创建了子组件的vnode，创建了子组件vnode不代表子组件已经初始化了，仅仅是类似于元素节点的vnode</span><br><span class="line"></span><br><span class="line">父组件执行render函数生成vnode之后，会通过patch方法将vnode转化为真实dom，</span><br><span class="line">在这个过程里，会将vnode创建为真实dom，然后插入到父vnode对应的真实dom里，</span><br><span class="line">创建组件的真实dom的时候，会执行子组件的初始化操作，就是parse，render，patch，</span><br></pre></td></tr></table></figure>
<h3 id="85-关于vue插槽slot来回传值问题"><a href="#85-关于vue插槽slot来回传值问题" class="headerlink" title="85.关于vue插槽slot来回传值问题"></a>85.关于vue插槽slot来回传值问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">有些情况下，我们需要将组件内的值传给slot插槽，供使用组件的地方调用，</span><br><span class="line">这时候可以给slot一个name属性，在使用组件的地方#name名称接收。</span><br><span class="line"></span><br><span class="line">&lt;swiper <span class="keyword">class</span>=<span class="string">&quot;swiper&quot;</span> :options=<span class="string">&quot;swiperOption&quot;</span> id=<span class="string">&quot;cateCard&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">swiper-slide</span> <span class="attr">v-for</span>=<span class="string">&quot;(category, index) in categories&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;items&quot;</span> <span class="attr">:category</span>=<span class="string">&quot;category.newsList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;swiper-pagination&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;pagination&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/swiper&gt;</span><br><span class="line"></span><br><span class="line">给slot添加有个name属性，并传值</span><br><span class="line">在引用组件处使用 #items=<span class="string">&quot;&#123; category &#125;&quot;</span>接收</span><br><span class="line">&lt;m-list-card icon=<span class="string">&quot;caidan&quot;</span> title=<span class="string">&quot;新闻资讯&quot;</span> :categories=<span class="string">&quot;newsCates&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">items</span>=<span class="string">&quot;&#123; category &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">class</span>=<span class="string">&quot;swiper-centent mt-3 d-flex&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in category&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">sapn</span>&gt;</span>[&#123;&#123; item.categories &#125;&#125;]<span class="tag">&lt;/<span class="name">sapn</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">sapn</span> <span class="attr">class</span>=<span class="string">&quot;mx-2&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">sapn</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">sapn</span> <span class="attr">class</span>=<span class="string">&quot;flex-grow-1&quot;</span>&gt;</span>&#123;&#123; item.title &#125;&#125;<span class="tag">&lt;/<span class="name">sapn</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">sapn</span>&gt;</span>&#123;&#123; item.date &#125;&#125;<span class="tag">&lt;/<span class="name">sapn</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">&lt;/m-list-card&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="86-剧中的方式（俩家公司都问了）"><a href="#86-剧中的方式（俩家公司都问了）" class="headerlink" title="86.剧中的方式（俩家公司都问了）"></a>86.剧中的方式（俩家公司都问了）</h3><h3 id="87-Vuex的使用场景？"><a href="#87-Vuex的使用场景？" class="headerlink" title="87.Vuex的使用场景？"></a>87.Vuex的使用场景？</h3><h3 id="88-什么情况下使用组件？有没有自己封装过组件？"><a href="#88-什么情况下使用组件？有没有自己封装过组件？" class="headerlink" title="88.什么情况下使用组件？有没有自己封装过组件？"></a>88.什么情况下使用组件？有没有自己封装过组件？</h3><h3 id="89-有没有自己写过动画效果？"><a href="#89-有没有自己写过动画效果？" class="headerlink" title="89.有没有自己写过动画效果？"></a>89.有没有自己写过动画效果？</h3><h3 id="90-Vue-和小程序的区别？"><a href="#90-Vue-和小程序的区别？" class="headerlink" title="90.Vue 和小程序的区别？"></a>90.Vue 和小程序的区别？</h3><h3 id="91-Vue2-和vue3的区别？（三家公司都问了）"><a href="#91-Vue2-和vue3的区别？（三家公司都问了）" class="headerlink" title="91.Vue2 和vue3的区别？（三家公司都问了）"></a>91.Vue2 和vue3的区别？（三家公司都问了）</h3><h3 id="92-Window对象有哪些？"><a href="#92-Window对象有哪些？" class="headerlink" title="92.Window对象有哪些？"></a>92.Window对象有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1)window：客户端 JavaScript 顶层对象。每当 &lt;body&gt; 或 &lt;frameset&gt; 标签出现时，window 对象就会被自动创建。</span><br><span class="line">(2)navigator：包含客户端有关浏览器信息。</span><br><span class="line">(3)screen：包含客户端屏幕的信息。</span><br><span class="line">(4)history：包含浏览器窗口访问过的 URL 信息。</span><br><span class="line">(5)location：包含当前网页文档的 URL 信息。</span><br><span class="line">(6)document：包含整个 HTML 文档，可被用来访问文档内容及其所有页面元素。</span><br></pre></td></tr></table></figure>
<h3 id="93-http-和https-结构？"><a href="#93-http-和https-结构？" class="headerlink" title="93.http 和https 结构？"></a>93.http 和https 结构？</h3><h3 id="94-数据结构有了解吗？"><a href="#94-数据结构有了解吗？" class="headerlink" title="94.数据结构有了解吗？"></a>94.数据结构有了解吗？</h3><h3 id="95-——————–2———–"><a href="#95-——————–2———–" class="headerlink" title="95.——————–2———–"></a>95.——————–2———–</h3><h3 id="96-Es3常用语法？"><a href="#96-Es3常用语法？" class="headerlink" title="96.Es3常用语法？"></a>96.Es3常用语法？</h3><h3 id="97-深拷贝-浅拷贝？"><a href="#97-深拷贝-浅拷贝？" class="headerlink" title="97.深拷贝 浅拷贝？"></a>97.深拷贝 浅拷贝？</h3><h3 id="98-如果const-定义数组或者对象了-能改变其中的值吗？"><a href="#98-如果const-定义数组或者对象了-能改变其中的值吗？" class="headerlink" title="98.如果const 定义数组或者对象了 能改变其中的值吗？"></a>98.如果const 定义数组或者对象了 能改变其中的值吗？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">可以：</span><br><span class="line">   const arr=[2,3,4,5,6]</span><br><span class="line">        arr[1]=1</span><br><span class="line">        console.log(arr[1]); // 1</span><br><span class="line">        console.log(arr); // [2,1,4,5,6]</span><br><span class="line">        const list=&#123;</span><br><span class="line">            name:&#x27;哈哈哈&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        list.name=&#x27;呜呜呜&#x27;</span><br><span class="line">console.log(list.name); // 呜呜呜</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="99-git-指令有哪些？每条指令都做了-原理？"><a href="#99-git-指令有哪些？每条指令都做了-原理？" class="headerlink" title="99.git 指令有哪些？每条指令都做了?原理？"></a>99.git 指令有哪些？每条指令都做了?原理？</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/soberw/p/15876442.html"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">(1)git init 初始化一个仓库 ，会将该目录下所有文件交给git管理</span><br><span class="line">(2)git status 查看当前版本管理状态</span><br><span class="line">(3)git add 文件1 文件2… 把有变化的文件(新增的、修改的、删除的) 添加到git暂存区里</span><br><span class="line">(4)git add  将所有改变的文件统一 加入到暂存区里</span><br><span class="line">(5)git rm --cached 文件1 文件2 把暂存区中的文件从暂存区移除</span><br><span class="line">(6)git commit -m ‘提交描述’</span><br><span class="line">(7)git restore 文件1 文件 2 … 放弃文件的改变</span><br><span class="line">(8)git log 查看提交历史</span><br><span class="line">(9)git reflog 查看命令历史</span><br><span class="line">(10)git reset --hard commitid 恢复到指定版本</span><br><span class="line">(11)git remote add origin https://gitee.com/nieps/javademo.git   将本地仓库与远程仓库建立联系</span><br><span class="line">(12)git push -u origin master 将本地代码推送到远程 首次推送</span><br><span class="line">(13)git push -f origin master 强制推送本地代码到远程</span><br><span class="line">(14)git remote 查看远程分支的名称</span><br><span class="line">(15)git remote -v 查看远程分支的名称及远程仓库的地址</span><br><span class="line">(16)git remote rm 远程分支名称 删除要本地仓库与远程仓库的关联关系</span><br><span class="line">(17)git pull niu master 拉取远程服务器代码</span><br><span class="line">(18)git clone 远程分支地址 将远程代码克隆到本地</span><br><span class="line">(19)git 命令 --help 查看命令帮助</span><br><span class="line">(20)git branch 查看当前的分支</span><br><span class="line">(21)git checkout -b 分支的名称 创建并切换到分支上</span><br><span class="line">(22)git switch -c 分支名称 创建并切换到分支上</span><br><span class="line">(23)git branch -d 分支名称 删除分支</span><br><span class="line">(24)git branch 分支的名称 创建分支</span><br><span class="line">(25)git checkout 分支的名称 切换分支</span><br><span class="line">(26)git merge 分支名称 将分支中的内容合并到当前分支</span><br><span class="line">(27)git switch 分支名称 切换到分支上</span><br><span class="line">(28)git tag 标签名 创建一个标签 默认该标签指向最新的commitid</span><br><span class="line">(29)git tag 查看所有标签</span><br><span class="line">(30)git tag 标签名 commitid 给指定的commit打标签</span><br><span class="line">(31)git tag -d 标签名 删除标签</span><br><span class="line">(32)git push 远程分支名称 标签名 将指定标签推送到远程</span><br><span class="line">(33)git push 远程分支名称 --tags 将所有标签推送到远程</span><br><span class="line">(34)删除远程标签：</span><br><span class="line">(35)先删除本地 git tag -d 标签名</span><br><span class="line">(36)删除远程 git push 远程分支名称 :/refs/tags/标签名</span><br><span class="line">(37)git push origin(远程分支名称) 本地分支：远程分支 将本地的分支推送到远程分支</span><br><span class="line">(38)git branch -d 删除本地分支</span><br><span class="line">(39)git push origin(远程分支名称) --delete 远程仓库分支名称</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/14/webInterview/web02.png"></p>
<h3 id="100-Js排序？（https-blog-csdn-net-weixin-46224014-article-details-121231814）"><a href="#100-Js排序？（https-blog-csdn-net-weixin-46224014-article-details-121231814）" class="headerlink" title="100.Js排序？（https://blog.csdn.net/weixin_46224014/article/details/121231814）"></a>100.Js排序？（<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46224014/article/details/121231814%EF%BC%89">https://blog.csdn.net/weixin_46224014/article/details/121231814）</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">01.冒泡排序：</span><br><span class="line">(1)比较所有相邻元素,如果第一个比第二个大，则交换它们</span><br><span class="line">(2)一轮下来保证可以找到一个数是最大的</span><br><span class="line">(3)执行n-1轮，就可以完成排序</span><br><span class="line">//定义一个原生的bubbleSort方法</span><br><span class="line">Array.prototype.bubbleSort = function () &#123;</span><br><span class="line">    for(let i = 0; i &lt; this.length - 1; i += 1) &#123;</span><br><span class="line">        //通过 this.length 次把第一位放到最后,完成排序</span><br><span class="line">        //-i是因为最后的位置是会动态改变的，当完成一次后,最后一位会变成倒数第二位 </span><br><span class="line">        for(let j = 0; j &lt; this.length - 1 - i; j += 1) &#123; </span><br><span class="line">            if(this[j] &gt; this[j+1]) &#123; </span><br><span class="line">                const temp = this[j];</span><br><span class="line">                this[j] = this[j+1];</span><br><span class="line">                this[j+1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const arr = [4,8,0,1,43,53,22,11,0];</span><br><span class="line">arr.bubbleSort();</span><br><span class="line">console.log(arr);</span><br><span class="line">2.选择排序</span><br><span class="line">①　找到数组中的最小值，选中它并将其放置在第一位</span><br><span class="line">②　接着找到第二个最小值，选中它并将其放置到第二位</span><br><span class="line">③　执行n-1轮，就可以完成排序</span><br><span class="line">Array.prototype.selectionSort = function() &#123; </span><br><span class="line">    for(let i = 0; i &lt; this.length - 1; ++i) &#123; </span><br><span class="line">        // 假设最小的值是当前的下标</span><br><span class="line">        let indexMin = i;</span><br><span class="line">        //遍历剩余长度找到最小下标</span><br><span class="line">        for(let j = i; j &lt; this.length; ++j) &#123; </span><br><span class="line">            if(this[j] &lt; this[indexMin] ) &#123; </span><br><span class="line">                indexMin = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(indexMin !== i) &#123; </span><br><span class="line">            //交换当前下标i与最小下标的值，重复this.length次</span><br><span class="line">            const temp = this[i];</span><br><span class="line">            this[i] = this[indexMin];</span><br><span class="line">            this[indexMin] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const arr = [5,4,3,2,1];</span><br><span class="line">arr.selectionSort();</span><br><span class="line">console.log(arr);</span><br><span class="line">3.插入排序</span><br><span class="line">说明：</span><br><span class="line">1.从第二个数开始往前比</span><br><span class="line">2.比它大就往后排</span><br><span class="line">3.以此类推进行到最后一个数</span><br><span class="line">Array.prototype.insertionSort = function() &#123; </span><br><span class="line">    //从第二个数开始往前比</span><br><span class="line">    for(let i = 1; i&lt;this.length; ++i) &#123; </span><br><span class="line">        //先把值保存起来</span><br><span class="line">        const temp = this[i];</span><br><span class="line">        let j = i;</span><br><span class="line">        while(j &gt; 0) &#123; </span><br><span class="line">            if(this[j-1] &gt; temp) &#123; </span><br><span class="line">                this[j] = this[j-1];</span><br><span class="line">            &#125; else &#123; </span><br><span class="line">                //因为已经是排序过的了，如果比上一位大，那就没必要再跟上上位比较了</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            j -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        //这里的j有可能是第0位，也有可能是到了一半停止了</span><br><span class="line">        this[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const arr = [5,4,3,2,1];</span><br><span class="line">arr.insertionSort();</span><br><span class="line">4.归并排序</span><br><span class="line">说明</span><br><span class="line">分: 把数组劈成两半，再递归地对数组进行“分”操作，直到分成一个个单独的数</span><br><span class="line">合：把两个数合并为有序数组，再对有序数组进行合并，直到全部子数组合并为一个完整数组</span><br><span class="line">Array.prototype.mergeSort = function () &#123; </span><br><span class="line">    const rec = (arr) =&gt; &#123;</span><br><span class="line">        //如果数组长度为1，说明切完了，可以直接返回</span><br><span class="line">        if (arr.length === 1) &#123; return arr; &#125;</span><br><span class="line">        //切分数组，把每一项都单独切出来</span><br><span class="line">        const mid = Math.floor(arr.length / 2);</span><br><span class="line">        const left = arr.slice(0,mid);</span><br><span class="line">        const right = arr.slice(mid,arr.length);</span><br><span class="line">        //有序的左边数组</span><br><span class="line">        const orderLeft = rec(left);</span><br><span class="line">        //有序的右边数组</span><br><span class="line">        const orderRight = rec(right);</span><br><span class="line">        //定义一个数组来存放顺序数组</span><br><span class="line">        const res = [];</span><br><span class="line">        // 把左右两个有序的合并为一个有序的返回</span><br><span class="line">        while(orderLeft.length || orderRight.length) &#123; </span><br><span class="line">            if(orderLeft.length &amp;&amp; orderRight.length) &#123; </span><br><span class="line">                res.push(orderLeft[0] &lt; orderRight[0] ? orderLeft.shift() : orderRight.shift())</span><br><span class="line">            &#125; else if (orderLeft.length) &#123; </span><br><span class="line">                res.push(orderLeft.shift());</span><br><span class="line">            &#125; else if (orderRight.length) &#123; </span><br><span class="line">                res.push(orderRight.shift());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;;</span><br><span class="line">    const res = rec(this);</span><br><span class="line">    //拷贝到数组本身</span><br><span class="line">    res.forEach((n,i) =&gt; &#123; this[i] = n; &#125;);</span><br><span class="line">&#125;</span><br><span class="line">const arr = [5,4,3,2,1];</span><br><span class="line">arr.mergeSort();</span><br><span class="line">console.log(arr);</span><br><span class="line">5.快速排序</span><br><span class="line">说明</span><br><span class="line">分区: 从数组中任意选择一个基准，所有比基准小的元素放到基准前面，比基准大的元素放到基准的后面</span><br><span class="line">递归：递归地对基准前后的子数组进行分区</span><br><span class="line">Array.prototype.quickSort = function () &#123; </span><br><span class="line">    const rec = (arr) =&gt; &#123; </span><br><span class="line">       // 预防数组是空的或者只有一个元素, 当所有元素都大于等于基准值就会产生空的数组</span><br><span class="line">       if(arr.length === 1 || arr.length === 0) &#123; return arr; &#125;</span><br><span class="line">       const left = [];</span><br><span class="line">       const right = [];</span><br><span class="line">       //以第一个元素作为基准值   </span><br><span class="line">       const mid = arr[0];</span><br><span class="line">       //小于基准值的放左边，大于基准值的放右边</span><br><span class="line">       for(let i = 1; i &lt; arr.length; ++i) &#123; </span><br><span class="line">           if(arr[i] &lt; mid) &#123; </span><br><span class="line">               left.push(arr[i]);</span><br><span class="line">           &#125; else &#123; </span><br><span class="line">               right.push(arr[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        //递归调用，最后放回数组    </span><br><span class="line">       return [...rec(left),mid,...rec(right)];</span><br><span class="line">    &#125;;</span><br><span class="line">    const res = rec(this);</span><br><span class="line">    res.forEach((n,i) =&gt; &#123; this[i] = n; &#125;)</span><br><span class="line">&#125;</span><br><span class="line">const arr = [2,3,4,5,3,1];</span><br><span class="line">arr.quickSort();</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="101-常用的数据结构"><a href="#101-常用的数据结构" class="headerlink" title="101.常用的数据结构"></a>101.常用的数据结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">数组(Array)</span><br><span class="line">	数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。</span><br><span class="line">	数组可以说是最基本的数据结构，在各种编程语言中都有对应。</span><br><span class="line">	一个数组可以分解为多个数组元素，按照数据元素的类型，</span><br><span class="line">	数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。</span><br><span class="line">	数组还可以有一维、二维以及多维等表现形式。 [5] </span><br><span class="line">栈( Stack)</span><br><span class="line">	栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。</span><br><span class="line">	栈按照先进后出或后进先出的原则来存储数据，</span><br><span class="line">	也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，</span><br><span class="line">	从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。</span><br><span class="line">	栈中没有数据时，称为空栈。 [5] </span><br><span class="line">队列(Queue)</span><br><span class="line">	队列和栈类似，也是一种特殊的线性表。和栈不同的是，</span><br><span class="line">	队列只允许在表的一端进行插入操作，而在另一端进行删除操作。</span><br><span class="line">	一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。</span><br><span class="line">	队列中没有元素时，称为空队列。 [5] </span><br><span class="line">链表( Linked List)</span><br><span class="line">	链表是一种数据元素按照链式存储结构进行存储的数据结构，</span><br><span class="line">	这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，</span><br><span class="line">	每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。</span><br><span class="line">	链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。 [5] </span><br><span class="line">树( Tree)</span><br><span class="line">	树是典型的非线性结构，它是包括，2个结点的有穷集合K。在树结构中，</span><br><span class="line">	有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，</span><br><span class="line">	而且可以有两个后继结点，m≥0。 [5] </span><br><span class="line">图(Graph)</span><br><span class="line">	图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，</span><br><span class="line">	而边是顶点的有序偶对。如果两个顶点之间存在一条边，</span><br><span class="line">	那么就表示这两个顶点具有相邻关系。 [5] </span><br><span class="line">堆(Heap)</span><br><span class="line">	堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。</span><br><span class="line">	堆的特点是根结点的值是所有结点中最小的或者最大的，</span><br><span class="line">	并且根结点的两个子树也是一个堆结构。 [5] </span><br><span class="line">散列表(Hash)</span><br><span class="line">	散列表源自于散列函数(Hash function)，</span><br><span class="line">	其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，</span><br><span class="line">	这样就可以不用进行比较操作而直接取得所查记录。 [5] </span><br></pre></td></tr></table></figure>

<h3 id="102-node，npm，vue升级到指定版本"><a href="#102-node，npm，vue升级到指定版本" class="headerlink" title="102.node，npm，vue升级到指定版本"></a>102.node，npm，vue升级到指定版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">node.js安装：https://www.runoob.com/nodejs/nodejs-install-setup.html</span><br><span class="line">node.js下载地址为：https://nodejs.org/en/download/</span><br><span class="line">注意：Linux 上安装 Node.js 需要安装 Python 2.6 或 2.7 ，不建议安装 Python 3.0 以上版本。</span><br><span class="line">nodejs及npm升级到最新版本、指定版本</span><br><span class="line">node有一个模块n，是专门用来管理node.js的版本的。</span><br><span class="line">1、安装n模块：</span><br><span class="line">npm install -g n</span><br><span class="line">2、升级node.js到最新稳定版</span><br><span class="line">n stable</span><br><span class="line">3、安装指定版本：</span><br><span class="line">n v6.11.5</span><br><span class="line">#########################################################</span><br><span class="line">npm 升级到最新版本</span><br><span class="line">//</span><br><span class="line">npm install -g npm</span><br><span class="line">npm升级到指定版本</span><br><span class="line">//比如升级到5.6.0</span><br><span class="line">npm install -g npm@5.6.0</span><br><span class="line">#########################################################</span><br><span class="line">安装最新的vue</span><br><span class="line">npm install -g vue-cli — 这个命令已经废弃了3.0以后</span><br><span class="line">npm install -g @vue/cli</span><br><span class="line">安装指定版本的vue</span><br><span class="line">npm install -g @vue/cli@版本号</span><br><span class="line">例如 ：</span><br><span class="line">npm install -g @vue/cli@3.11.0</span><br><span class="line">卸载vue</span><br><span class="line">npm uninstall -g @vue/cli</span><br><span class="line">#########################################################</span><br><span class="line">vue项目element-ui升级到某版本</span><br><span class="line">1.npm uninstall element-ui 卸载掉当前版本</span><br><span class="line">2.npm install element-ui@2.3.9 -S 安装你想要的版本，</span><br><span class="line">注意element-ui@2.3.9是一项，中间没有空格</span><br><span class="line">3.最后在main.js中把default修改为theme-chalk</span><br><span class="line">// import &#x27;element-ui/lib/theme-default/index.css&#x27;</span><br><span class="line">import &#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="103-Grunt（https-www-it610-com-article-1296113332306124800-htm）"><a href="#103-Grunt（https-www-it610-com-article-1296113332306124800-htm）" class="headerlink" title="103.Grunt（https://www.it610.com/article/1296113332306124800.htm）"></a>103.Grunt（<a target="_blank" rel="noopener" href="https://www.it610.com/article/1296113332306124800.htm%EF%BC%89">https://www.it610.com/article/1296113332306124800.htm）</a></h3><h3 id="104-Array-和-Object-有哪些原生方法？"><a href="#104-Array-和-Object-有哪些原生方法？" class="headerlink" title="104.Array 和 Object 有哪些原生方法？"></a>104.Array 和 Object 有哪些原生方法？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(1)Array.concat( ) 连接数组</span><br><span class="line">(2)Array.join( ) 将数组元素连接起来以构建一个字符串 </span><br><span class="line">(3)Array.length 数组的大小 </span><br><span class="line">(4)Array.pop( ) 删除并返回数组的最后一个元素 </span><br><span class="line">(5)Array.push( ) 给数组添加元素 </span><br><span class="line">(6)Array.reverse( ) 颠倒数组中元素的顺序 </span><br><span class="line">(7)Array.shift( ) 将元素移出数组 </span><br><span class="line">(8)Array.slice( ) 返回数组的一部分 </span><br><span class="line">(9)Array.sort( ) 对数组元素进行排序 </span><br><span class="line">(10)Array.splice( ) 插入、删除或替换数组的元素 </span><br><span class="line">(11)Array.toLocaleString( ) 把数组转换成局部字符串 </span><br><span class="line">(12)Array.toString( ) 将数组转换成一个字符串 </span><br><span class="line">(13)Array.unshift( ) 在数组头部插入一个元素</span><br><span class="line"></span><br><span class="line">(14)Object.hasOwnProperty( ) 检查属性是否被继承</span><br><span class="line">(15)Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型 </span><br><span class="line">(16)Object.propertyIsEnumerable( ) 是否可以通过for/in循环看到属性 </span><br><span class="line">(17)Object.toLocaleString( ) 返回对象的本地字符串表示 </span><br><span class="line">(18)Object.toString( ) 定义一个对象的字符串表示 </span><br><span class="line">(19)Object.valueOf( ) 指定对象的原始值</span><br></pre></td></tr></table></figure>
<h3 id="105-Eslin-？http-eslint-cn-docs-user-guide-getting-started"><a href="#105-Eslin-？http-eslint-cn-docs-user-guide-getting-started" class="headerlink" title="105.Eslin ？http://eslint.cn/docs/user-guide/getting-started"></a>105.Eslin ？<a target="_blank" rel="noopener" href="http://eslint.cn/docs/user-guide/getting-started">http://eslint.cn/docs/user-guide/getting-started</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ESLint  是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。</span><br><span class="line">		不管是多人合作还是个人项目，代码规范是很重要的。</span><br><span class="line">		这样做不仅可以很大程度地避免基本语法错误，也保证了代码的可读性。</span><br><span class="line">		这所谓工欲善其事，必先利其器，推荐 ESLint+vscode 来写 vue，有种飞一般的感觉。</span><br></pre></td></tr></table></figure>
<h3 id="106-Call-和-apply-的区别与应用"><a href="#106-Call-和-apply-的区别与应用" class="headerlink" title="106. Call 和 apply 的区别与应用?"></a>106. Call 和 apply 的区别与应用?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1、简介：</span><br><span class="line">	call，apply都属于Function.prototype的一个方法，它是JavaScript引擎内在实现的，</span><br><span class="line">	因为属于Function.prototype，所以每个Function对象实例(就是每个方法)都有call，apply属性。</span><br><span class="line">	既然作为方法的属性，那它们的使用就当然是针对方法的了，这两个方法是容易混淆的，</span><br><span class="line">	因为它们的作用一样，只是使用方式不同。</span><br><span class="line">2、作用：</span><br><span class="line">call（）方法和apply（）方法的作用相同：改变this指向。</span><br><span class="line">3、他们的区别在于接收参数的方式不同：</span><br><span class="line">call（）：第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。</span><br><span class="line">         在使用call（）方法时，传递给函数的参数必须逐个列举出来。</span><br><span class="line">apply（）：传递给函数的是参数数组</span><br><span class="line">代码示例：</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    function A()&#123;</span><br><span class="line">        this.flag = &#x27;A&#x27;;</span><br><span class="line">        this.tip = function()&#123;</span><br><span class="line">            alert(this.flag);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    function B()&#123;</span><br><span class="line">        this.flag = &#x27;B&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    var a = new A();</span><br><span class="line">    var b = new B();</span><br><span class="line">    //a.tip.call(b);    a.tip.apply(b);&lt;/script&gt;</span><br><span class="line">4、代码解释</span><br><span class="line">（1）实例代码定义了两个函数A和B，A中包含flag属性和tip属性(这个属性赋值一个函数)，B中有一个flag属性。</span><br><span class="line">（2）分别创建A和B的对象a和b。</span><br><span class="line">（3）无论是a.tip.call(b);和a.tip.apply(b);运行的结果都是弹出B。</span><br><span class="line">（4）从结果中可以看出call和apply都可以让B对象调用A对象的tip方法，并且修改了this的当前作用对象。</span><br></pre></td></tr></table></figure>
<h3 id="107-JS-开发模式？（https-blog-csdn-net-We-jia-article-details-87792818）"><a href="#107-JS-开发模式？（https-blog-csdn-net-We-jia-article-details-87792818）" class="headerlink" title="107.JS 开发模式？（https://blog.csdn.net/We_jia/article/details/87792818）"></a>107.JS 开发模式？（<a target="_blank" rel="noopener" href="https://blog.csdn.net/We_jia/article/details/87792818%EF%BC%89">https://blog.csdn.net/We_jia/article/details/87792818）</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">一、工厂模式</span><br><span class="line">function stu()&#123;</span><br><span class="line">            var s=new Object();</span><br><span class="line">            s.name=&quot;张三&quot;;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line"> stu()</span><br><span class="line">说明：</span><br><span class="line">在函数中定义对象,并定义对象的各种属性</span><br><span class="line">调用函数，返回对象</span><br><span class="line"></span><br><span class="line">二、构造函数模式</span><br><span class="line">function stu()&#123;  //属性+方法   </span><br><span class="line">            this.name=&quot;张三&quot;;</span><br><span class="line">            this.sex=null;</span><br><span class="line">            this.eat=function ()&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> var Stu=new stu();</span><br><span class="line"> console.log( Stu.name);</span><br><span class="line">说明：</span><br><span class="line">	与工厂方式相比，使用构造函数方式创建对象，</span><br><span class="line">	无需再函数内部重建创建对象，而使用this指代，而且函数无需明确return</span><br><span class="line">	将属性为方法的属性定义到函数之外，这样可以避免重复创建该方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">三、原型模式</span><br><span class="line">function cat()&#123;     </span><br><span class="line">        &#125;</span><br><span class="line">cat.prototype.sex=&quot;母&quot;;   //.利用prototype属性对属性进行定义</span><br><span class="line">cat.prototype.eat=eat;</span><br><span class="line">var eat=function ()&#123;</span><br><span class="line">            return &quot;吃小鱼&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"> var Cat=new cat()</span><br><span class="line">说明：</span><br><span class="line">函数中不对属性进行定义</span><br><span class="line">利用prototype属性对属性进行定义</span><br><span class="line">四、构造函数+原型的js混合的模式（推荐）</span><br><span class="line">  function stu()&#123;  //属性+方法</span><br><span class="line">            this.name=&quot;张三&quot;;</span><br><span class="line">            this.sex=null;</span><br><span class="line">        &#125;</span><br><span class="line">  stu.prototype.eat=function ()&#123;</span><br><span class="line">            return &quot;吃饭&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">  var Stu=new stu();</span><br><span class="line">说明：</span><br><span class="line">该模式是指混合搭配使用构造函数方式和原型方式</span><br><span class="line">将所有属性不是方法的属性定义在函数中（构造函数方式）</span><br><span class="line">将所有属性值为方法的属性利用prototype在函数之外定义（原型方式）</span><br><span class="line">五、构造函数+原型的动态原型模式（推荐）</span><br><span class="line"> function stu()&#123;  //属性+方法</span><br><span class="line">            this.name=&quot;张三&quot;;</span><br><span class="line">            this.sex=null;</span><br><span class="line">            if(typeof prototype_eat==&quot;undefined&quot;)&#123;</span><br><span class="line">                stu.prototype.eat=function ()&#123;</span><br><span class="line">                    return &quot;吃饭&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                prototype_eat=true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  var Stu=new stu();</span><br><span class="line">说明：</span><br><span class="line">1.动态原型方式可以理解为混合构造函数，原型方式的一个特例</span><br><span class="line">2.该模式中,属性为方法的属性直接在函数中进行了定义，但是因为</span><br><span class="line">           if(typeof Parent._lev==&quot;undefined&quot;)&#123;                             </span><br><span class="line">                           Parent._lev=true; </span><br><span class="line">               &#125; </span><br><span class="line">从而保证创建该对象的实例时，属性的方法不会被重复创建</span><br></pre></td></tr></table></figure>

<h3 id="108-如何处理异步？-（https-blog-csdn-net-lancun-web-article-details-109961050）"><a href="#108-如何处理异步？-（https-blog-csdn-net-lancun-web-article-details-109961050）" class="headerlink" title="108.如何处理异步？ （https://blog.csdn.net/lancun_web/article/details/109961050）"></a>108.如何处理异步？ （<a target="_blank" rel="noopener" href="https://blog.csdn.net/lancun_web/article/details/109961050%EF%BC%89">https://blog.csdn.net/lancun_web/article/details/109961050）</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">	解决js异步的方法有很多种，今天就讲解一下如何解决js中的异步问题。</span><br><span class="line">	在讲解异步解决办法之前我们需要知道什么是异步。</span><br><span class="line">	定时器、AJAX、事件绑定等都会引起js的异步行为，今天用js中的定时器为例来讲解，看下题。</span><br><span class="line"></span><br><span class="line">考虑下题中输出的结果为：</span><br><span class="line"></span><br><span class="line">    function getData() &#123;</span><br><span class="line">		setTimeout(function() &#123;</span><br><span class="line">			let name = &#x27;张三&#x27;;</span><br><span class="line">			return name;</span><br><span class="line">		&#125;, 1000);</span><br><span class="line">	&#125;</span><br><span class="line">	console.log(getData());</span><br><span class="line">	</span><br><span class="line">	这里就有很多人会说输出的结果为张三，那就说明你还没有真正理解异步。</span><br><span class="line">	其实真正的输出结果为：undefined。这是因为setTimeout方法为异步方法。</span><br><span class="line">	如果不明白为什么会这样，这里我讲一下js的执行机制大家就会更加明白了。</span><br><span class="line"></span><br><span class="line">js执行机制：</span><br><span class="line">	(1).所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）；</span><br><span class="line">	(2).主线程之外，还存在一个&quot;任务队列&quot;（task queue），</span><br><span class="line">	只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件；</span><br><span class="line">	(3).一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，</span><br><span class="line">	看看里面有哪些事件，那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行；</span><br><span class="line">	(4).主线程不断重复上面的第三步；</span><br><span class="line"></span><br><span class="line">解决异步的方法一（回调函数）：</span><br><span class="line"></span><br><span class="line">  function getData(callback) &#123;</span><br><span class="line">  	setTimeout(function() &#123;</span><br><span class="line">  		let name = &#x27;张三&#x27;;</span><br><span class="line">  		callback(name);</span><br><span class="line">  	&#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line">  getData(function(aaa)&#123;</span><br><span class="line">    console.log(aaa); //等待一秒之后输出 张三</span><br><span class="line">  &#125;)</span><br><span class="line">解决异步的方法二（es6的Promise）：</span><br><span class="line">function getData(resolve, reject)&#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">		var name=&quot;张三&quot;;</span><br><span class="line">		resolve(name);</span><br><span class="line">	&#125;, 1000);</span><br><span class="line">&#125;;</span><br><span class="line">var p = new Promise(getData);</span><br><span class="line">p.then(function(data)&#123;</span><br><span class="line">	console.log(data);//等待一秒之后输出 张三</span><br><span class="line">&#125;)</span><br><span class="line">解决异步的方法三（es7的async/await）：</span><br><span class="line">async用于申明一个异步的function，而await用于等待一个异步方法执行完成。</span><br><span class="line">   async function getData()&#123; //通过async封装异步方法</span><br><span class="line">	   return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">			setTimeout(function() &#123;</span><br><span class="line">				var name = &#x27;张三&#x27;;</span><br><span class="line">				resolve(name);</span><br><span class="line">			&#125;, 1000);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">    async function main()&#123;</span><br><span class="line">		var data = await getData();</span><br><span class="line">		console.log(data);//等待一秒之后输出 张三</span><br><span class="line">	&#125;</span><br><span class="line">	main();</span><br><span class="line">以上就是处理异步最常用的三种方法，不过第一种的回调函数方法是es6之前的处理方法，</span><br><span class="line">容易造成回调地狱，不易维护，不建议过多使用。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="109-Jq-和-js-都能实现对-test-的选择，它们的区别是什么？"><a href="#109-Jq-和-js-都能实现对-test-的选择，它们的区别是什么？" class="headerlink" title="109.Jq 和 js 都能实现对 #test 的选择，它们的区别是什么？"></a>109.Jq 和 js 都能实现对 #test 的选择，它们的区别是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">js可以选择用id和css选择器，jq用css选择器实现</span><br></pre></td></tr></table></figure>
<h3 id="110-使用vue-js-的时候，页面加载数据没加载完后页面会显示双括号，怎么解决？"><a href="#110-使用vue-js-的时候，页面加载数据没加载完后页面会显示双括号，怎么解决？" class="headerlink" title="110.使用vue.js 的时候，页面加载数据没加载完后页面会显示双括号，怎么解决？"></a>110.使用vue.js 的时候，页面加载数据没加载完后页面会显示双括号，怎么解决？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v-cloak指令（没有值）：</span><br><span class="line">1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。</span><br><span class="line">2.使用css配合v-cloak可以解决网速慢时页面展示出双大括号的问题。</span><br></pre></td></tr></table></figure>
<h3 id="111-Hash-模式能使用cookie吗？为什么？"><a href="#111-Hash-模式能使用cookie吗？为什么？" class="headerlink" title="111.Hash 模式能使用cookie吗？为什么？"></a>111.Hash 模式能使用cookie吗？为什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不能</span><br></pre></td></tr></table></figure>
<h3 id="112-Router-和route-的区别？"><a href="#112-Router-和route-的区别？" class="headerlink" title="112.Router 和route 的区别？"></a>112.Router 和route 的区别？</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_58515303/article/details/120814040">区别</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router和route   router是VueRouter的实例对象   route是 当前正在跳转的路由对象</span><br><span class="line">router</span><br><span class="line">router 是VueRouter的实例，router是一个全局的路由对象，</span><br><span class="line">里面有很多的属性和方法 ，比如：router.push,route.options等等</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/14/webInterview/web3.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route</span><br><span class="line">route相当于正在跳转的路由对象，可以从route里面获取hash，name ，path，query，matched等属性方法</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/14/webInterview/web4.png"></p>
<h3 id="113-New-创对象数的过程？"><a href="#113-New-创对象数的过程？" class="headerlink" title="113.New 创对象数的过程？"></a>113.New 创对象数的过程？</h3><h3 id="114-Axios-应该再哪些生命周期里面？为什么？"><a href="#114-Axios-应该再哪些生命周期里面？为什么？" class="headerlink" title="114.Axios 应该再哪些生命周期里面？为什么？"></a>114.Axios 应该再哪些生命周期里面？为什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios 在 vue 的 mounted 生命周期使用, mounted 在 html 加载完成后执行. </span><br><span class="line">因此进行网络数据查询, 需要更新视图的只能在 mounted 生命周期里写.</span><br></pre></td></tr></table></figure>
<h3 id="115-v-for-v-if-一起使用的优先级？"><a href="#115-v-for-v-if-一起使用的优先级？" class="headerlink" title="115.v-for v-if 一起使用的优先级？"></a>115.v-for v-if 一起使用的优先级？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">当它们处于同一节点，v-for 的优先级比 v-if 更高，</span><br><span class="line">这意味着 v-if 将分别重复运行于每个 v-for 循环中。</span><br><span class="line">当你只想为部分项渲染节点时，这种优先级的机制会十分有用，如下：</span><br><span class="line">	&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;</span><br><span class="line">	  &#123;&#123; todo &#125;&#125;&lt;/li&gt;</span><br><span class="line">	上面的代码将只渲染未完成的 todo。</span><br><span class="line">	而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 &lt;template&gt;) 上。如：</span><br><span class="line">	&lt;ul v-if=&quot;todos.length&quot;&gt;</span><br><span class="line">	  &lt;li v-for=&quot;todo in todos&quot;&gt;</span><br><span class="line">		&#123;&#123; todo &#125;&#125;</span><br><span class="line">	  &lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No todos left!&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<h3 id="116-关于-meta-标签（https-blog-csdn-net-m0-51049889-article-details-118552562）"><a href="#116-关于-meta-标签（https-blog-csdn-net-m0-51049889-article-details-118552562）" class="headerlink" title="116.关于 meta 标签（https://blog.csdn.net/m0_51049889/article/details/118552562）"></a>116.关于 meta 标签（<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_51049889/article/details/118552562%EF%BC%89">https://blog.csdn.net/m0_51049889/article/details/118552562）</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">meta 标签共有两个属性，分别是 http-equiv 属性和 name 属性。</span><br><span class="line"></span><br><span class="line">1. name 属性</span><br><span class="line">	name 属性主要用于描述网页，比如网页的关键词，叙述等。</span><br><span class="line">	与之对应的属性值为 content，content 中的内容是对name填入类型的具体描述，便于搜索引擎抓取。</span><br><span class="line">	meta 标签中 name 属性语法格式是</span><br><span class="line">&lt;meta name=&quot;参数&quot; content=&quot;具体的描述&quot;&gt;。</span><br><span class="line">其中 name 属性共有以下几种参数。(A-C 为常用属性)</span><br><span class="line">A. keywords(关键字)</span><br><span class="line">说明：用于告诉搜索引擎，你网页的关键字。</span><br><span class="line">举例：</span><br><span class="line">&lt;meta name=&quot;keywords&quot; content=&quot;Lxxyx,博客，文科生，前端&quot;&gt;</span><br><span class="line">B. description(网站内容的描述)</span><br><span class="line">说明：用于告诉搜索引擎，你网站的主要内容。</span><br><span class="line">举例：</span><br><span class="line">&lt;meta name=&quot;description&quot; content=&quot;文科生，热爱前端与编程。目前大二，这是我的前端博客&quot;&gt;</span><br><span class="line">C. viewport(移动端的窗口)</span><br><span class="line">说明：这个概念较为复杂，具体的会在下篇博文中讲述。</span><br><span class="line">这个属性常用于设计移动端网页。在用bootstrap,AmazeUI等框架时候都有用过viewport。</span><br><span class="line"></span><br><span class="line">举例（常用范例）：</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br><span class="line">D. robots(定义搜索引擎爬虫的索引方式)</span><br><span class="line">说明：robots用来告诉爬虫哪些页面需要索引，哪些页面不需要索引。</span><br><span class="line">content的参数有all,none,index,noindex,follow,nofollow。默认是all。</span><br><span class="line">举例：</span><br><span class="line">&lt;meta name=&quot;robots&quot; content=&quot;none&quot;&gt;</span><br><span class="line">具体参数如下：</span><br><span class="line">	1.none : 搜索引擎将忽略此网页，等价于 noindex，nofollow。</span><br><span class="line">	2.noindex : 搜索引擎不索引此网页。</span><br><span class="line">	3.nofollow: 搜索引擎不继续通过此网页的链接索引搜索其它的网页。</span><br><span class="line">	4.all : 搜索引擎将索引此网页与继续通过此网页的链接索引，等价于 index，follow。</span><br><span class="line">	5.index : 搜索引擎索引此网页。</span><br><span class="line">	6.follow : 搜索引擎继续通过此网页的链接索引搜索其它的网页。</span><br><span class="line">	E. author(作者)</span><br><span class="line">说明：用于标注网页作者</span><br><span class="line">举例：</span><br><span class="line">&lt;meta name=&quot;author&quot; content=&quot;Lxxyx,841380530@qq.com&quot;&gt;</span><br><span class="line">F. generator(网页制作软件)</span><br><span class="line">说明：用于标明网页是什么软件做的</span><br><span class="line">举例: (不知道能不能这样写)：</span><br><span class="line">&lt;meta name=&quot;generator&quot; content=&quot;Sublime Text3&quot;&gt;</span><br><span class="line">G. copyright(版权)</span><br><span class="line">说明：用于标注版权信息</span><br><span class="line">举例：</span><br><span class="line">&lt;meta name=&quot;copyright&quot; content=&quot;Lxxyx&quot;&gt; //代表该网站为Lxxyx个人版权所有。</span><br><span class="line">H. revisit-after(搜索引擎爬虫重访时间)</span><br><span class="line">说明：如果页面不是经常更新，为了减轻搜索引擎爬虫对服务器带来的压力，</span><br><span class="line">可以设置一个爬虫的重访时间。如果重访时间过短，爬虫将按它们定义的默认时间来访问。</span><br><span class="line">举例：</span><br><span class="line">&lt;meta name=&quot;revisit-after&quot; content=&quot;7 days&quot; &gt;</span><br><span class="line">I. renderer(双核浏览器渲染方式)</span><br><span class="line">说明：renderer 是为双核浏览器准备的，用于指定双核浏览器默认以何种方式渲染页面。比如说 360 浏览器。</span><br><span class="line">举例：</span><br><span class="line">&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; //默认webkit内核&lt;meta name=&quot;renderer&quot; content=&quot;ie-comp&quot;&gt; </span><br><span class="line">//默认IE兼容模式&lt;meta name=&quot;renderer&quot; content=&quot;ie-stand&quot;&gt; //默认IE标准模式</span><br><span class="line">2. http-equiv 属性</span><br><span class="line">	介绍之前，先说个小插曲。看文档和博客关于 http-equiv 的介绍时，有这么一句。</span><br><span class="line">	http-equiv 顾名思义，相当于 http 的文件头作用。</span><br><span class="line">	一开始看到这句话的时候，我是迷糊的。因为我看各类技术名词，</span><br><span class="line">	都会习惯性的去记住它的英文全称。equiv 的全称是”equivalent”，</span><br><span class="line">	意思是相等，相当于。然后我脑子里出现了大大的迷惑：“HTTP 相等？”</span><br><span class="line">	后来还准备去 Segmentfault 提问来着。结果在写问题的时候，</span><br><span class="line">	突然反应出 equivalent 还有相当于的意思。意思就是相当于 http 的作用。</span><br><span class="line">	至于文件头是哪儿出来的，估计是从其作用来分析的。</span><br><span class="line">	我认为顾名思义并不能得出”相当于 http 的文件头作用”这个论断。</span><br><span class="line">	这个我所认为的 http-equiv 意思的简介。</span><br><span class="line">	相当于 HTTP 的作用，比如说定义些 HTTP 参数啥的。</span><br><span class="line">meta 标签中 http-equiv 属性语法格式是：</span><br><span class="line">&lt;meta http-equiv=&quot;参数&quot; content=&quot;具体的描述&quot;&gt;</span><br><span class="line">其中 http-equiv 属性主要有以下几种参数：</span><br><span class="line">A. content-Type(设定网页字符集)(推荐使用HTML5的方式)</span><br><span class="line">说明：用于设定网页字符集，便于浏览器解析与渲染页面</span><br><span class="line">举例：</span><br><span class="line">&lt;meta http-equiv=&quot;content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;  //旧的HTML，不推荐</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt; //HTML5设定网页字符集的方式，推荐使用UTF-8</span><br><span class="line">B. X-UA-Compatible(浏览器采取何种版本渲染当前页面)</span><br><span class="line">说明：用于告知浏览器以何种版本来渲染页面。（一般都设置为最新模式，在各大框架中这个设置也很常见。）</span><br><span class="line">举例：</span><br><span class="line"> &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;</span><br><span class="line">  //指定IE和Chrome使用最新版本渲染当前页面</span><br><span class="line">C. cache-control(指定请求和响应遵循的缓存机制)</span><br><span class="line">用法1.</span><br><span class="line">说明：指导浏览器如何缓存某个响应以及缓存多长时间。这一段内容我在网上找了很久，但都没有找到满意的。</span><br><span class="line">最后终于在Google Developers中发现了我想要的答案。</span><br><span class="line">举例:</span><br><span class="line">&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;</span><br><span class="line">共有以下几种用法：</span><br><span class="line">no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。</span><br><span class="line">no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施）</span><br><span class="line">public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果</span><br><span class="line">private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应）</span><br><span class="line">maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，</span><br><span class="line">而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用 60 秒。</span><br><span class="line">参考链接：HTTP 缓存</span><br><span class="line"></span><br><span class="line">用法2.(禁止百度自动转码)</span><br><span class="line">	说明：用于禁止当前页面在移动端浏览时，被百度自动转码。虽然百度的本意是好的，</span><br><span class="line">	但是转码效果很多时候却不尽人意。所以可以在head中加入例子中的那句话，就可以避免百度自动转码了。</span><br><span class="line">举例：</span><br><span class="line">&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;</span><br><span class="line">D. expires(网页到期时间)</span><br><span class="line">说明:用于设定网页的到期时间，过期后网页必须到服务器上重新传输。</span><br><span class="line">举例：</span><br><span class="line">&lt;meta http-equiv=&quot;expires&quot; content=&quot;Sunday 26 October 2016 01:00 GMT&quot; /&gt;</span><br><span class="line">E. refresh(自动刷新并指向某页面)</span><br><span class="line">说明：网页将在设定的时间内，自动刷新并调向设定的网址。</span><br><span class="line">举例:</span><br><span class="line">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2；URL=http://www.lxxyx.win/&quot;&gt; //意思是2秒后跳转向我的博客</span><br><span class="line">F. Set-Cookie(cookie设定)</span><br><span class="line">说明：如果网页过期。那么这个网页存在本地的cookies也会被自动删除。</span><br><span class="line">&lt;meta http-equiv=&quot;Set-Cookie&quot; content=&quot;name, date&quot;&gt; //格式</span><br><span class="line">&lt;meta http-equiv=&quot;Set-Cookie&quot; content=&quot;User=Lxxyx; path=/; expires=Sunday, 10-Jan-16 10:00:00 GMT&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="117-meta-name-”viewport”-content-”width-device-width-initial-scale-1-0”理解"><a href="#117-meta-name-”viewport”-content-”width-device-width-initial-scale-1-0”理解" class="headerlink" title="117.meta name=”viewport” content=”width=device-width,initial-scale=1.0”理解"></a>117.meta name=”viewport” content=”width=device-width,initial-scale=1.0”理解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">viewport的概念</span><br><span class="line">  viewport就是设备的屏幕上能用来显示我们的网页的那一块区域。</span><br><span class="line">content属性值</span><br><span class="line">  &lt;meta name=&quot;viewport&quot;  content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;</span><br><span class="line">  viewport标记，用于指定用户是否可以缩放Web页面，并对相关的选项进行设定。</span><br><span class="line">  width 和height 指令分别指定视区的逻辑宽度和高度。它们的值可以是以像素为单位的数字，</span><br><span class="line">  s也可以是一个特殊的标记符号。如上文代码中device-width即表示，视区宽度应为设备的屏幕宽度。</span><br><span class="line">  类似的，device-height即表示设备的屏幕高度。</span><br><span class="line">  initial-scale用于设置Web页面的初始缩放比例。默认的初始缩放比例值因智能手机浏览器的不同而有所差异，</span><br><span class="line">  通常情况下，设备会在浏览器中呈现出整个Web页面。设为1.0则显示未经缩放的Web页面。</span><br><span class="line">  maximum-scale和minimum-scale用于设置用户对于Web页面缩放比例的限制。值的范围为0.25~10.0之间</span><br><span class="line">  user-scalable指定用户是否可以缩放视区，即缩放Web页面的视图。值为yes时允许用户进行缩放，值为no时不允许缩放。</span><br><span class="line">整个网页在设备内显示时的页面宽度就会等于设备逻辑像素大小，也就是device-width。这个device-width的计算公式为：</span><br><span class="line">设备的物理分辨率/(devicePixelRatio * scale)，</span><br><span class="line">在scale为1的情况下，device-width = 设备的物理分辨率/devicePixelRatio</span><br><span class="line">devicePixelRatio称为设备像素比，每款设备的devicePixelRatio都是已知，并且不变的，</span><br><span class="line">目前高清屏，普遍都是2，不过还有更高的，比如2.5, 3 等，我魅族note的手机的devicePixelRatio就是3。</span><br><span class="line">淘宝触屏版布局的前提就是viewport的scale根据devicePixelRatio动态设置：</span><br><span class="line">css中的1px并不等于设备的1px</span><br><span class="line">在css中我们一般使用px作为单位，在pc浏览器中css的1个像素往往都是对应着电脑屏幕的1个物理像素，</span><br><span class="line">这可能会造成我们的一个错觉，那就是css中的像素就是设备的物理像素。</span><br><span class="line">但实际情况却并非如此，css中的像素只是一个抽象的单位，</span><br><span class="line">在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的。</span><br><span class="line">在为pc浏览器设计的网页中，我们无需对这个津津计较，但在移动设备上，</span><br><span class="line">必须弄明白这点。在早先的移动设备中，屏幕像素密度都比较低，</span><br><span class="line">如iphone3，它的分辨率为320x480，在iphone3上，一个css像素确实是等于一个屏幕物理像素的。</span><br><span class="line">后来随着技术的发展，移动设备的屏幕像素密度越来越高，从iphone4开始，苹果公司便推出了所谓的Retina屏，</span><br><span class="line">分辨率提高了一倍，变成640x960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，</span><br><span class="line">这时，一个css像素是等于两个物理像素的。后来，不同设备上的一个css像素相当于多少个屏幕物理像素，</span><br><span class="line">也因设备的不同而不同，没有一个定论。</span><br><span class="line">还有一个因素也会引起css中px的变化，那就是用户缩放。例如，当用户把页面放大一倍，</span><br><span class="line">那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，</span><br><span class="line">css中1px所代表的物理像素也会减少一倍。关于这点，在文章后面的部分还会讲到。</span><br><span class="line">在移动端浏览器中以及某些桌面浏览器中，**window对象有一个devicePixelRatio属性（设备像素比），</span><br><span class="line">它的官方的定义为：设备分辨率和设备独立像素的比例，</span><br><span class="line">也就是 devicePixelRatio = 设备的物理像素（分辨率） / 独立像素（实际css中像素）。</span><br><span class="line">独立像素也就是设备的宽度（device-width），device-width = 设备分辨率/devicePixelRatio(设备像素比) **。</span><br><span class="line">例如，在Retina屏的iphone上，devicePixelRatio的值为2，也就是说1个css像素相当于2个物理像素。</span><br><span class="line"></span><br><span class="line">参考链接 https://www.jianshu.com/p/64877ce6e893</span><br></pre></td></tr></table></figure>
<h3 id="118-合并单元格"><a href="#118-合并单元格" class="headerlink" title="118.合并单元格"></a>118.合并单元格</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">跨行合并单元格：rowspan=‘合并单元格的个数’，删除多余的单元格</span><br><span class="line">跨列合并单元格：colspan=‘合并单元格的个数’，删除多余的单元格</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="119-Vue-路由的监听方式"><a href="#119-Vue-路由的监听方式" class="headerlink" title="119.Vue 路由的监听方式"></a>119.Vue 路由的监听方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">路由监听方式1： 通过 watch 进行监听</span><br><span class="line">路由监听方式2：通过钩子函数 beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave进行监听</span><br><span class="line">路由监听方式3：全局路由监听 this.$router.beforeEach</span><br><span class="line">路由监听方式1： 通过 watch 进行监听</span><br><span class="line">// 方式1、监听路由 $route 变化</span><br><span class="line">export default&#123;</span><br><span class="line">    watch: &#123;</span><br><span class="line">        $route(to, from)&#123;</span><br><span class="line">            console.log(&#x27;路由变化了&#x27;)</span><br><span class="line">            console.log(&#x27;当前页面路由：&#x27; + to);</span><br><span class="line">            console.log(&#x27;上一个路由：&#x27; + from);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式2、监听路由 $route 变化, 使用handler函数</span><br><span class="line">export default&#123;</span><br><span class="line">    watch: &#123;</span><br><span class="line">        &#x27;$route&#x27;: &#123; // $route可以用引号，也可以不用引号</span><br><span class="line">            handler(to, from)&#123;</span><br><span class="line">            console.log(&#x27;路由变化了&#x27;)</span><br><span class="line">            console.log(&#x27;当前页面路由：&#x27; + to);</span><br><span class="line">            console.log(&#x27;上一个路由：&#x27; + from);</span><br><span class="line">            &#125;,</span><br><span class="line">            deep: true, // 深度监听</span><br><span class="line">            immediate: true, // 第一次初始化渲染就可以监听到</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式3、监听路由 $route 变化,触发methods里的方法</span><br><span class="line">export default&#123;</span><br><span class="line">    watch: &#123;</span><br><span class="line">        &#x27;$route&#x27;: &#x27;initData&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        initData()&#123;</span><br><span class="line">            console.log(&#x27;路由变化了&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式4、监听路由的 path 变化</span><br><span class="line">export default&#123;</span><br><span class="line">    watch: &#123;</span><br><span class="line">        &#x27;$route.path&#x27;(toPath, fromPath)&#123;</span><br><span class="line">            console.log(&#x27;路由变化了&#x27;)</span><br><span class="line">            console.log(&#x27;当前页面路由地址：&#x27; + toPath)</span><br><span class="line">            console.log(&#x27;上一个路由地址：&#x27; + fromPath)</span><br><span class="line">         &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式5、监听路由的 path 变化, 使用handler函数</span><br><span class="line">export default&#123;</span><br><span class="line">    watch: &#123;</span><br><span class="line">        &#x27;$route.path&#x27;: &#123;</span><br><span class="line">            handler(toPath, fromPath)&#123;</span><br><span class="line">                console.log(&#x27;路由变化了&#x27;)</span><br><span class="line">                console.log(&#x27;当前页面路由地址：&#x27; + toPath)</span><br><span class="line">                console.log(&#x27;上一个路由地址：&#x27; + fromPath)</span><br><span class="line">            &#125;,</span><br><span class="line">            deep: true, // 深度监听</span><br><span class="line">            immediate: true, // 第一次初始化渲染就可以监听到</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式6、监听路由的 path 变化,触发methods里的方法</span><br><span class="line">export default&#123;</span><br><span class="line">    watch: &#123;</span><br><span class="line">        &#x27;$route.path&#x27;: &#x27;initData&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        initData()&#123;</span><br><span class="line">            console.log(&#x27;路由变化了&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">路由监听方式2：通过钩子函数 beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave进行监听</span><br><span class="line">export default&#123;</span><br><span class="line">    beforeRouteEnter(to, from, next)&#123;</span><br><span class="line">        // 渲染该组件前调用这个钩子，因此组件还未被创建，不能获取this</span><br><span class="line">        console.log(this) // 结果为：undefined</span><br><span class="line">        console.log(&#x27;beforeRouteEnter&#x27;)</span><br><span class="line">        next()</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeRouteUpdate(to, from, next)&#123;</span><br><span class="line">        //这个组件是被复用的时候调用，比如带有动态参数的路由跳转：/foo/11 跳转到 /foo/12</span><br><span class="line">        console.log(this) // 可以访问this</span><br><span class="line">        console.log(&#x27;beforeRouteUpdate&#x27;)</span><br><span class="line">        next()</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeRouteLeave(to, from, next)&#123;</span><br><span class="line">        // 导航离开当前路由的时候被调用，this可以被访问到</span><br><span class="line">        console.log(this) // 可以访问this</span><br><span class="line">        console.log(&#x27;beforeRouteLeave&#x27;)</span><br><span class="line">        next()</span><br><span class="line">    &#125;,</span><br><span class="line">路由监听方式3：全局路由监听 this.$router.beforeEach</span><br><span class="line">// 方式1、在App.vue的create中进行全局路由监听</span><br><span class="line">export default  &#123;</span><br><span class="line">    name:  &#x27;App&#x27;,</span><br><span class="line">    created() &#123;</span><br><span class="line">        this.$router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">            console.log(to);</span><br><span class="line">            console.log(from);</span><br><span class="line">            next()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式2、在路由文件（/router/index.js）中进行全局路由监听</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import Router from &#x27;vue-router&#x27;</span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">let routes = [</span><br><span class="line">     &#123;</span><br><span class="line">       path: &#x27;/login&#x27;,</span><br><span class="line">       component: resolve =&gt; require([&#x27;@/views/login&#x27;], resolve),</span><br><span class="line">     &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">let router = new Router(&#123;</span><br><span class="line">    mode: &#x27;history&#x27;, // 去掉 url 中的 #</span><br><span class="line">    scrollBehavior: () =&gt; (&#123; y: 0 &#125;),</span><br><span class="line">    base: process.env.VUE_APP_BASE_DOMAIN,</span><br><span class="line">    routes,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    console.log(to);</span><br><span class="line">    console.log(from);</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">    routes</span><br><span class="line">    router</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="120-Promie-同时请求多个url的方法？-async-await-理解？"><a href="#120-Promie-同时请求多个url的方法？-async-await-理解？" class="headerlink" title="120.Promie 同时请求多个url的方法？ async await 理解？"></a>120.Promie 同时请求多个url的方法？ async await 理解？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">可以使用 Promise.all 来实现同时请求：</span><br><span class="line">// 如果都是要转成 jsonconst urls = [&#x27;/api1&#x27;, &#x27;/api2&#x27;]const doSth = async () =&gt; &#123;</span><br><span class="line">  const results = await Promise.all(urls.map(</span><br><span class="line">    url =&gt; fetch(url).then(response =&gt; response.json()) // 注意这个箭头函数，是 map 所执行的</span><br><span class="line">  ))</span><br><span class="line">  console.log(results) // 俩 json</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="121-this-nextTick？（vue2）作用？-https-www-jianshu-com-p-8411bab1b0db"><a href="#121-this-nextTick？（vue2）作用？-https-www-jianshu-com-p-8411bab1b0db" class="headerlink" title="121.this.$nextTick？（vue2）作用？ https://www.jianshu.com/p/8411bab1b0db"></a>121.this.$nextTick？（vue2）作用？ <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8411bab1b0db">https://www.jianshu.com/p/8411bab1b0db</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通过事件改变data数据，然后输出dom，在方法里直接打印的话，</span><br><span class="line">由于dom元素还没有更新， 因此打印出来的还是未改变之前的值，</span><br><span class="line">而通过this.$nextTick()获取到的值为dom更新之后的值.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="121-1-vue中data为什么一个函数？"><a href="#121-1-vue中data为什么一个函数？" class="headerlink" title="121.1.vue中data为什么一个函数？"></a>121.1.vue中data为什么一个函数？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vue中data必须是函数是为了保证组件的独立性和可复用性，</span><br><span class="line">data是一个函数，组件实例化的时候这个函数将会被调用，</span><br><span class="line">返回一个对象，计算机会给这个对象分配一个内存地址，你实例化几次，</span><br><span class="line">就分配几个内存地址，他们的地址都不一样，所以每个组件中的数据不会相互干扰，</span><br><span class="line">改变其中一个组件的状态，其它组件不变。</span><br></pre></td></tr></table></figure>
<h3 id="122-ES6-数组去重的方法？（https-blog-csdn-net-m0-56262444-article-details-116747048）"><a href="#122-ES6-数组去重的方法？（https-blog-csdn-net-m0-56262444-article-details-116747048）" class="headerlink" title="122.ES6 数组去重的方法？（https://blog.csdn.net/m0_56262444/article/details/116747048）"></a>122.ES6 数组去重的方法？（<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_56262444/article/details/116747048%EF%BC%89">https://blog.csdn.net/m0_56262444/article/details/116747048）</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">数组去重的几种方法</span><br><span class="line">一、for循环判断</span><br><span class="line">二、ES6中的Set对象</span><br><span class="line">1、一个数组去重</span><br><span class="line">2、两个数组合并去重（取合集）</span><br><span class="line">三、对象数组去重</span><br><span class="line">四、根据对象数组中的日期计算天数</span><br><span class="line">一、for循环判断</span><br><span class="line">let a=[1,2,4,2,3,1,2,2]</span><br><span class="line">function duplRem(arr) &#123;</span><br><span class="line">    let b=[];</span><br><span class="line">    let flag=true;</span><br><span class="line">    for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; b.length; j++) &#123;</span><br><span class="line">            if (arr[i]==b[j]) &#123;</span><br><span class="line">                 flag=false;</span><br><span class="line">                 break;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                 flag=true;</span><br><span class="line">            &#125;          </span><br><span class="line">        &#125;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            b.push(arr[i]);           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line">let c=duplRem(a);</span><br><span class="line">console.log(c);//(4) [1, 2, 4, 3]</span><br><span class="line">二、ES6中的Set对象</span><br><span class="line">Set对象是一组不重复的值，重复的值会被忽略</span><br><span class="line"></span><br><span class="line">1、一个数组去重</span><br><span class="line">let a=[1,2,4,2,3,1,2,2]</span><br><span class="line">let c=new Set(a);</span><br><span class="line">console.log(c);//Set(4) &#123;1, 2, 4, 3&#125;</span><br><span class="line">2、两个数组合并去重（取合集）</span><br><span class="line">let a=[1,2,4,2,3,1,2,2]</span><br><span class="line">let b=[2,5,2,3,1,5,3,3]</span><br><span class="line">let c=new Set([...a,...b]);</span><br><span class="line">console.log(c);//Set(5) &#123;1, 2, 4, 3, 5&#125;</span><br><span class="line">Set对象，返回的是一个对象，不是数组。不过，Set对象自带Iterator接口，可以用for of遍历。</span><br><span class="line">let a=[1,2,4,2,3,1,2,2]</span><br><span class="line">let c=new Set(a);</span><br><span class="line">for(let val of c)&#123;</span><br><span class="line">    console.log(val);</span><br><span class="line">&#125;</span><br><span class="line">console.log(c);</span><br><span class="line">遍历后可以放到一个新数组中，也可以用Array.from方法将对象转换成数组：</span><br><span class="line"></span><br><span class="line">let a=[1,2,4,2,3,1,2,2]</span><br><span class="line">let c=new Set(a);</span><br><span class="line">let d=Array.from(c);</span><br><span class="line">console.log(d);</span><br><span class="line">三、对象数组去重</span><br><span class="line">用了Set对象，感觉用于数组去重很方便，想如果数组是一个对象数组，是否也可以使用Set来去重。</span><br><span class="line">let a=[</span><br><span class="line">    &#123;name:&quot;刘备&quot;&#125;,</span><br><span class="line">    &#123;name:&quot;刘备&quot;&#125;,</span><br><span class="line">    &#123;name:&quot;刘备&quot;&#125;,</span><br><span class="line">    &#123;name:&quot;刘备&quot;&#125;,</span><br><span class="line">    &#123;name:&quot;刘备&quot;&#125;,</span><br><span class="line">]</span><br><span class="line">let c=new Set(a);</span><br><span class="line">console.log(c);//Set(5) &#123;&#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;&#125;</span><br><span class="line">结果显示并没有达到去重的效果，每个对象都是不一样的。</span><br><span class="line">那么对象数组的去重是否还是需要循环每个对象的值呢？</span><br><span class="line"></span><br><span class="line">四、根据对象数组中的日期计算天数</span><br><span class="line">应用场景：对象数组中有日期，根据日期计算用户共记录的天数</span><br><span class="line">// 对象数组</span><br><span class="line"> [&#123;&quot;aclass&quot;: &quot;兼职&quot;, &quot;date&quot;: &quot;2021-06-24&quot;, &quot;explain&quot;: &quot;小程序&quot;, </span><br><span class="line"> &quot;incomePay&quot;: 1, &quot;money&quot;: &quot;105&quot;&#125;, &#123;&quot;aclass&quot;: &quot;红包&quot;, </span><br><span class="line"> &quot;date&quot;: &quot;2021-06-24&quot;, &quot;explain&quot;: &quot; 家长&quot;, &quot;incomePay&quot;: 1, &quot;money&quot;: &quot;35&quot;&#125;,</span><br><span class="line"> &#123;&quot;aclass&quot;: &quot;购物&quot;, &quot;date&quot;: &quot;2021-06-24&quot;, &quot;explain&quot;: &quot;短袖&quot;, </span><br><span class="line"> &quot;incomePay&quot;: 0, &quot;money&quot;: &quot;55&quot;&#125;, &#123;&quot;aclass&quot;: &quot;餐饮&quot;, </span><br><span class="line"> &quot;date&quot;: &quot;2021-06-24&quot;, &quot;explain&quot;: &quot;午餐&quot;, &quot;incomePay&quot;: 0, &quot;money&quot;: &quot;20&quot;&#125;]</span><br><span class="line">export function dayCount(arr) &#123;</span><br><span class="line">    let daySet =new Set()</span><br><span class="line">    for(let item of arr)&#123;</span><br><span class="line">        daySet.add(item.date)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(daySet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">获得Set对象</span><br><span class="line"> // Set &#123;&quot;2021-06-24&quot;, &quot;2021-06-23&quot;,</span><br><span class="line">  &quot;2021-06-21&quot;, &quot;2021-06-19&quot;, &quot;2021-05-23&quot;, </span><br><span class="line">  &quot;2021-05-16&quot;, &quot;2021-04-23&quot;, &quot;2021-03-23&quot;&#125;</span><br><span class="line">1</span><br><span class="line">返回长度即天数</span><br><span class="line">export function dayCount(arr) &#123;</span><br><span class="line">    let daySet =new Set()</span><br><span class="line">    for(let item of arr)&#123;</span><br><span class="line">        daySet.add(item.date)</span><br><span class="line">    &#125;</span><br><span class="line">    return daySet.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="123-数组去重的方法？"><a href="#123-数组去重的方法？" class="headerlink" title="123.数组去重的方法？"></a>123.数组去重的方法？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">// &lt;!-- 1. 利用ES6 Set去重 --&gt;</span><br><span class="line">        // 2. 方法二：</span><br><span class="line">        // 利用 for  循环嵌套for 循环然后splice去重</span><br><span class="line">        function unique(arr)&#123;</span><br><span class="line">            for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">                for(var j=i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">                    if(arr[i]==arr[j])&#123;</span><br><span class="line">                        arr.splice(j,1)</span><br><span class="line">                    j--</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return arr</span><br><span class="line">        &#125;</span><br><span class="line">        var arr=[1,1,&#x27;true&#x27;,&#x27;true&#x27;]</span><br><span class="line">        console.log(unique(arr));</span><br><span class="line">        // 3.利用indexOf去重</span><br><span class="line">        function unique(arr) &#123;</span><br><span class="line">            if (!Array.isArray(arr)) &#123;</span><br><span class="line">                console.log(&#x27;type error&#x27;);</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            var array=[]</span><br><span class="line">            for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">                if(array.indexOf(arr[i]) ===-1)&#123;</span><br><span class="line">                    array.push(arr[i])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return array</span><br><span class="line">        &#125;</span><br><span class="line">        var arr=[1,1,&#x27;true&#x27;,&#x27;true&#x27;]</span><br><span class="line">        console.log(unique(arr));</span><br><span class="line">    // 4. 利用sort()去重</span><br><span class="line">    function unique(arr)&#123;</span><br><span class="line">        if(!Array.isArray(arr))&#123;</span><br><span class="line">            console.log(&#x27;type error&#x27;);</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        var arr=arr.sort()</span><br><span class="line">        var NewArr=[arr[0]]</span><br><span class="line">        for(var i=1;i&lt;arr.length;i++)&#123;</span><br><span class="line">            if(arr[i] !==arr[i-1])&#123;</span><br><span class="line">                NewArr.push(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return NewArr</span><br><span class="line">    &#125;</span><br><span class="line">    var arr=[1,1,&#x27;true&#x27;,&#x27;true&#x27;]</span><br><span class="line">    console.log(unique(arr));</span><br><span class="line">    // 5. 利用includes</span><br><span class="line">    function unique(arr)&#123;</span><br><span class="line">        if(!Array.isArray(arr))&#123;</span><br><span class="line">            console.log(&#x27;type error&#x27;);</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        var array=[]</span><br><span class="line">        for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">            if(!array.includes(arr[i]))&#123;</span><br><span class="line">                array.push(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return array</span><br><span class="line">    &#125;</span><br><span class="line">    var arr=[1,1,&#x27;true&#x27;,&#x27;true&#x27;]</span><br><span class="line">    console.log(unique(arr));</span><br><span class="line">    // 6. 利用递归去重</span><br><span class="line">    function unique(arr)&#123;</span><br><span class="line">        var array=arr</span><br><span class="line">        var len=array.length</span><br><span class="line">        array.sort(function(a,b)&#123; // 排序后更加方便去重</span><br><span class="line">            return a - b</span><br><span class="line">        &#125;)</span><br><span class="line">        function loop(index)&#123;</span><br><span class="line">            if(index &gt;=1)&#123;</span><br><span class="line">                if(array[index] ===array[index -1])&#123;</span><br><span class="line">                    array.splice(index,1)</span><br><span class="line">                &#125;</span><br><span class="line">                loop(index -1) // 递归loop，然后数组去重</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        loop(len -1)</span><br><span class="line">        return array</span><br><span class="line">    &#125;</span><br><span class="line">    var arr=[1,1,&#x27;true&#x27;,&#x27;true&#x27;]</span><br><span class="line">    console.log(unique(arr));</span><br></pre></td></tr></table></figure>
<h3 id="124-遍历数组有哪些方法？"><a href="#124-遍历数组有哪些方法？" class="headerlink" title="124.遍历数组有哪些方法？"></a>124.遍历数组有哪些方法？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/weixin_44640323/article/details/114284243</span><br><span class="line">第一种：普通for循环</span><br><span class="line">for(var i = 0; i &lt; arr.length;i++  )&#123;</span><br><span class="line">        //代码</span><br><span class="line">    &#125;</span><br><span class="line">第二种：forEach循环</span><br><span class="line">    arr.forEach((item,index,arr)=&gt;&#123;</span><br><span class="line">        //代码</span><br><span class="line">    &#125;)</span><br><span class="line">    forEach接收一个回调函数作为参数,而这个回调函数有接受三个参数,</span><br><span class="line">作为参数。item是每个元素,index元素在数组中的下标,arr数组本身。</span><br><span class="line">    没有返回值！</span><br><span class="line">第三种：map循环</span><br><span class="line">   var brr= arr.map((item,index,arr)=&gt;&#123;</span><br><span class="line">        //代码</span><br><span class="line">        return item * 2;</span><br><span class="line">    &#125;)</span><br><span class="line">    map的用法和forEach差不多。但是map是有返回值的。他的返回值是一个新数组</span><br><span class="line">    arr----&gt;[1,2,3]</span><br><span class="line">    brr----&gt;[2,4,6]</span><br><span class="line">第四种：for–of</span><br><span class="line">    只有是现实iterator 接口的才能用for---of.对象不能</span><br><span class="line">    for(var item of arr)&#123;</span><br><span class="line">        //代码</span><br><span class="line">    &#125;</span><br><span class="line">第五种：filter</span><br><span class="line">    var arr = [</span><br><span class="line">        &#123;name:&#x27;张三&#x27;,age:&#x27;20&#x27;&#125;,</span><br><span class="line">        &#123;name:&#x27;李四&#x27;,age:&quot;50&quot;&#125;</span><br><span class="line">    ]</span><br><span class="line">    arr.filter(item=&gt;&#123;</span><br><span class="line">        return item.name;</span><br><span class="line">        // [张三,李四]</span><br><span class="line">    &#125;)</span><br><span class="line">    arr.filter(item=&gt;&#123;</span><br><span class="line">        return item.age&gt;30;</span><br><span class="line">        //[&#123;name:&quot;李四&quot;,age:&quot;50&quot;&#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">    //接受一个回调函数作为参数,返回值是一个新数组</span><br><span class="line">第六种：every遍历</span><br><span class="line">    every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true。(全部符合条件)</span><br><span class="line">    var arr=[50,6,70,80];</span><br><span class="line">    arr.every((item,index,arr)=&gt;&#123;</span><br><span class="line">        return item &gt; 50; //每一项数据都要大于50</span><br><span class="line">    &#125;)</span><br><span class="line">    //false    </span><br><span class="line">第七种：some遍历</span><br><span class="line">    some()是对数组中每一项运行指定函数，如果该函数对任一项返回true，则返回true。(只要有一个符合)</span><br><span class="line">    var arr=[50,6,70,80];</span><br><span class="line">    arr.some((item,index,arr)=&gt;&#123;</span><br><span class="line">        return item &gt; 50; //只要有一项数据都要大于50</span><br><span class="line">    &#125;)</span><br><span class="line">    //true</span><br><span class="line">第八种：reduce</span><br><span class="line">    reduce()方法接收一个函数作为累加器,数组中每个值(从左往右)开始缩减,最重为一个值</span><br><span class="line">    [1,2,3].reduce((a,b) =&gt; &#123;</span><br><span class="line">        return a + b;//6   </span><br><span class="line">    &#125;)</span><br><span class="line">    [1,2,3].reduce((previousValue,currentValue,index,arr)=&gt;&#123;</span><br><span class="line">        return previousValue + currentValue;</span><br><span class="line">    &#125;)</span><br><span class="line">    reduce还有第二个参数，我们可以把这个参数作为第一次调用callback时的第一个参数，</span><br><span class="line">   上面这个例子因为没有第二个参数，所以直接从数组的第二项开始，如果我们给了第二个参数为5</span><br><span class="line">     [1,2,3].reduce((previousValue,currentValue,index,arr)=&gt;&#123;</span><br><span class="line">        return previousValue + currentValue;</span><br><span class="line">    &#125;,5)</span><br><span class="line">    // 6, 8 ,11</span><br><span class="line">    第一次调用的previousValue的值就用传入的第二个参数代替，</span><br><span class="line">第九种：reduceRight</span><br><span class="line">    reduceRight()方法的功能和reduce()功能是一样的，</span><br><span class="line">   不同的是reduceRight()从数组的末尾向前将数组中的数组项做累加。</span><br><span class="line">    reduceRight()首次调用回调函数callbackfn时，prevValue 和 curValue 可以是两个值之一。</span><br><span class="line">   如果调用 reduceRight() 时提供了 initialValue 参数，则 prevValue 等于 initialValue，</span><br><span class="line">   curValue 等于数组中的最后一个值。如果没有提供 initialValue 参数，则 prevValue 等于数组最后一个值，</span><br><span class="line">    curValue 等于数组中倒数第二个值。</span><br><span class="line">    var arr = [0,1,2,3,4];</span><br><span class="line"> </span><br><span class="line">    arr.reduceRight(function (preValue,curValue,index,array) &#123;</span><br><span class="line">        return preValue + curValue;</span><br><span class="line">    &#125;); // 10</span><br><span class="line">    7 = 4 + 3   第一次</span><br><span class="line">    9 = 2 + 7   第二次</span><br><span class="line">    10 = 9 + 1   第三次</span><br><span class="line">    10 = 10 + 0  第四次</span><br><span class="line">第十种：find</span><br><span class="line">    find()方法返回数组中符合测试函数条件的第一个元素。否则返回undefined </span><br><span class="line">    var stu = [</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#x27;张三&#x27;,</span><br><span class="line">        gender: &#x27;男&#x27;,</span><br><span class="line">        age: 20</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#x27;王小毛&#x27;,</span><br><span class="line">        gender: &#x27;男&#x27;,</span><br><span class="line">        age: 20</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#x27;李四&#x27;,</span><br><span class="line">        gender: &#x27;男&#x27;,</span><br><span class="line">        age: 20</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">    function getStu(element)&#123;</span><br><span class="line">    return element.name == &#x27;李四&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stu.find(getStu)</span><br><span class="line">    //返回结果为</span><br><span class="line">    //&#123;name: &quot;李四&quot;, gender: &quot;男&quot;, age: 20&#125;</span><br><span class="line">第十一种：findIndex</span><br><span class="line">    对于数组中的每个元素，findIndex 方法都会调用一次回调函数（采用升序索引顺序），</span><br><span class="line">    直到有元素返回 true。只要有一个元素返回 true，findIndex 立即返回该返回 true 的元素的索引值。</span><br><span class="line">	如果数组中没有任何元素返回 true，则 findIndex 返回 -1。</span><br><span class="line">    findIndex 不会改变数组对象!!!!!</span><br><span class="line">    [1,2,3].findIndex(function(x) &#123; x == 2; &#125;);</span><br><span class="line">    //1</span><br><span class="line">    [1,2,3].findIndex(x =&gt; x == 4);</span><br><span class="line">    //-1</span><br><span class="line">第十二种：keys,values,entries</span><br><span class="line">   ES6 提供三个新的方法 —— entries()，keys()和values() —— 用于遍历数组。</span><br><span class="line">   它们都返回一个遍历器对象，可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、</span><br><span class="line">    values()是对键值的遍历，entries()是对键值对的遍历</span><br><span class="line">   for (let index of [&#x27;a&#x27;, &#x27;b&#x27;].keys()) &#123;</span><br><span class="line">     console.log(index);</span><br><span class="line">   &#125;</span><br><span class="line">   // 0</span><br><span class="line">   // 1</span><br><span class="line">   for (let elem of [&#x27;a&#x27;, &#x27;b&#x27;].values()) &#123;</span><br><span class="line">    console.log(elem);</span><br><span class="line">   &#125;</span><br><span class="line">   // &#x27;a&#x27;</span><br><span class="line">   // &#x27;b&#x27;</span><br><span class="line">   for (let [index, elem] of [&#x27;a&#x27;, &#x27;b&#x27;].entries()) &#123;</span><br><span class="line">    console.log(index, elem);</span><br><span class="line">   &#125;</span><br><span class="line">   // 0 &quot;a&quot;</span><br><span class="line">   // 1 &quot;b&quot;</span><br></pre></td></tr></table></figure>
<h3 id="125-数组中forEach和map的区别？"><a href="#125-数组中forEach和map的区别？" class="headerlink" title="125.数组中forEach和map的区别？"></a>125.数组中forEach和map的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">相同点：</span><br><span class="line">1.都是循环遍历数组中的每一项</span><br><span class="line">2.每次执行匿名函数都支持三个参数，参数分别为item（当前每一项），index（索引值），arr（原数组）</span><br><span class="line">3.匿名函数中的this都是指向window</span><br><span class="line">4.只能遍历数组</span><br><span class="line">不同点：</span><br><span class="line">1.map()会分配内存空间存储新数组并返回，forEach()不会返回数据。</span><br><span class="line">&lt;script&gt;let list = [1,2,3,4,5]let a = list.forEach(r =&gt; &#123;</span><br><span class="line">	return r&#125;);</span><br><span class="line">console.log(a);//underfindlet b = list.map(r =&gt; &#123;</span><br><span class="line">	return r&#125;)</span><br><span class="line">console.log(b);//[1,2,3,4,5]&lt;/script&gt;</span><br><span class="line">执行速度对比：</span><br><span class="line">forEach()的执行速度 &lt; map()的执行速度</span><br></pre></td></tr></table></figure>

<h3 id="126-定位元素有哪些-有什么区别？"><a href="#126-定位元素有哪些-有什么区别？" class="headerlink" title="126.定位元素有哪些,有什么区别？"></a>126.定位元素有哪些,有什么区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">一、普通定位(Static)</span><br><span class="line">	在我们的开发过程中，除非专门指定，否则所有框都在普通流中定位。</span><br><span class="line">	普通流中元素框的位置由元素在(X)HTML中的位置决定。块级元素从上到下依次排列，</span><br><span class="line">	框之间的垂直距离由框的垂直margin计算得到。行内元素在一行中水平布置。这个就不过多描述了。</span><br><span class="line">二 . 相对定位（relative）</span><br><span class="line">	在我们前端开发中，relative相对定位一直被看作普通文档流定位模型的一部分，</span><br><span class="line">	定位元素的位置相对于它在普通流中的位置进行移动。使用相对定位的元素不管它是否进行移动，</span><br><span class="line">	元素仍要占据它原来的位置。移动元素会导致它覆盖其他的框。</span><br><span class="line">三 . 绝对定位（absolute）</span><br><span class="line">	在前端开发中，相对于已定位的最近的父类元素，如果没有已定位的最近的父类元素，</span><br><span class="line">	那么它的位置就相对于最初的包含块（如body）。绝对定位的框可以从它的包含块向上、右、下、左移动。</span><br><span class="line">四 .固定定位（fixed）</span><br><span class="line">	相对于浏览器窗口，其余的特点类似于绝对定位。fixed元素就是固定在浏览器某个位置的元素，</span><br><span class="line">	绝对定位是固定在页面的，如果滚动滚动条的话绝对定位的元素也会滚上去，fixed元素不会。</span><br><span class="line">最后：</span><br><span class="line">	这几种定位方式各有千秋，很多小白就经常问老李了，我们写页面的时候，</span><br><span class="line">	这4种布局方式应该用哪个呢？（这问题一听就很小白了）</span><br><span class="line">	最后给大家说一下吧，在我们现在专业的前端开发工作中，用的最多的不是绝对定位，</span><br><span class="line">	也不是相对定位，而是绝对定位和相对定位的结合使用。（小白：WTF????合体？？？）</span><br><span class="line">	并不是合体出现什么新的定位方法啦。而是我们去前端开发中的一种布局书写规范：</span><br><span class="line">	父相子绝（即父元素使用相对定位，子元素使用绝对定位，一起结合实现布局。）</span><br><span class="line">	这种布局规范是现阶段前端开发公认的布局方法，也能避免很多错误的出现。 </span><br></pre></td></tr></table></figure>
<h3 id="127-闭包有了解么-有什么优缺点"><a href="#127-闭包有了解么-有什么优缺点" class="headerlink" title="127.闭包有了解么,有什么优缺点?"></a>127.闭包有了解么,有什么优缺点?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">闭包：想重用变量又想保护这个变量不被篡改的一种机制,是指有权访问另一个函数作用域中的变量的函数，</span><br><span class="line">创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量.</span><br><span class="line">function fn() &#123;</span><br><span class="line">    var count = 0;</span><br><span class="line">    return function fn2() &#123;</span><br><span class="line">        count++</span><br><span class="line">        return console.log(count)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var f = fn();</span><br><span class="line">f();//1</span><br><span class="line">f();//2</span><br><span class="line">f();//3</span><br><span class="line">	上面就是 一个简单闭包的例子,那么闭包中的变量为什么不会被回收呢？</span><br><span class="line">	那是因为JavaScript中的内存回收机制，也就是说一个函数开始执行的时候，</span><br><span class="line">	它会给这个函数中定义的变量划分 内存空间来保存,如果一个函数不再被引用，那么这个函数就会被GC回收。</span><br><span class="line">	如果两个函数互相引用，而不再被第3者所引用，那么这两个互相引用的函数也会被回收。</span><br><span class="line">	因为函数fn 被fn2引用，fn2又被 fn外面的f 引用，所以函数fn2执行后不会被销毁.</span><br><span class="line">闭包有三个特性：</span><br><span class="line">1.函数嵌套函数</span><br><span class="line">2.函数内部可以引用外部的参数和变量</span><br><span class="line">3.参数和变量不会被垃圾回收机制回收</span><br><span class="line">闭包的优点是：</span><br><span class="line">1.变量被保存起来没有被销毁，随时可以被调用</span><br><span class="line">2.只有函数内部的子函数才能读取局部变量,可以避免全局污染</span><br><span class="line">缺点是：</span><br><span class="line">如果闭包使用不当，就会导致变量不会被垃圾回收机制回收，造成内存泄露</span><br><span class="line">128.vue核心是什么</span><br><span class="line">1．数据驱动，也就是数据的双向绑定</span><br><span class="line">(1)Vue 响应式核心就是，getter 的时候会收集依赖，setter 的时候会触发依赖更新</span><br><span class="line">(2)vue将遍历data中对象的所有property，</span><br><span class="line">并使用 Object.defineProperty 把这些 property 全部转为getter/setter。</span><br><span class="line">(3)这些 getter/setter 对用户来说是不可见的，</span><br><span class="line">  但是在内部它们让 Vue 能够追踪依赖，在 property被访问和修改时通知变更。</span><br><span class="line">(4)每个组件实例都对应一个 watcher 实例，</span><br><span class="line">它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。</span><br><span class="line">(5)getter的时候我们会收集依赖，依赖收集就是订阅数据变化watcher的收集，</span><br><span class="line">依赖收集的目的是当响应式数据发生变化时，能够通知相应的订阅者去处理相关的逻辑。</span><br><span class="line">(6)setter 的时候会触发依赖更新，之后当依赖项的 setter 触发时，</span><br><span class="line">  会通知 watcher，从而使它关联的组件重新渲染。</span><br><span class="line">2．组件系统</span><br><span class="line">(1)模板（template）：模板声明了数据和最终展现给用户的DOM之间的映射关系。</span><br><span class="line">(2)初始数据（data）：一个组件的初始数据状态。对于可复用的组件来说，这通常是私有的状态。</span><br><span class="line">(3)接受的外部参数(props)：组件之间通过参数来进行数据的传递和共享。</span><br><span class="line">(4)方法（methods）：对数据的改动操作一般都在组件的方法内进行。</span><br><span class="line">5.生命周期钩子函数（lifecycle hooks）：一个组件会触发多个生命周期钩子函数，</span><br><span class="line"> 最新2.0版本对于生命周期函数名称改动很大。</span><br><span class="line">6.私有资源（assets）：Vue.js当中将用户自定义的指令、过滤器、组件等统称为资源。</span><br><span class="line">一个组件可以声明自己的私有资源。私有资源只有该组件和它的子组件可以调用。</span><br></pre></td></tr></table></figure>
<h3 id="129-vuex是什么-怎么使用的-https-blog-csdn-net-m0-56232007-article-details-118680241"><a href="#129-vuex是什么-怎么使用的-https-blog-csdn-net-m0-56232007-article-details-118680241" class="headerlink" title="129.vuex是什么,怎么使用的(https://blog.csdn.net/m0_56232007/article/details/118680241)"></a>129.vuex是什么,怎么使用的(<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_56232007/article/details/118680241">https://blog.csdn.net/m0_56232007/article/details/118680241</a>)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">1. Vuex</span><br><span class="line">	Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</span><br><span class="line">	如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。</span><br><span class="line">	确实是如此——如果您的应用够简单，您最好不要使用 Vuex。</span><br><span class="line">	一个简单的 store 模式 (opens new window)就足够您所需了。</span><br><span class="line">	但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，</span><br><span class="line">	Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：</span><br><span class="line">Flux 架构就像眼镜：您自会知道什么时候需要它。</span><br><span class="line">尽量用Vuex开发项目，可以让项目更易维护。</span><br><span class="line">1.1. Vuex的核心思想</span><br><span class="line">state</span><br><span class="line">mutation</span><br><span class="line">action</span><br><span class="line">这三个东西组成了Vuex的核心内容</span><br><span class="line">1.1.1. 流程</span><br><span class="line">在组件中使用state中的数据</span><br><span class="line">在组件的生命周期或者原生事件中分发（dispatch）对应的action</span><br><span class="line">action中进行异步请求，请求后台接口获取对应的数据</span><br><span class="line">将数据提交（commit）给对应的mutation</span><br><span class="line">mutation接收到对应的数据后，设置state</span><br><span class="line">state一旦被修改，自定渲染到使用该state的组件</span><br><span class="line">在mutation中尽可以只做state设置的操作，保证mutation功能的单一性。可以组合提交多个mutation实现功能</span><br><span class="line">1.2. 基本模板</span><br><span class="line">src/store/index.js</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;&#125;,</span><br><span class="line">  mutations: &#123;&#125;,</span><br><span class="line">  actions: &#123;&#125;,</span><br><span class="line">  getters: &#123;&#125;,</span><br><span class="line">  modules: &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">export default store</span><br><span class="line">main.js</span><br><span class="line">...</span><br><span class="line">import store from &#x27;store的路径&#x27;</span><br><span class="line">...</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  store,</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br><span class="line">1.3. state</span><br><span class="line">我们应该把组件中的数据存放在state中，组件中需要使用state的位置，去获取对应的state即可</span><br><span class="line">1.3.1. 如何设置state</span><br><span class="line">new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    key: &quot;value&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">1.3.2. 如何在组件中使用state</span><br><span class="line">1.3.2.1. 直接使用</span><br><span class="line">直接在组件模板或者组件的js里通过$store.state.key的方式使用</span><br><span class="line">1.3.2.2. 利用computed优化</span><br><span class="line">在computed中定义一个计算数据，建议名字和key的名字相同</span><br><span class="line">&#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    key () &#123;</span><br><span class="line">      return this.$store.state.key</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">1.3.2.3. 辅助函数</span><br><span class="line">…</span><br><span class="line">1.4. mutation</span><br><span class="line">mutation是设置state的唯一方法！！！！！！！！！！！！！</span><br><span class="line">1.4.1. 如何创建mutation</span><br><span class="line">在store的配置里，我们可以创建mutation</span><br><span class="line">new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    msg: &quot;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    自定义的mutation名字 (state, payload) &#123;</span><br><span class="line">      // state是固定写法，用state可以直接修改state 例如 staet.msg = &quot;值&quot;</span><br><span class="line">      // payload是参数（载荷） 当我们在提交mutation的时候可以传递参数 commit(&#x27;mutation&#x27;, 载荷实际的数据)</span><br><span class="line">      state.msg = payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">1.4.2. 如何使用mutation</span><br><span class="line">一种方法，在组件中进行 commit 操作，或者在 action 中进行 commit 操作（这种方式具体见 action的用法章节）</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=&quot;change&quot;&gt;点击修改msg&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    change () &#123;</span><br><span class="line">      this.$store.commit(&#x27;自定义的mutation名字&#x27;, &quot;传递的数据&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">mutation中只能进行同步操作！不要出现异步操作！</span><br><span class="line">1.5. action</span><br><span class="line">我们可以在action中进行异步操作</span><br><span class="line">1.5.1. 如何创建action</span><br><span class="line">在store的配置里，我们可以创建action</span><br><span class="line">new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    msg: &quot;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    setMsg (state, payload) &#123;</span><br><span class="line">      // state是固定写法，用state可以直接修改state 例如 staet.msg = &quot;值&quot;</span><br><span class="line">      // payload是参数（载荷） 当我们在提交mutation的时候可以传递参数 commit(&#x27;mutation&#x27;, 载荷实际的数据)</span><br><span class="line">      state.msg = payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    getMsg (&#123;commit&#125;, payload) &#123;</span><br><span class="line">      // 在异步操作前加个return 确保dispatch后执行代码</span><br><span class="line">      return axios.get(&quot;url&quot;).then(res =&gt; &#123;</span><br><span class="line">        // 将res.data设置给state</span><br><span class="line">        commit(&#x27;setMsg&#x27;, res.data) // 这里的commit通过解构第一个参数得到。</span><br><span class="line">		这个参数中包含以下内容： commit dispatch state rootState getters rootGetter</span><br><span class="line">        // 这里的state不能修改，只提供获取state中数据的功能</span><br><span class="line">        // 在action中也可以dispatch其他的action</span><br><span class="line">        dispatch(&#x27;action&#x27;, payload)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">1.5.2. 如何使用action</span><br><span class="line">利用this.$store.dispatch可以实现action的执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 在组件的生命周期或者原生事件中，我们可以触发dispatch</span><br><span class="line">this.$store.dispatch(&quot;getMsg&quot;, &quot;参数&quot;)</span><br><span class="line">1.5.2.1. 如何确保dispatch中的异步操作结束后执行代码</span><br><span class="line">this.$store.dispatch(&#x27;action名字&#x27;, &#x27;参数&#x27;).then(() =&gt; &#123;</span><br><span class="line">  // 如果想要让这个函数在异步结束后执行，需要在对应的action将promise对象return出去</span><br><span class="line">&#125;)</span><br><span class="line">actions: &#123;</span><br><span class="line">  getMsg (&#123;commit&#125;, payload) &#123;</span><br><span class="line">    return axios.get(&quot;url&quot;).then(res =&gt; &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="130-什么是长连接-短连接？"><a href="#130-什么是长连接-短连接？" class="headerlink" title="130.什么是长连接 短连接？"></a>130.什么是长连接 短连接？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">参考：https://www.pianshen.com/article/11282111695/</span><br><span class="line">长连接、短连接 长连接：客户端和服务端建立连接后不进行断开，</span><br><span class="line">之后客户端再次访问这个服务器上的内容时，继续使用这一条连接通道。</span><br><span class="line">短连接：客户端和服务端建立连接，发送完数据后立马断开连接。</span><br><span class="line">下次要取数据，需要再次建立连接。 HTTP/1.0：默认使用短连接 HTTP/1.1：默认使用长连接 HTTP的长连...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="131-打开百度是长连接还是短连接？"><a href="#131-打开百度是长连接还是短连接？" class="headerlink" title="131.打开百度是长连接还是短连接？"></a>131.打开百度是长连接还是短连接？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">参考：https://www.pianshen.com/article/9858996747/</span><br><span class="line">打开百度是长连接还是短链接 HTTP1.1开始，都默认使用长连接，</span><br><span class="line">除非在connection字段设置close。 wireshark实验发现，打开百度是长连接。</span><br><span class="line"> 主要的过程是浏览器先和服务端建立一个TCP连接，然后如果一段时间内没有数据传送给服务端，</span><br><span class="line"> 浏览器便发送TCP Keep-Alive包给服务端，服务端一段时间后便会关闭其到浏览器之间的连接，</span><br><span class="line"> 另外可以看到，浏览器是不会主动关闭其到服务器端的连接...</span><br></pre></td></tr></table></figure>
<h3 id="132-讲讲关于display-block"><a href="#132-讲讲关于display-block" class="headerlink" title="132.讲讲关于display:block"></a>132.讲讲关于display:block</h3><h4 id="display的block、inline和inline-block的区别"><a href="#display的block、inline和inline-block的区别" class="headerlink" title="display的block、inline和inline-block的区别"></a>display的block、inline和inline-block的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）block： 会独占一行，多个元素会另起一行，</span><br><span class="line">            可以设置width、height、margin和padding属性；</span><br><span class="line">（2）inline： 元素不会独占一行，设置width、height属性无效。</span><br><span class="line">             但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</span><br><span class="line">（3）inline-block：将对象设置为inline对象，但对象的内容作为block对象呈现，</span><br><span class="line">                  之后的内联对象会被排列在同一行内。</span><br></pre></td></tr></table></figure>
<h4 id="对于行内元素和块级元素，其特点如下："><a href="#对于行内元素和块级元素，其特点如下：" class="headerlink" title="对于行内元素和块级元素，其特点如下："></a>对于行内元素和块级元素，其特点如下：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">（1）行内元素</span><br><span class="line">设置宽高无效；</span><br><span class="line">可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</span><br><span class="line">不会自动换行；</span><br><span class="line">（2）块级元素</span><br><span class="line">可以设置宽高；</span><br><span class="line">设置margin和padding都有效；</span><br><span class="line">可以自动换行；</span><br><span class="line">多个块状，默认排列从上到下。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="133-讲讲-display：flex？"><a href="#133-讲讲-display：flex？" class="headerlink" title="133.讲讲 display：flex？"></a>133.讲讲 display：flex？</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_60622481/article/details/124438743">题目来源</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Lp4y1S7XM?spm_id_from=333.337.search-card.all.click">视频来源</a></p>
<h4 id="一般display：flex写在父元素的属性上！下面是基本理解！"><a href="#一般display：flex写在父元素的属性上！下面是基本理解！" class="headerlink" title="一般display：flex写在父元素的属性上！下面是基本理解！"></a>一般display：flex写在父元素的属性上！下面是基本理解！</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在 flex 容器中默认存在两条轴，水平主轴(main axis) </span><br><span class="line"> 和垂直的交叉轴(cross axis)，这是默认的设置</span><br><span class="line"></span><br><span class="line">在容器中的每个单元块被称之为 flex item，</span><br><span class="line">每个项目占据的主轴空间为 (main size), 占据的交叉轴的空间为 (cross size)。</span><br><span class="line"></span><br><span class="line">这里需要强调，不能先入为主认为宽度就是 main size，</span><br><span class="line">高度就是 cross size，这个还要取决于你主轴的方向，</span><br><span class="line">如果你垂直方向是主轴，那么项目的高度就是 main size。</span><br></pre></td></tr></table></figure>
<h4 id="哪些属性作用在父元素上？"><a href="#哪些属性作用在父元素上？" class="headerlink" title="哪些属性作用在父元素上？"></a>哪些属性作用在父元素上？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">justify-content：space-around  space-between   spacr-evently   center    flex-end</span><br><span class="line"></span><br><span class="line">align-items:lex-star  flex-end</span><br><span class="line"></span><br><span class="line">flex-direction :row    row-reverse   column   column-reverse</span><br><span class="line"></span><br><span class="line">flex-wrap :nowrap（如果子孩子，的宽度超过父盒子，会进行总动的伸缩）  wrap（不去管）</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="哪些属性作用在子元素上？"><a href="#哪些属性作用在子元素上？" class="headerlink" title="哪些属性作用在子元素上？"></a>哪些属性作用在子元素上？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">order （项目排列的顺序 越小越靠前）</span><br><span class="line"></span><br><span class="line">align-self（单个属性的操作  flex-end  center flex-star）</span><br><span class="line"></span><br><span class="line">flex-grow（如果剩余有宽度是否进行扩张方法，默认是0，）</span><br><span class="line"></span><br><span class="line">flex-shrink （空间不足的时候进行缩小默认是1 进行缩小）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="134-react-hooks"><a href="#134-react-hooks" class="headerlink" title="134.react hooks"></a>134.react hooks</h3><h3 id="以下关于react的文章来源"><a href="#以下关于react的文章来源" class="headerlink" title="以下关于react的文章来源"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_67401851/article/details/123426586">以下关于react的文章来源</a></h3><h3 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/kellywong/article/details/106430977">参考来源</a></h3><h4 id="134-1-React-加入-Hooks-的意义是什么？为什么-React-要加入Hooks-这一特性？"><a href="#134-1-React-加入-Hooks-的意义是什么？为什么-React-要加入Hooks-这一特性？" class="headerlink" title="134.1 React 加入 Hooks 的意义是什么？为什么 React 要加入Hooks 这一特性？"></a>134.1 React 加入 Hooks 的意义是什么？为什么 React 要加入Hooks 这一特性？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">为了解决一些component问题：</span><br><span class="line">组件之间的逻辑状态难以复用</span><br><span class="line">大型复杂的组件很难拆分</span><br><span class="line">Class语法的使用不友好</span><br><span class="line">比如说：</span><br><span class="line">类组件可以访问生命周期，函数组件不能</span><br><span class="line">类组件可以定义维护state(状态)，函数组件不可以</span><br><span class="line">类组件中可以获取到实例化后的this,并基于这个this做一些操作，而函数组件不可以</span><br><span class="line">mixins:变量作用于来源不清、属性重名、Mixins引入过多会导致顺序冲突</span><br><span class="line">HOC和Render props：组件嵌套过多，不易渲染调试、会劫持props,会有漏洞</span><br><span class="line">有了Hooks:</span><br><span class="line"></span><br><span class="line">Hooks 就是让你不必写class组件就可以用state和其他的React特性；</span><br><span class="line">也可以编写自己的hooks在不同的组件之间复用</span><br><span class="line">Hooks优点:</span><br><span class="line"></span><br><span class="line">没有破坏性改动：完全可选的。 你无需重写任何已有代码就可以在一些组件中尝试 Hook。</span><br><span class="line">100% 向后兼容的。 Hook 不包含任何破坏性改动。</span><br><span class="line"></span><br><span class="line">更容易复用代码：它通过自定义hooks来复用状态，从而解决了类组件逻辑难以复用的问题</span><br><span class="line">函数式编程风格：函数式组件、状态保存在运行环境、每个功能都包裹在函数中，整体风格更清爽、优雅</span><br><span class="line">代码量少，复用性高</span><br><span class="line">更容易拆分</span><br><span class="line">Hooks缺点(Hoosk有哪些坑):</span><br><span class="line"></span><br><span class="line">hooks 是 React 16.8 的新增特性、以前版本的就别想了</span><br><span class="line">	状态不同步（闭包带来的坑）:函数的运行是独立的，每个函数都有一份独立的闭包作用域。</span><br><span class="line">	当我们处理复杂逻辑的时候，经常会碰到“引用不是最新”的问题</span><br><span class="line">使用useState时候，使用push，pop，splice等直接更改数组对象的坑，</span><br><span class="line">demo中使用push直接更改数组无法获取到新值，应该采用析构方式原因：</span><br><span class="line">push，pop，splice是直接修改原数组，react会认为state并没有发生变化，无法更新)</span><br><span class="line">useState 初始化只初始化一次</span><br><span class="line">useEffect 内部不能修改 state</span><br><span class="line">useEffect 依赖引用类型会出现死循环</span><br><span class="line">不要在循环，条件或嵌套函数中调用Hook，必须始终在React函数的顶层使用Hook。</span><br><span class="line">这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。</span><br><span class="line">一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性，从而产生难以预料到的后果</span><br></pre></td></tr></table></figure>
<h3 id="134-2-if-else条件判断里使用hooks有什么问题？"><a href="#134-2-if-else条件判断里使用hooks有什么问题？" class="headerlink" title="134.2 if else条件判断里使用hooks有什么问题？"></a>134.2 if else条件判断里使用hooks有什么问题？</h3><ul>
<li><p>if else里面不能用hooks，hooks是有顺序的</p>
</li>
<li><p>不能用在if else 或者循环里面 还有非顶层的函数内部</p>
</li>
<li><p>hooks在初始化时候是以链表形式存储的，后续更新都是按照这个链表顺序执行的</p>
<h3 id="134-3-hooks闭包的坑有哪些？如何解决"><a href="#134-3-hooks闭包的坑有哪些？如何解决" class="headerlink" title="134.3 hooks闭包的坑有哪些？如何解决?"></a>134.3 hooks闭包的坑有哪些？如何解决?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">问题：每次 render 都有一份新的状态，数据卡在闭包里，</span><br><span class="line">捕获了每次 render 后的 state，也就导致了输出原来的 state</span><br><span class="line"></span><br><span class="line">解决：可以通过 useRef 来保存 state。前文讲过 ref 在组件中只存在一份，</span><br><span class="line">无论何时使用它的引用都不会产生变化，因此可以来解决闭包引发的问题。</span><br></pre></td></tr></table></figure>
<h3 id="134-3-常用的Hooks有哪些？"><a href="#134-3-常用的Hooks有哪些？" class="headerlink" title="134.3 常用的Hooks有哪些？"></a>134.3 常用的Hooks有哪些？</h3></li>
<li><p>useState()状态钩子。为函数组建提供内部状态</p>
</li>
<li><p>useContext()共享钩子。该钩子的作用是，在组件之间共享状态。<br>可以解决react逐层通过Porps传递数据，它接受React.createContext()的返回结果作为参数，<br>使用useContext将不再需要Provider 和 Consumer</p>
</li>
<li><p>useReducer()状态钩子。Action 钩子。useReducer() 提供了状态管理，<br>其基本原理是通过用户在页面中发起action, 从而通过reducer方法来改变state, 从而实现页面和状态的通信。使用很像redux</p>
</li>
<li><p>useEffect()副作用钩子。它接收两个参数， 第一个是进行的异步操作，<br>第二个是数组，用来给出Effect的依赖项</p>
</li>
<li><p>useRef()获取组件的实例；渲染周期之间共享数据的存储(state不能存储跨渲染周期的数据，<br>因为state的保存会触发组件重渲染）,useRef传入一个参数initValue，<br>并创建一个对象{ current: initValue }给函数组件使用，在整个生命周期中该对象保持不变</p>
</li>
<li><p>useMemo和useCallback可缓存函数的引用或值，useMemo缓存数据，<br>useCallback缓存函数，两者是Hooks的常见优化策略，<br>useCallback(fn,deps)相当于useMemo(()=&gt;fn,deps),经常用在下面两种场景:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、要保持引用相等；对于组件内部用到的 object、array、函数等，</span><br><span class="line">2、用在了其他 Hook 的依赖数组中，或者作为 props 传递给了下游组件，应该使用 useMemo/useCallback）</span><br></pre></td></tr></table></figure>
<h3 id="134-4-useEffect为什么有时候会出现无限重复请求的问题"><a href="#134-4-useEffect为什么有时候会出现无限重复请求的问题" class="headerlink" title="134.4 useEffect为什么有时候会出现无限重复请求的问题"></a>134.4 useEffect为什么有时候会出现无限重复请求的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可能1 在effect里做数据请求未设置依赖参数，没有依赖项effect </span><br><span class="line">会在每次渲染后执行一次，然后在 effect 中更新了状态引起渲染并再次触发 effect</span><br><span class="line">可能2 所设置的依赖项总是会变</span><br><span class="line">解决：useCallback包一层，或者useMemo</span><br><span class="line">useEffect的依赖项里类数组根据什么来判断有没有值变化</span><br><span class="line">浅比较</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="134-5-React-Hooks-api的原理："><a href="#134-5-React-Hooks-api的原理：" class="headerlink" title="134.5 React Hooks api的原理："></a>134.5 React Hooks api的原理：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">用链表数据结构来做全局状态保持；判断依赖项决定是否要更新状态等等</span><br><span class="line">useState 和 useReducer 都是关于状态值的提取和更新， useState 是 useReducer 的一个简化版,</span><br><span class="line">1、两者的状态值都被挂载在组件实例对象 FiberNode 的 memoizedState 属性中</span><br><span class="line"></span><br><span class="line">2、两者保存状态值的数据结构完全不同；类组件是直接把 state </span><br><span class="line">	属性中挂载的这个开发者自定义的对象给保存到 memoizedState </span><br><span class="line">	属性中；而 React Hooks 是用链表来保存状态的， </span><br><span class="line">	memoizedState 属性保存的实际上是这个链表的头指针。</span><br><span class="line"></span><br><span class="line">//链表的节点--Hook对象 react-reconciler/src/ReactFiberHooks.js</span><br><span class="line">export type Hook=&#123;</span><br><span class="line">  memoizedState:any,//最新的状态值</span><br><span class="line">  baseState:any,//初始状态值，如`useState(0)`,则初始值为0</span><br><span class="line">  baseUpdate:Update&lt;any,any&gt;|null,</span><br><span class="line">  queue:UpdateQueue&lt;any,any&gt; | null,//临时保存对状态值的操作，更准确来说是一个链表数据结构中的一个指针</span><br><span class="line">  next:Hook | null，//指向下一个链表节点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="web5.png">参考图</a></p>
<h3 id="134-6-React-Hooks如何模拟组件生命周期？"><a href="#134-6-React-Hooks如何模拟组件生命周期？" class="headerlink" title="134.6 React Hooks如何模拟组件生命周期？"></a>134.6 React Hooks如何模拟组件生命周期？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Hooks模拟constructor</span><br><span class="line"></span><br><span class="line">constructor()&#123;</span><br><span class="line">  super()</span><br><span class="line">  this.state=&#123;count:0&#125;</span><br><span class="line">&#125;</span><br><span class="line">//Hooks模拟constructor</span><br><span class="line">const [count setCount]=useState(0)</span><br><span class="line"></span><br><span class="line">Hooks模拟componentDidMount</span><br><span class="line"></span><br><span class="line">componentDidMount()&#123;</span><br><span class="line"> console.log(&#x27;I am mounted&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">//Hooks模拟componentDidMount</span><br><span class="line">useEffect(()=&gt;console.log(&#x27;mounted&#x27;),[])</span><br><span class="line">//useEffect拥有两个参数，第一个参数作为回调函数会在浏览器布局和绘制完成后调用，</span><br><span class="line">因此它不会阻碍浏览器的渲染进程，第二个参数是一个数组，也是依赖项</span><br><span class="line">//1、当依赖列表存在并有值，如果列表中的任何值发生更改，则每次渲染后都会触发回调</span><br><span class="line">//2、当它不存在时，每次渲染后都会触发回调</span><br><span class="line">//3、当它是一个空列表时，回调只会被触发一次，类似于componentDidMount</span><br><span class="line"></span><br><span class="line">模拟shouldComponentUpdate</span><br><span class="line"></span><br><span class="line">shouldComponentUpdate(nextProps,nextState)&#123;</span><br><span class="line">   console.log(&#x27;shouldComponentUpdate&#x27;)</span><br><span class="line">   return true //更新组件 反之不更新</span><br><span class="line">&#125;</span><br><span class="line">// React.memo包裹一个组件来对它的props进行浅比较,但这不是一个hooks，</span><br><span class="line">因为它的写法和hooks不同，其实React.memo等效于PureComponent,但它只比较props</span><br><span class="line"></span><br><span class="line">// 模拟shouldComponentUpdate</span><br><span class="line">const MyComponent=React.memo(</span><br><span class="line">  _MyComponent,</span><br><span class="line">  (prevProps,nextProps)=&gt;nextProps.count!==preProps.count</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Hooks模拟componentDidUpdate</span><br><span class="line"></span><br><span class="line">componentDidMount() &#123;console.log(&#x27;mounted or updated&#x27;);&#125;</span><br><span class="line">componentDidUpate()&#123;console.log(&#x27;mounted or updated&#x27;)&#125;</span><br><span class="line">//Hooks模拟componentDidUpdate</span><br><span class="line">useEffect(()=&gt;console.log(&#x27;mounted or updated&#x27;))</span><br><span class="line">//这里的回调函数会在每次渲染后调用，因此不仅可以访问componentDidUpdate,</span><br><span class="line">还可以访问componentDidMount,如果只想模拟componentDidUpdate,我们可以这样来实现</span><br><span class="line">const mounted=useRef()</span><br><span class="line">useEffect(()=&gt;&#123;</span><br><span class="line"> if(!mounted.current)&#123;mounted.current=true&#125;else&#123;console.log(&#x27;I am didUpdate&#x27;)&#125;</span><br><span class="line">&#125;)</span><br><span class="line">//useRef在组件中创建“实例变量”，它作为一个标志来指示组件是否处于挂载或更新阶段。</span><br><span class="line">当组件更新完成后在会执行else里面的内容，以此来单独模拟componentDidUpdate</span><br><span class="line"></span><br><span class="line">Hooks模拟componentWillUnmount</span><br><span class="line"></span><br><span class="line">componentWillUnmount()&#123;</span><br><span class="line">  console.log(&#x27;will unmount&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">//hooks</span><br><span class="line">useEffect(()=&gt;&#123;</span><br><span class="line">//此处并不同于willUnMount porps发生变化即更新，也会执行结束监听</span><br><span class="line">//准确的说：返回的函数会在下一次effect执行之前，被执行</span><br><span class="line"> return ()=&gt;&#123;console.log(&#x27;will unmount&#x27;)&#125;</span><br><span class="line">&#125;,[])</span><br><span class="line">//当在useEffect的回调函数中返回一个函数时，这个函数会在组件卸载前被调用。</span><br><span class="line">我们可以在这里清除定时器或事件监听器。</span><br></pre></td></tr></table></figure>

<h3 id="134-7-模拟的生命周期和class中的生命周期有什么区别吗？"><a href="#134-7-模拟的生命周期和class中的生命周期有什么区别吗？" class="headerlink" title="134.7 模拟的生命周期和class中的生命周期有什么区别吗？"></a>134.7 模拟的生命周期和class中的生命周期有什么区别吗？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、默认的useEffect（不带[]）中return的清理函数，它和componentWillUnmount有本质区别的，</span><br><span class="line">默认情况下return，在每次useEffect执行前都会执行，并不是只有组件卸载的时候执行。</span><br><span class="line"></span><br><span class="line">2、useEffect在副作用结束之后，会延迟一段时间执行，并非同步执行，</span><br><span class="line">和compontDidMount有本质区别。遇到dom操作，最好使用useLayoutEffect。</span><br><span class="line"></span><br><span class="line">hooks 模拟的生命周期与class中的生命周期不尽相同，</span><br><span class="line">  我们在使用时，还是需要思考业务场景下那种方式最适合。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="134-8-Hooks相比HOC和Render-Prop有哪些优点？"><a href="#134-8-Hooks相比HOC和Render-Prop有哪些优点？" class="headerlink" title="134.8 Hooks相比HOC和Render Prop有哪些优点？"></a>134.8 Hooks相比HOC和Render Prop有哪些优点？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hoc和render prop都是一种开发模式，将复用逻辑提升到父组件，容易嵌套过多，过度包装</span><br><span class="line">hooks是react的api模式，将复用逻辑取到组件顶层，而不是强行提升到父组件中。</span><br><span class="line">这样就能够避免 HOC 和 Render Props 带来的「嵌套地域」</span><br></pre></td></tr></table></figure>

<h3 id="134-9-Function-Component与Class-Component区别"><a href="#134-9-Function-Component与Class-Component区别" class="headerlink" title="134.9 Function Component与Class Component区别"></a>134.9 Function Component与Class Component区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">对于class com来说：</span><br><span class="line"></span><br><span class="line">首先state是不可变(Immutable),setState后生成一个全新的state引用</span><br><span class="line">但class com通过this.state方式读取state，所以每次代码执行都会拿到最新的state引用</span><br><span class="line">对于function com来说：</span><br><span class="line"></span><br><span class="line">useState 产生的数据也是不可变 Immutable 的，通过数组第二个参数 Set 一个新值后，</span><br><span class="line">原来的值在下次渲染时会形成一个新的引用。</span><br><span class="line">但它state没有通过this.的方式读取，每次执行都读取当时渲染闭包环境的数据，</span><br><span class="line">虽然最新的值跟着最新的渲染变了，但旧的渲染里，状态依然是旧值</span><br><span class="line">1、原理：function组件能捕获渲染的值(captaure the rendered values),</span><br><span class="line">读取渲染闭包内的数据，而class组件在react通过this.的方式读取，this是可变的，所以总能获取最新的props</span><br><span class="line"></span><br><span class="line">2、保存状态：Class把state属性挂载的对象保存到memoizedState属性中，</span><br><span class="line">而Function是用链表来保存状态的，memoizedState属性保存是链表的头指针</span><br><span class="line"></span><br><span class="line">useEffect和useLayoutEffect区别？</span><br><span class="line">1、useEffect是render结束后，callback函数执行，但是不会阻断浏览器的渲染，</span><br><span class="line">算是某种异步的方式吧。但是class的componentDidMount 和componentDidUpdate是同步的,</span><br><span class="line">在render结束后就运行,useEffect在大部分场景下都比class的方式性能更好.</span><br><span class="line"></span><br><span class="line">2、 useLayoutEffect是用在处理DOM的时候,当你的useEffect里面的操作需要处理DOM,</span><br><span class="line">	并且会改变页面的样式,就需要用这个,否则可能会出现出现闪屏问题, </span><br><span class="line">	useLayoutEffect里面的callback函数会在DOM更新完成后立即执行,</span><br><span class="line">	但是会在浏览器进行任何绘制之前运行完成,阻塞了浏览器的绘制</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="134-9-useState和setState区别？"><a href="#134-9-useState和setState区别？" class="headerlink" title="134.9 useState和setState区别？"></a>134.9 useState和setState区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//setState</span><br><span class="line">this.setState(</span><br><span class="line">	&#123;count:this.state.count+1&#125;,</span><br><span class="line">	()=&gt;&#123;</span><br><span class="line">	console.log(this.state.count) //通过回调函数监听到最新的值</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//useState</span><br><span class="line">const[count,setCount]=useState(0)</span><br><span class="line">setCount(1)</span><br><span class="line">useEffect(()=&gt;&#123;</span><br><span class="line">  console.log(count) //通过useEffect监听最新的值</span><br><span class="line">&#125;,</span><br><span class="line">[count])</span><br><span class="line"></span><br><span class="line">1、setState是通过回调函数来获取更新的state，useState是通过useEffect() 来获取最新的 state</span><br><span class="line">2、二者第一个参数都可以传入函数</span><br><span class="line">3、setState()可以在第2个参数传入回调，useState()没有第2个参数</span><br><span class="line">4、setState()自动具备浅合并功能，useState()更新引用需要手动浅合并</span><br><span class="line"></span><br><span class="line">两者参数对比</span><br><span class="line">   setState(updater,[,callback])</span><br><span class="line">         updater:object/function - 用于更新数据</span><br><span class="line">         callback:function - 用于获取更新后最新的state值</span><br><span class="line">    useState(initState)</span><br><span class="line">         const [state ,setState] = useState(initState)</span><br><span class="line">            state:状态</span><br><span class="line">            setState(updater): 修改状态的方法</span><br><span class="line">               updater:object/function - 用于更新数据</span><br><span class="line">            initState : 状态的初始值  </span><br></pre></td></tr></table></figure>

<h3 id="134-10-useState中的第二个参数更新状态和class中的this-setState区别？"><a href="#134-10-useState中的第二个参数更新状态和class中的this-setState区别？" class="headerlink" title="134.10 useState中的第二个参数更新状态和class中的this.setState区别？"></a>134.10 useState中的第二个参数更新状态和class中的this.setState区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">useState 通过数组第二个参数 Set 一个新值后，新值会形成一个新的引用，捕获当时渲染闭包里的数据 State</span><br><span class="line"></span><br><span class="line">setState 是通过 this.state 的读取 state,每次代码执行都会拿到最新的 state 引用</span><br><span class="line"></span><br><span class="line">用useState实现state和setState功能？</span><br><span class="line">//方法一 模拟setState传入updater和callback</span><br><span class="line">const [n1,setN1]=useState&lt;any&gt;(0)</span><br><span class="line">const [n1,setN2]=useState&lt;any&gt;(0)</span><br><span class="line">setN1((num)=&gt;&#123;</span><br><span class="line">  setN2(num+1)</span><br><span class="line">  //返回n1修改后的值</span><br><span class="line">  return num+1</span><br><span class="line">&#125;)</span><br><span class="line">//方法二 自定义hooks,配合引入useRef</span><br><span class="line">export const useXState =(initState)=&gt;&#123;</span><br><span class="line">     const [state,setState]=useState(initState)</span><br><span class="line">     let isUpdate=useRef()</span><br><span class="line">     const setXState=(state,cb)=&gt;&#123;</span><br><span class="line">       setState(prev=&gt;&#123;</span><br><span class="line">          isUpdate.current=cb</span><br><span class="line">          return typeof state===&#x27;function&#x27;?state(prev):state</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">useEffect(()=&gt;&#123;</span><br><span class="line">  if(isUpdate.current)&#123;</span><br><span class="line">     isUpdate.current()</span><br><span class="line">  &#125;</span><br><span class="line">  //useEffect不可以每次渲染组件都执行，因此在每次渲染之后都需要判断其是否值得执行</span><br><span class="line">&#125;)</span><br><span class="line">return [state,setXState]</span><br><span class="line">	//useRef的特性来作为标识区分是挂载还是更新，当执行setXstate时，</span><br><span class="line">	会传入和setState一模一样的参数，并且将回调赋值给useRef的current属性，</span><br><span class="line">	这样在更新完成时，我们手动调用current即可实现更新后的回调这一功能</span><br></pre></td></tr></table></figure>

<h3 id="134-11-useReducer和redux区别？"><a href="#134-11-useReducer和redux区别？" class="headerlink" title="134.11 useReducer和redux区别？"></a>134.11 useReducer和redux区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useReducer() 提供了状态管理，其基本原理是通过用户在页面中发起action, </span><br><span class="line">从而通过 reducer方法来改变state, 从而实现页面和状态的通信,使用很像redux</span><br><span class="line">useReducer是useState的代替方案，用于state复杂变化</span><br><span class="line">useReducer是单个组件状态管理，组价通讯还需要props</span><br><span class="line">redux是全局的状态管理，多组件共享数据</span><br></pre></td></tr></table></figure>
<h3 id="134-12-如何自定义HOOK"><a href="#134-12-如何自定义HOOK" class="headerlink" title="134.12 如何自定义HOOK"></a>134.12 如何自定义HOOK</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState, useEffect &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">function useFriendStatus(friendID) &#123;</span><br><span class="line">  const [isOnline, setIsOnline] = useState(null);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    function handleStatusChange(status) &#123;</span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return isOnline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="134-13-Hooks性能优化"><a href="#134-13-Hooks性能优化" class="headerlink" title="134.13 Hooks性能优化"></a>134.13 Hooks性能优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useMemo 缓存数据</span><br><span class="line">useCallback 缓存函数</span><br><span class="line">相当于class组件的SCU和PureComponent</span><br></pre></td></tr></table></figure>
<h3 id="134-14-怎么在高阶组件里面访问组件实例"><a href="#134-14-怎么在高阶组件里面访问组件实例" class="headerlink" title="134.14 怎么在高阶组件里面访问组件实例"></a>134.14 怎么在高阶组件里面访问组件实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、属性代理。高阶组件通过包裹的React组件来操作props，更改 props，</span><br><span class="line">  可以对传递的包裹组件的WrappedComponent的props进行控制</span><br><span class="line"></span><br><span class="line">2、通过 refs 获取组件实例</span><br></pre></td></tr></table></figure>
<h3 id="135-关于前端动画的总结？"><a href="#135-关于前端动画的总结？" class="headerlink" title="135 关于前端动画的总结？"></a>135 关于前端动画的总结？</h3><h3 id="参考来源-1"><a href="#参考来源-1" class="headerlink" title="参考来源"></a><a target="_blank" rel="noopener" href="https://wenku.baidu.com/view/6f26f4852b4ac850ad02de80d4d8d15abf230057.html">参考来源</a></h3><h3 id="136-清楚浮动的方法？"><a href="#136-清楚浮动的方法？" class="headerlink" title="136 清楚浮动的方法？"></a>136 清楚浮动的方法？</h3><h4 id="1-利用伪元素选择器，添加空div，并设置【clear-both】"><a href="#1-利用伪元素选择器，添加空div，并设置【clear-both】" class="headerlink" title="1.利用伪元素选择器，添加空div，并设置【clear:both】"></a>1.利用伪元素选择器，添加空div，并设置【clear:both】</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container clear&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">           内容</span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aside&quot;</span>&gt;</span></span><br><span class="line">           边栏</span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">     <span class="selector-class">.content</span> &#123;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">           <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">           <span class="attribute">float</span>: left;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="selector-class">.aside</span> &#123;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">           <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">           <span class="attribute">float</span>: left;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="selector-class">.box</span> &#123;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">           <span class="attribute">background-color</span>: yellow;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* .clear&#123;</span></span><br><span class="line"><span class="comment">           clear: both;</span></span><br><span class="line"><span class="comment">       &#125; */</span></span><br><span class="line"><span class="comment">/* 这里使用伪类选择器 添加元素 并且设置其为clear：both */</span></span><br><span class="line">       <span class="selector-class">.clear</span><span class="selector-pseudo">::before</span>,<span class="selector-class">.clear</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">           <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">           <span class="attribute">display</span>: block;</span><br><span class="line">           <span class="attribute">clear</span>: both;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-给父元素设置超出部分隐藏"><a href="#2-给父元素设置超出部分隐藏" class="headerlink" title="2. 给父元素设置超出部分隐藏"></a>2. 给父元素设置超出部分隐藏</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clear</span>:&#123;</span><br><span class="line">   <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="新大陆面试"><a href="#新大陆面试" class="headerlink" title="新大陆面试"></a>新大陆面试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.除了遍历的for循环，还了解那些for循环？</span><br><span class="line">2.怎么遍历对象？</span><br><span class="line">3.怎么终止for循环？</span><br><span class="line">4.Nodejs 能获取window对象嘛？</span><br><span class="line">5.怎么编写七天免密免密登录？</span><br><span class="line">6.Locoalstorage和sessionstorage的区别？</span><br><span class="line">7.Sessionstorage在同个端口下切换页面，sessionstorage还存在嘛？</span><br><span class="line">8.Cookie存放在哪里？</span><br><span class="line">9.在nodejs里怎么获取cookie？</span><br><span class="line">10.自己擅长逻辑还是样式？</span><br><span class="line">都擅长，比较喜欢写样式</span><br><span class="line">11.原始js 怎么实现淡入淡出的效果？</span><br><span class="line">如果考虑到宽高的变化，那里面的内容显示问题怎么解决？</span><br><span class="line">12.微信小程序有了解嘛？Rpx 和px的区别？</span><br><span class="line">13.自学的话通常在哪里学？（网站）</span><br></pre></td></tr></table></figure>
<h2 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h2><h3 id="1-除了遍历的for循环，还了解那些for循环？"><a href="#1-除了遍历的for循环，还了解那些for循环？" class="headerlink" title="1.除了遍历的for循环，还了解那些for循环？"></a>1.除了遍历的for循环，还了解那些for循环？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line">1、for</span><br><span class="line">for 循环是出现最早，也是应用最普遍的一个遍历，能够满足绝大多数的遍历。</span><br><span class="line">可以遍历 数组、对象、字符串，示例：</span><br><span class="line"></span><br><span class="line">// 遍历数组</span><br><span class="line">var arr = [1, 2, 3]</span><br><span class="line">for (var i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">  console.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">//遍历对象</span><br><span class="line">var obj = &#123;</span><br><span class="line">  job: &#x27;web worker&#x27;,</span><br><span class="line">  name:&#x27;前端代码女神&#x27;</span><br><span class="line">&#125;</span><br><span class="line">for (var i = 0,keys = Object.keys(obj); i&lt; keys.length; i++)&#123;</span><br><span class="line">  console.log(obj[keys[i]])</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//遍历字符串</span><br><span class="line">let str = &#x27;abc&#x27;</span><br><span class="line">for (var i = 0; i &lt; str.length; i++)&#123;</span><br><span class="line">  console.log(str[i])</span><br><span class="line">&#125;</span><br><span class="line">2、for ... in</span><br><span class="line">for ... in 是在 ES5 中新增的，以任意顺序迭代一个对象的除Symbol以外的可枚举属性，</span><br><span class="line">包括继承的可枚举属性。</span><br><span class="line"></span><br><span class="line">// 遍历数组</span><br><span class="line">var arr = [1, 2, 3]</span><br><span class="line">for (var i in arr )&#123;</span><br><span class="line">  console.log(i);//0 1 2</span><br><span class="line">  console.log(arr[i]);//1 2 3</span><br><span class="line">&#125;</span><br><span class="line">//遍历对象</span><br><span class="line">var obj = &#123;</span><br><span class="line">  job: &#x27;web worker&#x27;,</span><br><span class="line">  name:&#x27;前端代码女神&#x27;</span><br><span class="line">&#125;</span><br><span class="line">for (var key in obj)&#123;</span><br><span class="line">  console.log(key)// job name</span><br><span class="line">  console.log(obj[key])// web worker  前端代码女神</span><br><span class="line">&#125;</span><br><span class="line">//遍历字符串</span><br><span class="line">let str = &#x27;abc&#x27;</span><br><span class="line">for (var i in str)&#123;</span><br><span class="line">  console.log(i) // 0 1 2</span><br><span class="line">  console.log(str[i]) // a b c</span><br><span class="line">&#125;</span><br><span class="line">3、for ... of</span><br><span class="line">for ... of 语句在可迭代对象(包括 Array、Map、Set、String、TypedArray、arguments 对象等等)</span><br><span class="line">上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。</span><br><span class="line"></span><br><span class="line">// 迭代 Array</span><br><span class="line">var arr = [1, 2, 3]</span><br><span class="line">for (var val of arr )&#123;</span><br><span class="line">  console.log(val);// 1 2 3</span><br><span class="line">&#125;</span><br><span class="line">//迭代 String</span><br><span class="line">let str = &#x27;abc&#x27;</span><br><span class="line">for (var val of str)&#123;</span><br><span class="line">  console.log(val) // a b c</span><br><span class="line">&#125;</span><br><span class="line">// 迭代 TypedArray - 一个类型化数组，描述了一个底层的二进制数据缓冲区！</span><br><span class="line">let iterable = new Uint8Array([0x00, 0xff]);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">for (let value of iterable) &#123;</span><br><span class="line">  console.log(value);//0 255</span><br><span class="line">&#125;</span><br><span class="line">// 迭代 Map - 对象保存键值对，能够记住键的原始插入顺序</span><br><span class="line">let map = new Map([[&#x27;a&#x27;,1],[&#x27;b&#x27;,2]])</span><br><span class="line">for (let key of map) &#123;</span><br><span class="line">  console.log(&#x27;key&#x27;,key)//[&#x27;a&#x27;,1] [&#x27;b&#x27;,2] </span><br><span class="line">&#125;</span><br><span class="line">for (let [key,value] of map) &#123;</span><br><span class="line">  console.log(key) // a b</span><br><span class="line">  console.log(value) // 1 2</span><br><span class="line">&#125;</span><br><span class="line">// 迭代 Set</span><br><span class="line">let set = new Set([1,2,3,2,1])</span><br><span class="line">for (let val of set) &#123;</span><br><span class="line">  console.log(val)// 1 2 3</span><br><span class="line">&#125;</span><br><span class="line">4、for await...of</span><br><span class="line">创建一个循环，该循环遍历异步可迭代对象以及同步可迭代对象，包括内置的 String、Array，</span><br><span class="line">类数组对象(arguments 或 nodeList)，TypedArray, Map, Set 和用户定义的异步/同步迭代器。</span><br><span class="line"></span><br><span class="line">它使用对象的每个不同属性的值调用要执行的语句来调用自定义迭代钩子。</span><br><span class="line"></span><br><span class="line">类似于 await 运算符一样，该语句只能在一个async function 内部使用。</span><br><span class="line"></span><br><span class="line">async function* asyncGenerator() &#123;</span><br><span class="line">  var i = 0;</span><br><span class="line">  while (i &lt; 3) &#123;</span><br><span class="line">    yield i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(async function () &#123;</span><br><span class="line">  for await (num of asyncGenerator()) &#123;</span><br><span class="line">    console.log(num);// 0 1 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">5、forEach</span><br><span class="line">forEach 是ES5版本发布的，按升序为数组中含有效值的每一项执行一次回调函数，</span><br><span class="line">那些已删除或者未初始化的项将被跳过(例如在稀疏数组上)，一般认为是 普通for循环 的加强版。</span><br><span class="line"></span><br><span class="line">// 遍历数组</span><br><span class="line">var arr = [1, 2, 3]</span><br><span class="line">arr.forEach((item, index) =&gt; &#123;</span><br><span class="line">  console.log(index);//0 1 2</span><br><span class="line">  console.log(item);// 1 2 3</span><br><span class="line">&#125;)</span><br><span class="line">//遍历对象</span><br><span class="line">var obj = &#123;</span><br><span class="line">  job: &#x27;web worker&#x27;,</span><br><span class="line">  name:&#x27;前端代码女神&#x27;</span><br><span class="line">&#125;</span><br><span class="line">var keys = Object.keys(obj)</span><br><span class="line">keys.forEach((key) =&gt; &#123;</span><br><span class="line">  console.log(key)// job name</span><br><span class="line">  console.log(obj[key])// web worker  前端代码女神</span><br><span class="line">&#125;)</span><br><span class="line">6、map</span><br><span class="line">遍历时可以返回一个新数组，新数组的结果是原数组中每个元素都调用一次提供的函数后返回的值。</span><br><span class="line"></span><br><span class="line">// 遍历数组</span><br><span class="line">var arr = [1, 2, 3]</span><br><span class="line">let newArr = arr.map((item) =&gt; item * 2)</span><br><span class="line">console.log(newArr);//[2,4,6]</span><br><span class="line">二、多个 for 之间区别</span><br><span class="line">1、使用场景差异</span><br><span class="line">for循环是最早最原始的循环遍历语句，for 内部定义一个变量，</span><br><span class="line">按照条件进行循环遍历，通常是数组的长度，当超过长度时就停止循环，</span><br><span class="line">一般遍历的都是数组或类数组。</span><br><span class="line"></span><br><span class="line">遍历对象时，由于对象没有长度，所以使用 Object.keys() 获取对象的所有属性，</span><br><span class="line">以数组形式返回。</span><br><span class="line"></span><br><span class="line">for / in主要是用来遍历对象上的可枚举属性，包括原型对象上的属性，</span><br><span class="line">按任意顺序进行遍历，遍历对象时获取到的是属性的键值，遍历的是数组，数组的下标当做键值。</span><br><span class="line"></span><br><span class="line">for / of用于遍历可迭代对象的数据，包括 Array、Map、Set、String、TypedArray、arguments 对象等等。</span><br><span class="line"></span><br><span class="line">for await...of用于遍历异步可迭代对象，该语句只能在一个async function 内部使用。</span><br><span class="line"></span><br><span class="line">f orEach 是 for 的加升级版，使用更简单，携带参数更多，</span><br><span class="line">但本质还是数组的循环，每个元素都执行一次回调，不会改变原数组。</span><br><span class="line"></span><br><span class="line">map是给原数组每个元素都执行一次回调，返回一个新数组，不会改变原数组。</span><br><span class="line"></span><br><span class="line">2、功能差异</span><br><span class="line">forEach、map 不支持跳出循环，其他不支持。</span><br><span class="line"></span><br><span class="line">for await ... of 能够支持异步操作，其他的不支持。</span><br><span class="line"></span><br><span class="line">对于纯对象的遍历， for ... in 枚举更方便。</span><br><span class="line"></span><br><span class="line">对于数组遍历，如果不需要索引，可以直接使用 for...of 获取值，</span><br><span class="line">还可支持 break 或 return ;如果还需要索引，使用 forEach 更适合，但不支持 return。</span><br><span class="line"></span><br><span class="line">如果是一个数组映射成另一个数组，使用 map 最合适。</span><br><span class="line"></span><br><span class="line">3、性能差异</span><br><span class="line">在测试环境、测试数据条件一致的情况下，性能排序为：</span><br><span class="line"></span><br><span class="line">for &gt; for of &gt; forEach &gt; map &gt; for in。</span><br><span class="line"></span><br><span class="line">for 因为没有额外的函数调用和上下文，所以性能是最快的。</span><br><span class="line"></span><br><span class="line">for ... of 具有 iterator 接口的数据结构，可以使用它来迭代成员，直接读取键值。</span><br><span class="line"></span><br><span class="line">forEach 是 for 的语法糖，还有许多的参数和上下文，因此会慢一些。</span><br><span class="line"></span><br><span class="line">map 因为它返回的是一个等长的全新数组，数组创建和赋值产生的性能开销较大。</span><br><span class="line"></span><br><span class="line">for...in 性能最差，因为需要列举对象的所有属性，有转化过程，开销比较大。</span><br><span class="line"></span><br><span class="line">三、for 的使用</span><br><span class="line">在项目开发中，我们应该根据实际需求，去选择一个合适的 for 遍历。以下是一些使用建议：</span><br><span class="line"></span><br><span class="line">如果需要把数据映射成另外一个数组，如变成对应布尔值，推荐使用 map ，</span><br><span class="line">不会修改原数组，使用语法简单。</span><br><span class="line"></span><br><span class="line">数组遍历时，可以使用 for 、forEach 或 for...of。</span><br><span class="line"></span><br><span class="line">遍历的是纯对象时，推荐使用 for ... in 。</span><br><span class="line"></span><br><span class="line">如果是需要对迭代器遍历，推荐使用 for ... of。</span><br><span class="line"></span><br><span class="line">如果是在数组中筛选符合条件的数组，使用 fillter 。</span><br></pre></td></tr></table></figure>
<h3 id="2-怎么遍历对象？"><a href="#2-怎么遍历对象？" class="headerlink" title="2.怎么遍历对象？"></a>2.怎么遍历对象？</h3><h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/MISS_zhang_0110/article/details/123369222">参考网址</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">遍历对象的方法</span><br><span class="line">一、vue中v-for遍历对象</span><br><span class="line">二、for...in 遍历数组和对象都可以</span><br><span class="line">三、Object的方法</span><br><span class="line">四、Object.getOwnPropertyNames(obj)</span><br><span class="line">五、使用Reflect.ownKeys(obj)遍历</span><br></pre></td></tr></table></figure>
<h3 id="3-怎么终止for循环？"><a href="#3-怎么终止for循环？" class="headerlink" title="3.怎么终止for循环？"></a>3.怎么终止for循环？</h3><h3 id="参考网址-1"><a href="#参考网址-1" class="headerlink" title="参考网址"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40203552/article/details/107343692">参考网址</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.continue</span><br><span class="line">当程序运行到 continue； 语句时，会终止当前的这一次循环，进入下一次的循环中。</span><br><span class="line">它 适用于所有的循环结构。</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * ...</span><br><span class="line">	 */</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.break</span><br><span class="line">当程序运行到 break; 语句时，会结束当前的循环，执行循环后面（外边）的语句。</span><br><span class="line">如果多层循环，只会退出当前的循环，执行该循环后的语句，外循环不受影响。</span><br><span class="line">一般配合判断语句使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.return</span><br><span class="line">当程序运行到 return; 语句时，会终止循环，结束当前方法。</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * ...</span><br><span class="line">	 */</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-Nodejs-能获取window对象嘛？"><a href="#4-Nodejs-能获取window对象嘛？" class="headerlink" title="4.Nodejs 能获取window对象嘛？"></a>4.Nodejs 能获取window对象嘛？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node中没有window对象。window是浏览器的规范，并非js语言规范，</span><br><span class="line">所以在nodejs当然不能用。 不过nodejs有个类似的全局变量，</span><br><span class="line">叫golgal，当然了，它内部的内容和浏览器中的window很不一样就是了。</span><br></pre></td></tr></table></figure>
<h3 id="5-怎么编写七天免密免密登录"><a href="#5-怎么编写七天免密免密登录" class="headerlink" title="5.怎么编写七天免密免密登录"></a>5.怎么编写七天免密免密登录</h3><h3 id="参考网址-2"><a href="#参考网址-2" class="headerlink" title="参考网址"></a><a target="_blank" rel="noopener" href="https://https//blog.csdn.net/YZY010313/article/details/122481163">参考网址</a></h3><h3 id="6-Locoalstorage和sessionstorage的区别"><a href="#6-Locoalstorage和sessionstorage的区别" class="headerlink" title="6.Locoalstorage和sessionstorage的区别?"></a>6.Locoalstorage和sessionstorage的区别?</h3><h3 id="参考网址-3"><a href="#参考网址-3" class="headerlink" title="参考网址"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_47443027/article/details/115211563">参考网址</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">区别一：生命周期</span><br><span class="line"></span><br><span class="line">sessionStorage仅在当前会话下生效，当你关闭页面或浏览器后你存储的sessionStorage数据会被清除。</span><br><span class="line"></span><br><span class="line">localStorage生命周期是永久，储存的信息是永远不会消失的，除非你自己主动清除localStorage信息。</span><br><span class="line"></span><br><span class="line">区别二：各自的使用方法</span><br><span class="line"></span><br><span class="line">sessionStorage使用方法</span><br><span class="line"></span><br><span class="line">1、第一个参数是保存的变量名，第二个是变量的值</span><br><span class="line"></span><br><span class="line">sessionStorage.setItem(&#x27;sname&#x27;, &#x27;session&#x27;);</span><br><span class="line"></span><br><span class="line">2、获取sessionStorage的数据</span><br><span class="line"></span><br><span class="line">sessionStorage.getItem(&#x27;sname&#x27;);</span><br><span class="line"></span><br><span class="line">3、删除某个sessionStorage的数据</span><br><span class="line"></span><br><span class="line">sessionStorage.removeItem(&#x27;sname&#x27;);</span><br><span class="line"></span><br><span class="line">4、清除所有保存的sessionStorage数据</span><br><span class="line"></span><br><span class="line">sessionStorage.clear();</span><br><span class="line"></span><br><span class="line">localStorage使用方法</span><br><span class="line"></span><br><span class="line">1、第一个参数是保存的变量名，第二个是变量的值</span><br><span class="line"></span><br><span class="line">localStorage.setItem(&#x27;lname&#x27;, &#x27;local&#x27;);</span><br><span class="line"></span><br><span class="line">2、获取localStorage的数据</span><br><span class="line"></span><br><span class="line">localStorage.getItem(&#x27;lname&#x27;);</span><br><span class="line"></span><br><span class="line">3、删除某个localStorage的数据</span><br><span class="line"></span><br><span class="line">localStorage.removeItem(&#x27;lname&#x27;);</span><br><span class="line"></span><br><span class="line">4、清除所有保存的localStorage数据</span><br><span class="line"></span><br><span class="line">localStorage.clear();</span><br><span class="line"></span><br><span class="line">说了两个它们的区别，那你应该在想它们有没有共同点，共同点也是有的，共同点是它们的数据存储大小一般都在5mb。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-Sessionstorage在同个端口下切换页面，sessionstorage还存在嘛？"><a href="#7-Sessionstorage在同个端口下切换页面，sessionstorage还存在嘛？" class="headerlink" title="7..Sessionstorage在同个端口下切换页面，sessionstorage还存在嘛？"></a>7..Sessionstorage在同个端口下切换页面，sessionstorage还存在嘛？</h3><h3 id="参考网址-4"><a href="#参考网址-4" class="headerlink" title="参考网址"></a><a target="_blank" rel="noopener" href="https://www.h5w3.com/140783.html">参考网址</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">即使同一个域名、同一个key名，在不同标签页之间，session不能联动共用。</span><br><span class="line"></span><br><span class="line">但是，从一个标签页中，使用target=&quot;_blank&quot;的方式跳转到同域名的新标签页面，上一个页面的session就可以带过来。</span><br><span class="line"></span><br><span class="line">	就好像从一个标签页切换路由，虽然地址路径换了、</span><br><span class="line">	域名没变的情况下，session都还能存在并可以取到。</span><br><span class="line">	但是，从一个标签页种下session后，不关闭页面，地址栏修改不同域名的页面地址并跳转，</span><br><span class="line">	上个页面的session就没了。特别的，从新地址点击回退，退回到之前的页面地址后，</span><br><span class="line">	session又保留出来了。这也就是session为什么作为会话存储了，没有杀死该页面或浏览器的情况下，</span><br><span class="line">	session其实还在，只不过切换了域名地址，因为跨域限制取不到</span><br><span class="line">	（事实上，控制台Application里也看不到别的域名种的session）</span><br></pre></td></tr></table></figure>
<h3 id="8-Cookie存放在哪里？"><a href="#8-Cookie存放在哪里？" class="headerlink" title="8.Cookie存放在哪里？"></a>8.Cookie存放在哪里？</h3><h3 id="cookie面试相关"><a href="#cookie面试相关" class="headerlink" title="cookie面试相关"></a><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/513ebae8d6e3f4c3056b769f4">cookie面试相关</a></h3><h3 id="参考网址-5"><a href="#参考网址-5" class="headerlink" title="参考网址"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39918690/article/details/110606758">参考网址</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie：存储在用户本地终端上的数据主要包括：名字、值、过期时间、路径和域。</span><br><span class="line">如果不设置时间，默认关闭消除Cookie。会话Cookie保存在内存里，设置时间的保存在硬盘里。</span><br></pre></td></tr></table></figure>
<h3 id="9-在nodejs里怎么获取cookie？"><a href="#9-在nodejs里怎么获取cookie？" class="headerlink" title="9.在nodejs里怎么获取cookie？"></a>9.在nodejs里怎么获取cookie？</h3><h3 id="参考网址-6"><a href="#参考网址-6" class="headerlink" title="参考网址"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43845090/article/details/111316539">参考网址</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.插件下载</span><br><span class="line">在nodejs下不太好直接获取到request里面的cookie，需要安装cookie-parser插件来获取</span><br><span class="line">安装：</span><br><span class="line"></span><br><span class="line">npm install cookie-parser --save</span><br><span class="line">1</span><br><span class="line">使用：</span><br><span class="line"></span><br><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express();</span><br><span class="line">const cookieParser = require(&#x27;cookie-parser&#x27;);</span><br><span class="line">app.use(cookieParser());</span><br><span class="line"></span><br><span class="line">获取cookie</span><br><span class="line">当我们使用了cookieParser之后，就能直接在request中取出cookie了</span><br><span class="line">具体实现：</span><br><span class="line"></span><br><span class="line">app.get(&#x27;/views&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  console.log(req.cookies);</span><br><span class="line">  res.send(&quot;测试&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="10-在nodejs环境中使用过那些插件？"><a href="#10-在nodejs环境中使用过那些插件？" class="headerlink" title="10.在nodejs环境中使用过那些插件？"></a>10.在nodejs环境中使用过那些插件？</h3><h3 id="11-微信小程序有了解嘛？Rpx-和px的区别？"><a href="#11-微信小程序有了解嘛？Rpx-和px的区别？" class="headerlink" title="11.微信小程序有了解嘛？Rpx 和px的区别？"></a>11.微信小程序有了解嘛？Rpx 和px的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">px 像素，是相对于显示器屏幕分辨率而言的。</span><br><span class="line">em 相对长度单位。相对于当前对象内文本的字体尺寸。会继承父级元素的字体大小。</span><br><span class="line">rem 是相对于HTML根元素的字体大小。</span><br><span class="line">vh 和vw相对于视口的高度和宽度,1vh 等于1/100的视口高度，1vw 等于1/100的视口宽度。</span><br><span class="line">rpx 是微信小程序解决自适应屏幕尺寸的尺寸单位。</span><br></pre></td></tr></table></figure>
<h3 id="12-js是单线程还是多线程？为什么？"><a href="#12-js是单线程还是多线程？为什么？" class="headerlink" title="12.js是单线程还是多线程？为什么？"></a>12.js是单线程还是多线程？为什么？</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_50736511/article/details/124208582">参考网站</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_49200148/article/details/107165334">参考网站</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">js为什么是单线程的</span><br><span class="line"></span><br><span class="line">如果js是多线程的话，一个线程添加DOM一个线程删除DOM那就会产生差错，浏览器不知道应该听谁的，到底删除DOM还是添加DOM。</span><br><span class="line"></span><br><span class="line">js是单线程语言，浏览器只分配给js一个主线程，用来执行任务（函数），但一次只能执行一个任务，</span><br><span class="line">这些任务形成一个任务队列排队等候执行，但前端的某些任务是非常耗时的，比如网络请求，定时器和事件监听，</span><br><span class="line">如果让他们和别的任务一样，都老老实实的排队等待执行的话，执行效率会非常的低，甚至导致页面的假死。</span><br><span class="line">所以，浏览器为这些耗时任务开辟了另外的线程，主要包括http请求线程，浏览器定时触发器，浏览器事件触发线程，这些任务是异步的。</span><br><span class="line"></span><br><span class="line">来自：</span><br><span class="line">https://blog.csdn.net/weixin_50736511/article/details/124208582</span><br><span class="line">https://blog.csdn.net/weixin_49200148/article/details/107165334</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">MaxLi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/05/14/webInterview/">http://example.com/2022/05/14/webInterview/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/14/iconfont/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">iconfont</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/14/aboutCreateNewBlog/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">aboutCreateNewBlog</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MaxLi</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">前端面试个人总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-html5%E6%96%B0%E7%89%B9%E6%80%A7-html5%E6%96%B0%E7%89%B9%E6%80%A7-%EF%BC%88https-www-cnblogs-com-vicky1018-p-7705223-html%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">1. html5新特性[html5新特性]（https:&#x2F;&#x2F;www.cnblogs.com&#x2F;vicky1018&#x2F;p&#x2F;7705223.html）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-CSS3%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">2. CSS3新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%96%E9%9A%8F%E6%9C%BA%E6%95%B050-%E5%88%B0100%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">3.取随机数50 到100随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Js%E9%87%8C%E9%9D%A2this%E6%8C%87%E5%90%91"><span class="toc-number">1.4.</span> <span class="toc-text">4. Js里面this指向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">1.5.</span> <span class="toc-text">5. 原型和原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8E%9F%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F-%E4%BC%A0%E5%9C%A8%E4%BA%8E-%EF%BC%88https-blog-csdn-net-hgzzzz-article-details-81530563%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">6.原型的作用？[传在于]（https:&#x2F;&#x2F;blog.csdn.net&#x2F;hgzzzz&#x2F;article&#x2F;details&#x2F;81530563）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Cookie%E9%BB%98%E8%AE%A4%E5%AD%98%E6%94%BE20%E5%88%86%E9%92%9F"><span class="toc-number">1.7.</span> <span class="toc-text">7. Cookie默认存放20分钟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Vue%E6%A1%86%E6%9E%B6%E5%92%8CjQuery%E3%80%81%E5%8E%9F%E7%94%9Fjs%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.</span> <span class="toc-text">8. Vue框架和jQuery、原生js有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%8F%92%E6%A7%BD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.9.</span> <span class="toc-text">9. 插槽的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">1.10.</span> <span class="toc-text">10. 常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8"><span class="toc-number">1.11.</span> <span class="toc-text">11. 计算属性和侦听器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-V-for%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0%E4%B8%AA-key-%E7%A6%8F%E5%BB%BA%E5%85%89%E9%80%9A%E4%BA%92%E8%81%94%E9%80%9A%E4%BF%A1%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8-get"><span class="toc-number">1.12.</span> <span class="toc-text">12. V-for为什么要加个 key (福建光通互联通信有限公司)get</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">1.13.</span> <span class="toc-text">13. 单向数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E8%99%9A%E6%8B%9FDOM%E6%98%AF%E7%94%A8%E6%9D%A5%E5%B9%B2%E5%98%9B%E7%9A%84"><span class="toc-number">1.14.</span> <span class="toc-text">14. 虚拟DOM是用来干嘛的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%AE%88%E5%8D%AB"><span class="toc-number">1.15.</span> <span class="toc-text">15. 守卫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E8%B7%AF%E7%94%B1%E4%B8%AD%E9%85%8D%E7%BD%AE-404-%E9%A1%B5%E9%9D%A2"><span class="toc-number">1.16.</span> <span class="toc-text">16.路由中配置 404 页面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Vuex%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%EF%BC%885%EF%BC%89"><span class="toc-number">1.17.</span> <span class="toc-text">17. Vuex中的模块（5）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6"><span class="toc-number">1.18.</span> <span class="toc-text">18. 如何提高首屏加载速度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.19.</span> <span class="toc-text">19. 路由懒加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-DOM-%E4%B8%8EBOM-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F-BOIM%E5%92%8CDOM%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">20.DOM 与BOM 的理解？ BOIM和DOM的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E6%8D%95%E8%8E%B7%E5%92%8C%E5%86%92%E6%B3%A1%EF%BC%9F%E4%B8%AD%E9%80%94%E4%B8%AD%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">21.捕获和冒泡？中途中阻止冒泡执行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E5%A6%82%E4%BD%95%E4%BD%95%E8%AE%A9%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E5%80%BC%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">23.如何何让计算属性设置值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B-%E7%A6%8F%E5%BB%BA%E5%85%89%E9%80%9A%E4%BA%92%E8%81%94%E9%80%9A%E4%BF%A1%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8"><span class="toc-number">2.3.</span> <span class="toc-text">24.组件之间通信方式有哪些(福建光通互联通信有限公司)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-props-%E6%8E%A5%E5%8F%97%E5%AD%97%E6%AE%B5-%E5%8F%AA%E6%83%B3%E6%8E%A5%E5%8F%97%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE"><span class="toc-number">2.4.</span> <span class="toc-text">25.props 接受字段 只想接受数组类型，怎么配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E6%8F%92%E6%A7%BD%E5%92%8C%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.</span> <span class="toc-text">26.插槽和具名插槽的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD%E5%B9%B2%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">27.作用域插槽干什么用？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#28-vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%E7%A6%8F%E5%BB%BA%E5%85%89%E9%80%9A%E4%BA%92%E8%81%94%E9%80%9A%E4%BF%A1%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8"><span class="toc-number">3.1.</span> <span class="toc-text">28.vue 生命周期有哪些？(福建光通互联通信有限公司)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">29.父子组件生命周期的执行顺序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81"><span class="toc-number">3.3.</span> <span class="toc-text">30.防抖节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-hash%E6%A8%A1%E5%BC%8F%E5%92%8Chistory-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">31.hash模式和history 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-MVVM-MVC-%EF%BC%9F-%E7%A6%8F%E5%BB%BA%E5%85%89%E9%80%9A%E4%BA%92%E8%81%94%E9%80%9A%E4%BF%A1%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8"><span class="toc-number">3.5.</span> <span class="toc-text">33.MVVM  MVC ？(福建光通互联通信有限公司)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E8%AE%B2%E8%AE%B2%E8%99%9A%E6%8B%9F-DOM"><span class="toc-number">3.6.</span> <span class="toc-text">34.讲讲虚拟 DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-link-%E5%92%8Cimport%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-%E7%A6%8F%E5%BB%BA%E5%85%89%E9%80%9A%E4%BA%92%E8%81%94%E9%80%9A%E4%BF%A1%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8"><span class="toc-number">3.7.</span> <span class="toc-text">35.link 和import的区别？(福建光通互联通信有限公司)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-http-%E5%88%9B%E5%BB%BA%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F"><span class="toc-number">3.8.</span> <span class="toc-text">37.http 创建状态码？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%9F%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.9.</span> <span class="toc-text">38.什么是跨域？解决跨域的方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-http-%E4%B8%8Ehttps%EF%BC%9F-%E7%A6%8F%E5%BB%BA%E5%85%89%E9%80%9A%E4%BA%92%E8%81%94%E9%80%9A%E4%BF%A1%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8-%EF%BC%88%EF%BC%89"><span class="toc-number">3.10.</span> <span class="toc-text">39.http 与https？(福建光通互联通信有限公司)（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-get%E8%AF%B7%E6%B1%82%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-%E7%A6%8F%E5%BB%BA%E5%85%89%E9%80%9A%E4%BA%92%E8%81%94%E9%80%9A%E4%BF%A1%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8"><span class="toc-number">3.11.</span> <span class="toc-text">40.get请求和post请求的区别？(福建光通互联通信有限公司)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-cookie-%E5%92%8Clocalstorate-sessionstorage%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88-%E7%A6%8F%E5%BB%BA%E5%85%89%E9%80%9A%E4%BA%92%E8%81%94%E9%80%9A%E4%BF%A1%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8-%EF%BC%89"><span class="toc-number">3.12.</span> <span class="toc-text">41.cookie 和localstorate sessionstorage的区别（(福建光通互联通信有限公司)）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E5%85%B3%E4%BA%8E-Promise-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.13.</span> <span class="toc-text">42.关于 Promise 面试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%91%A2%EF%BC%9F"><span class="toc-number">3.14.</span> <span class="toc-text">43.宏任务包含哪些呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%91%A2%EF%BC%9F"><span class="toc-number">3.15.</span> <span class="toc-text">44.微任务包含哪些呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-async-await"><span class="toc-number">3.16.</span> <span class="toc-text">45. async await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-promise-%E5%92%8Csettimeout-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.17.</span> <span class="toc-text">46.promise 和settimeout 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%92%8C%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.18.</span> <span class="toc-text">47.同步请求和异步请求的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.19.</span> <span class="toc-text">48.文档数据库和结构数据库的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-v-html-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F-v-text%EF%BC%9F"><span class="toc-number">3.20.</span> <span class="toc-text">49.v-html 的作用？ v-text？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-vue%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9F"><span class="toc-number">3.21.</span> <span class="toc-text">50.vue事件监听有哪些修饰符？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-MVVM-%E5%92%8C-MVC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">3.22.</span> <span class="toc-text">51.MVVM 和 MVC的区别？理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.23.</span> <span class="toc-text">52.数据类型有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E8%99%9A%E6%8B%9Fdom%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.24.</span> <span class="toc-text">53.虚拟dom实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-route%E5%92%8Crouter%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.25.</span> <span class="toc-text">54.route和router的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-v-model%E5%8E%9F%E7%90%86"><span class="toc-number">3.26.</span> <span class="toc-text">55. v-model原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-%E6%80%8E%E4%B9%88%E7%BB%99vue%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E6%96%B9%E6%B3%95"><span class="toc-number">3.27.</span> <span class="toc-text">56.怎么给vue定义全局方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57-vue-router%E6%80%8E%E4%B9%88%E9%87%8D%E5%AE%9A%E5%90%91%E9%A1%B5%E9%9D%A2"><span class="toc-number">3.28.</span> <span class="toc-text">57. vue-router怎么重定向页面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58-%E8%B7%AF%E7%94%B1%E4%B8%AD%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE404%E9%A1%B5%E9%9D%A2"><span class="toc-number">3.29.</span> <span class="toc-text">58.路由中怎么配置404页面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-Es5%E5%92%8Ces6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.30.</span> <span class="toc-text">59.Es5和es6的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60-%E9%97%AD%E5%8C%85"><span class="toc-number">3.31.</span> <span class="toc-text">60.闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#61-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.32.</span> <span class="toc-text">61.深拷贝的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">3.33.</span> <span class="toc-text">62.数组去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-DOM%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9C%89%EF%BC%9A"><span class="toc-number">3.34.</span> <span class="toc-text">63.DOM事件分有：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%EF%BC%9A"><span class="toc-number">3.35.</span> <span class="toc-text">64.事件代理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#65-JavaScript%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">3.36.</span> <span class="toc-text">65.JavaScript的垃圾回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#66-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9A"><span class="toc-number">3.37.</span> <span class="toc-text">66.常见的内存泄漏：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#67-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">3.38.</span> <span class="toc-text">67.性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#68-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.39.</span> <span class="toc-text">68.箭头函数的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#69-%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.40.</span> <span class="toc-text">69.跨域解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70-%E8%BE%93%E5%85%A5url%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">3.41.</span> <span class="toc-text">70.输入url发生了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#71-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.42.</span> <span class="toc-text">71.浏览器渲染步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72-304%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.43.</span> <span class="toc-text">72.304的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73-http%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">3.44.</span> <span class="toc-text">73.http常用的状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74-es6%E7%9A%84%E6%8B%93%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E2%80%A6"><span class="toc-number">3.45.</span> <span class="toc-text">74.es6的拓展运算符…</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75-New%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">3.46.</span> <span class="toc-text">75.New操作符具体做了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#76-%E9%80%89%E7%94%A8%E6%A0%87%E7%AD%BE%E7%9A%84%E6%A0%87%E5%87%86"><span class="toc-number">3.47.</span> <span class="toc-text">76.选用标签的标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77-%E5%B8%83%E5%B1%80"><span class="toc-number">3.48.</span> <span class="toc-text">77.布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78-CSS%E5%8D%95%E4%BD%8D%E4%B8%8E%E8%AE%A1%E7%AE%97"><span class="toc-number">3.49.</span> <span class="toc-text">78.CSS单位与计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#79-CSS%E5%8D%8A%E9%80%8F%E6%98%8E-%E9%80%8F%E6%98%8E"><span class="toc-number">3.50.</span> <span class="toc-text">79.CSS半透明&#x2F;透明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#80-%E5%8A%A8%E7%94%BB"><span class="toc-number">3.51.</span> <span class="toc-text">80.动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#81-%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E4%B8%8E%E5%93%8D%E5%BA%94%E5%BC%8F%E9%A1%B5%E9%9D%A2"><span class="toc-number">3.52.</span> <span class="toc-text">81.媒体查询与响应式页面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#82-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E5%92%8CWeb-App%E9%A1%B5%E9%9D%A2"><span class="toc-number">3.53.</span> <span class="toc-text">82.浏览器兼容性和Web App页面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#83-Vue2-%E5%92%8Cvue3%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.54.</span> <span class="toc-text">83.Vue2 和vue3的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#84-%E6%8F%92%E6%A7%BD%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">3.55.</span> <span class="toc-text">84.插槽原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#85-%E5%85%B3%E4%BA%8Evue%E6%8F%92%E6%A7%BDslot%E6%9D%A5%E5%9B%9E%E4%BC%A0%E5%80%BC%E9%97%AE%E9%A2%98"><span class="toc-number">3.56.</span> <span class="toc-text">85.关于vue插槽slot来回传值问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#86-%E5%89%A7%E4%B8%AD%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%88%E4%BF%A9%E5%AE%B6%E5%85%AC%E5%8F%B8%E9%83%BD%E9%97%AE%E4%BA%86%EF%BC%89"><span class="toc-number">3.57.</span> <span class="toc-text">86.剧中的方式（俩家公司都问了）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#87-Vuex%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">3.58.</span> <span class="toc-text">87.Vuex的使用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#88-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%EF%BC%9F%E6%9C%89%E6%B2%A1%E6%9C%89%E8%87%AA%E5%B7%B1%E5%B0%81%E8%A3%85%E8%BF%87%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-number">3.59.</span> <span class="toc-text">88.什么情况下使用组件？有没有自己封装过组件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#89-%E6%9C%89%E6%B2%A1%E6%9C%89%E8%87%AA%E5%B7%B1%E5%86%99%E8%BF%87%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%EF%BC%9F"><span class="toc-number">3.60.</span> <span class="toc-text">89.有没有自己写过动画效果？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#90-Vue-%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.61.</span> <span class="toc-text">90.Vue 和小程序的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#91-Vue2-%E5%92%8Cvue3%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E4%B8%89%E5%AE%B6%E5%85%AC%E5%8F%B8%E9%83%BD%E9%97%AE%E4%BA%86%EF%BC%89"><span class="toc-number">3.62.</span> <span class="toc-text">91.Vue2 和vue3的区别？（三家公司都问了）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#92-Window%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.63.</span> <span class="toc-text">92.Window对象有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#93-http-%E5%92%8Chttps-%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">3.64.</span> <span class="toc-text">93.http 和https 结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">3.65.</span> <span class="toc-text">94.数据结构有了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#95-%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%932%E2%80%94%E2%80%94%E2%80%94%E2%80%93"><span class="toc-number">3.66.</span> <span class="toc-text">95.——————–2———–</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#96-Es3%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%EF%BC%9F"><span class="toc-number">3.67.</span> <span class="toc-text">96.Es3常用语法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#97-%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-number">3.68.</span> <span class="toc-text">97.深拷贝 浅拷贝？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#98-%E5%A6%82%E6%9E%9Cconst-%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84%E6%88%96%E8%80%85%E5%AF%B9%E8%B1%A1%E4%BA%86-%E8%83%BD%E6%94%B9%E5%8F%98%E5%85%B6%E4%B8%AD%E7%9A%84%E5%80%BC%E5%90%97%EF%BC%9F"><span class="toc-number">3.69.</span> <span class="toc-text">98.如果const 定义数组或者对象了 能改变其中的值吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#99-git-%E6%8C%87%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%AF%8F%E6%9D%A1%E6%8C%87%E4%BB%A4%E9%83%BD%E5%81%9A%E4%BA%86-%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">3.70.</span> <span class="toc-text">99.git 指令有哪些？每条指令都做了?原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#100-Js%E6%8E%92%E5%BA%8F%EF%BC%9F%EF%BC%88https-blog-csdn-net-weixin-46224014-article-details-121231814%EF%BC%89"><span class="toc-number">3.71.</span> <span class="toc-text">100.Js排序？（https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_46224014&#x2F;article&#x2F;details&#x2F;121231814）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#101-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.72.</span> <span class="toc-text">101.常用的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#102-node%EF%BC%8Cnpm%EF%BC%8Cvue%E5%8D%87%E7%BA%A7%E5%88%B0%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC"><span class="toc-number">3.73.</span> <span class="toc-text">102.node，npm，vue升级到指定版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#103-Grunt%EF%BC%88https-www-it610-com-article-1296113332306124800-htm%EF%BC%89"><span class="toc-number">3.74.</span> <span class="toc-text">103.Grunt（https:&#x2F;&#x2F;www.it610.com&#x2F;article&#x2F;1296113332306124800.htm）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#104-Array-%E5%92%8C-Object-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">3.75.</span> <span class="toc-text">104.Array 和 Object 有哪些原生方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#105-Eslin-%EF%BC%9Fhttp-eslint-cn-docs-user-guide-getting-started"><span class="toc-number">3.76.</span> <span class="toc-text">105.Eslin ？http:&#x2F;&#x2F;eslint.cn&#x2F;docs&#x2F;user-guide&#x2F;getting-started</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#106-Call-%E5%92%8C-apply-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-number">3.77.</span> <span class="toc-text">106. Call 和 apply 的区别与应用?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#107-JS-%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%9F%EF%BC%88https-blog-csdn-net-We-jia-article-details-87792818%EF%BC%89"><span class="toc-number">3.78.</span> <span class="toc-text">107.JS 开发模式？（https:&#x2F;&#x2F;blog.csdn.net&#x2F;We_jia&#x2F;article&#x2F;details&#x2F;87792818）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#108-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%EF%BC%9F-%EF%BC%88https-blog-csdn-net-lancun-web-article-details-109961050%EF%BC%89"><span class="toc-number">3.79.</span> <span class="toc-text">108.如何处理异步？ （https:&#x2F;&#x2F;blog.csdn.net&#x2F;lancun_web&#x2F;article&#x2F;details&#x2F;109961050）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#109-Jq-%E5%92%8C-js-%E9%83%BD%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%AF%B9-test-%E7%9A%84%E9%80%89%E6%8B%A9%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.80.</span> <span class="toc-text">109.Jq 和 js 都能实现对 #test 的选择，它们的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#110-%E4%BD%BF%E7%94%A8vue-js-%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E6%B2%A1%E5%8A%A0%E8%BD%BD%E5%AE%8C%E5%90%8E%E9%A1%B5%E9%9D%A2%E4%BC%9A%E6%98%BE%E7%A4%BA%E5%8F%8C%E6%8B%AC%E5%8F%B7%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">3.81.</span> <span class="toc-text">110.使用vue.js 的时候，页面加载数据没加载完后页面会显示双括号，怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#111-Hash-%E6%A8%A1%E5%BC%8F%E8%83%BD%E4%BD%BF%E7%94%A8cookie%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.82.</span> <span class="toc-text">111.Hash 模式能使用cookie吗？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#112-Router-%E5%92%8Croute-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.83.</span> <span class="toc-text">112.Router 和route 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#113-New-%E5%88%9B%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">3.84.</span> <span class="toc-text">113.New 创对象数的过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#114-Axios-%E5%BA%94%E8%AF%A5%E5%86%8D%E5%93%AA%E4%BA%9B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%87%8C%E9%9D%A2%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.85.</span> <span class="toc-text">114.Axios 应该再哪些生命周期里面？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#115-v-for-v-if-%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F"><span class="toc-number">3.86.</span> <span class="toc-text">115.v-for v-if 一起使用的优先级？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#116-%E5%85%B3%E4%BA%8E-meta-%E6%A0%87%E7%AD%BE%EF%BC%88https-blog-csdn-net-m0-51049889-article-details-118552562%EF%BC%89"><span class="toc-number">3.87.</span> <span class="toc-text">116.关于 meta 标签（https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_51049889&#x2F;article&#x2F;details&#x2F;118552562）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#117-meta-name-%E2%80%9Dviewport%E2%80%9D-content-%E2%80%9Dwidth-device-width-initial-scale-1-0%E2%80%9D%E7%90%86%E8%A7%A3"><span class="toc-number">3.88.</span> <span class="toc-text">117.meta name&#x3D;”viewport” content&#x3D;”width&#x3D;device-width,initial-scale&#x3D;1.0”理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#118-%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC"><span class="toc-number">3.89.</span> <span class="toc-text">118.合并单元格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#119-Vue-%E8%B7%AF%E7%94%B1%E7%9A%84%E7%9B%91%E5%90%AC%E6%96%B9%E5%BC%8F"><span class="toc-number">3.90.</span> <span class="toc-text">119.Vue 路由的监听方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#120-Promie-%E5%90%8C%E6%97%B6%E8%AF%B7%E6%B1%82%E5%A4%9A%E4%B8%AAurl%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F-async-await-%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">3.91.</span> <span class="toc-text">120.Promie 同时请求多个url的方法？ async await 理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#121-this-nextTick%EF%BC%9F%EF%BC%88vue2%EF%BC%89%E4%BD%9C%E7%94%A8%EF%BC%9F-https-www-jianshu-com-p-8411bab1b0db"><span class="toc-number">3.92.</span> <span class="toc-text">121.this.$nextTick？（vue2）作用？ https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;8411bab1b0db</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#121-1-vue%E4%B8%ADdata%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">3.93.</span> <span class="toc-text">121.1.vue中data为什么一个函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#122-ES6-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F%EF%BC%88https-blog-csdn-net-m0-56262444-article-details-116747048%EF%BC%89"><span class="toc-number">3.94.</span> <span class="toc-text">122.ES6 数组去重的方法？（https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_56262444&#x2F;article&#x2F;details&#x2F;116747048）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#123-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">3.95.</span> <span class="toc-text">123.数组去重的方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#124-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">3.96.</span> <span class="toc-text">124.遍历数组有哪些方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#125-%E6%95%B0%E7%BB%84%E4%B8%ADforEach%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.97.</span> <span class="toc-text">125.数组中forEach和map的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#126-%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.98.</span> <span class="toc-text">126.定位元素有哪些,有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#127-%E9%97%AD%E5%8C%85%E6%9C%89%E4%BA%86%E8%A7%A3%E4%B9%88-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.99.</span> <span class="toc-text">127.闭包有了解么,有什么优缺点?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#129-vuex%E6%98%AF%E4%BB%80%E4%B9%88-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E7%9A%84-https-blog-csdn-net-m0-56232007-article-details-118680241"><span class="toc-number">3.100.</span> <span class="toc-text">129.vuex是什么,怎么使用的(https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_56232007&#x2F;article&#x2F;details&#x2F;118680241)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#130-%E4%BB%80%E4%B9%88%E6%98%AF%E9%95%BF%E8%BF%9E%E6%8E%A5-%E7%9F%AD%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">3.101.</span> <span class="toc-text">130.什么是长连接 短连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#131-%E6%89%93%E5%BC%80%E7%99%BE%E5%BA%A6%E6%98%AF%E9%95%BF%E8%BF%9E%E6%8E%A5%E8%BF%98%E6%98%AF%E7%9F%AD%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">3.102.</span> <span class="toc-text">131.打开百度是长连接还是短连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#132-%E8%AE%B2%E8%AE%B2%E5%85%B3%E4%BA%8Edisplay-block"><span class="toc-number">3.103.</span> <span class="toc-text">132.讲讲关于display:block</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#display%E7%9A%84block%E3%80%81inline%E5%92%8Cinline-block%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.103.1.</span> <span class="toc-text">display的block、inline和inline-block的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%EF%BC%8C%E5%85%B6%E7%89%B9%E7%82%B9%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">3.103.2.</span> <span class="toc-text">对于行内元素和块级元素，其特点如下：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#133-%E8%AE%B2%E8%AE%B2-display%EF%BC%9Aflex%EF%BC%9F"><span class="toc-number">3.104.</span> <span class="toc-text">133.讲讲 display：flex？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%88%ACdisplay%EF%BC%9Aflex%E5%86%99%E5%9C%A8%E7%88%B6%E5%85%83%E7%B4%A0%E7%9A%84%E5%B1%9E%E6%80%A7%E4%B8%8A%EF%BC%81%E4%B8%8B%E9%9D%A2%E6%98%AF%E5%9F%BA%E6%9C%AC%E7%90%86%E8%A7%A3%EF%BC%81"><span class="toc-number">3.104.1.</span> <span class="toc-text">一般display：flex写在父元素的属性上！下面是基本理解！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E4%BD%9C%E7%94%A8%E5%9C%A8%E7%88%B6%E5%85%83%E7%B4%A0%E4%B8%8A%EF%BC%9F"><span class="toc-number">3.104.2.</span> <span class="toc-text">哪些属性作用在父元素上？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E4%BD%9C%E7%94%A8%E5%9C%A8%E5%AD%90%E5%85%83%E7%B4%A0%E4%B8%8A%EF%BC%9F"><span class="toc-number">3.104.3.</span> <span class="toc-text">哪些属性作用在子元素上？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-react-hooks"><span class="toc-number">3.105.</span> <span class="toc-text">134.react hooks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E4%B8%8B%E5%85%B3%E4%BA%8Ereact%E7%9A%84%E6%96%87%E7%AB%A0%E6%9D%A5%E6%BA%90"><span class="toc-number">3.106.</span> <span class="toc-text">以下关于react的文章来源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%9D%A5%E6%BA%90"><span class="toc-number">3.107.</span> <span class="toc-text">参考来源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#134-1-React-%E5%8A%A0%E5%85%A5-Hooks-%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88-React-%E8%A6%81%E5%8A%A0%E5%85%A5Hooks-%E8%BF%99%E4%B8%80%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">3.107.1.</span> <span class="toc-text">134.1 React 加入 Hooks 的意义是什么？为什么 React 要加入Hooks 这一特性？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-2-if-else%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E9%87%8C%E4%BD%BF%E7%94%A8hooks%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.108.</span> <span class="toc-text">134.2 if else条件判断里使用hooks有什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-3-hooks%E9%97%AD%E5%8C%85%E7%9A%84%E5%9D%91%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">3.109.</span> <span class="toc-text">134.3 hooks闭包的坑有哪些？如何解决?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-3-%E5%B8%B8%E7%94%A8%E7%9A%84Hooks%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.110.</span> <span class="toc-text">134.3 常用的Hooks有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-4-useEffect%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%97%A0%E9%99%90%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.111.</span> <span class="toc-text">134.4 useEffect为什么有时候会出现无限重复请求的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-5-React-Hooks-api%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">3.112.</span> <span class="toc-text">134.5 React Hooks api的原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-6-React-Hooks%E5%A6%82%E4%BD%95%E6%A8%A1%E6%8B%9F%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="toc-number">3.113.</span> <span class="toc-text">134.6 React Hooks如何模拟组件生命周期？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-7-%E6%A8%A1%E6%8B%9F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8Cclass%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%90%97%EF%BC%9F"><span class="toc-number">3.114.</span> <span class="toc-text">134.7 模拟的生命周期和class中的生命周期有什么区别吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-8-Hooks%E7%9B%B8%E6%AF%94HOC%E5%92%8CRender-Prop%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-number">3.115.</span> <span class="toc-text">134.8 Hooks相比HOC和Render Prop有哪些优点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-9-Function-Component%E4%B8%8EClass-Component%E5%8C%BA%E5%88%AB"><span class="toc-number">3.116.</span> <span class="toc-text">134.9 Function Component与Class Component区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-9-useState%E5%92%8CsetState%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.117.</span> <span class="toc-text">134.9 useState和setState区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-10-useState%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E6%9B%B4%E6%96%B0%E7%8A%B6%E6%80%81%E5%92%8Cclass%E4%B8%AD%E7%9A%84this-setState%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.118.</span> <span class="toc-text">134.10 useState中的第二个参数更新状态和class中的this.setState区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-11-useReducer%E5%92%8Credux%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.119.</span> <span class="toc-text">134.11 useReducer和redux区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-12-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89HOOK"><span class="toc-number">3.120.</span> <span class="toc-text">134.12 如何自定义HOOK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-13-Hooks%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">3.121.</span> <span class="toc-text">134.13 Hooks性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-14-%E6%80%8E%E4%B9%88%E5%9C%A8%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E9%87%8C%E9%9D%A2%E8%AE%BF%E9%97%AE%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.122.</span> <span class="toc-text">134.14 怎么在高阶组件里面访问组件实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#135-%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E5%8A%A8%E7%94%BB%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%9F"><span class="toc-number">3.123.</span> <span class="toc-text">135 关于前端动画的总结？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%9D%A5%E6%BA%90-1"><span class="toc-number">3.124.</span> <span class="toc-text">参考来源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#136-%E6%B8%85%E6%A5%9A%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">3.125.</span> <span class="toc-text">136 清楚浮动的方法？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%A9%E7%94%A8%E4%BC%AA%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%8C%E6%B7%BB%E5%8A%A0%E7%A9%BAdiv%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AE%E3%80%90clear-both%E3%80%91"><span class="toc-number">3.125.1.</span> <span class="toc-text">1.利用伪元素选择器，添加空div，并设置【clear:both】</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%99%E7%88%B6%E5%85%83%E7%B4%A0%E8%AE%BE%E7%BD%AE%E8%B6%85%E5%87%BA%E9%83%A8%E5%88%86%E9%9A%90%E8%97%8F"><span class="toc-number">3.126.</span> <span class="toc-text">2. 给父元素设置超出部分隐藏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A4%A7%E9%99%86%E9%9D%A2%E8%AF%95"><span class="toc-number">3.127.</span> <span class="toc-text">新大陆面试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">答案：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%99%A4%E4%BA%86%E9%81%8D%E5%8E%86%E7%9A%84for%E5%BE%AA%E7%8E%AF%EF%BC%8C%E8%BF%98%E4%BA%86%E8%A7%A3%E9%82%A3%E4%BA%9Bfor%E5%BE%AA%E7%8E%AF%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">1.除了遍历的for循环，还了解那些for循环？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%80%8E%E4%B9%88%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">2.怎么遍历对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E7%BD%91%E5%9D%80"><span class="toc-number">4.3.</span> <span class="toc-text">参考网址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%80%8E%E4%B9%88%E7%BB%88%E6%AD%A2for%E5%BE%AA%E7%8E%AF%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">3.怎么终止for循环？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E7%BD%91%E5%9D%80-1"><span class="toc-number">4.5.</span> <span class="toc-text">参考网址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Nodejs-%E8%83%BD%E8%8E%B7%E5%8F%96window%E5%AF%B9%E8%B1%A1%E5%98%9B%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">4.Nodejs 能获取window对象嘛？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%80%8E%E4%B9%88%E7%BC%96%E5%86%99%E4%B8%83%E5%A4%A9%E5%85%8D%E5%AF%86%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95"><span class="toc-number">4.7.</span> <span class="toc-text">5.怎么编写七天免密免密登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E7%BD%91%E5%9D%80-2"><span class="toc-number">4.8.</span> <span class="toc-text">参考网址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Locoalstorage%E5%92%8Csessionstorage%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.9.</span> <span class="toc-text">6.Locoalstorage和sessionstorage的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E7%BD%91%E5%9D%80-3"><span class="toc-number">4.10.</span> <span class="toc-text">参考网址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Sessionstorage%E5%9C%A8%E5%90%8C%E4%B8%AA%E7%AB%AF%E5%8F%A3%E4%B8%8B%E5%88%87%E6%8D%A2%E9%A1%B5%E9%9D%A2%EF%BC%8Csessionstorage%E8%BF%98%E5%AD%98%E5%9C%A8%E5%98%9B%EF%BC%9F"><span class="toc-number">4.11.</span> <span class="toc-text">7..Sessionstorage在同个端口下切换页面，sessionstorage还存在嘛？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E7%BD%91%E5%9D%80-4"><span class="toc-number">4.12.</span> <span class="toc-text">参考网址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Cookie%E5%AD%98%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">4.13.</span> <span class="toc-text">8.Cookie存放在哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3"><span class="toc-number">4.14.</span> <span class="toc-text">cookie面试相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E7%BD%91%E5%9D%80-5"><span class="toc-number">4.15.</span> <span class="toc-text">参考网址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%9C%A8nodejs%E9%87%8C%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96cookie%EF%BC%9F"><span class="toc-number">4.16.</span> <span class="toc-text">9.在nodejs里怎么获取cookie？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E7%BD%91%E5%9D%80-6"><span class="toc-number">4.17.</span> <span class="toc-text">参考网址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%9C%A8nodejs%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%BF%87%E9%82%A3%E4%BA%9B%E6%8F%92%E4%BB%B6%EF%BC%9F"><span class="toc-number">4.18.</span> <span class="toc-text">10.在nodejs环境中使用过那些插件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9C%89%E4%BA%86%E8%A7%A3%E5%98%9B%EF%BC%9FRpx-%E5%92%8Cpx%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.19.</span> <span class="toc-text">11.微信小程序有了解嘛？Rpx 和px的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-js%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.20.</span> <span class="toc-text">12.js是单线程还是多线程？为什么？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/02/0802review/" title="0802review"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="0802review"/></a><div class="content"><a class="title" href="/2022/08/02/0802review/" title="0802review">0802review</a><time datetime="2022-08-01T23:54:46.000Z" title="Created 2022-08-02 07:54:46">2022-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/02/0801interview/" title="0801interview"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="0801interview"/></a><div class="content"><a class="title" href="/2022/08/02/0801interview/" title="0801interview">0801interview</a><time datetime="2022-08-01T23:47:14.000Z" title="Created 2022-08-02 07:47:14">2022-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/01/vue-diff/" title="vue_diff"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vue_diff"/></a><div class="content"><a class="title" href="/2022/08/01/vue-diff/" title="vue_diff">vue_diff</a><time datetime="2022-08-01T12:19:42.000Z" title="Created 2022-08-01 20:19:42">2022-08-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/31/0731vueRiview/" title="0731vueRiview"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="0731vueRiview"/></a><div class="content"><a class="title" href="/2022/07/31/0731vueRiview/" title="0731vueRiview">0731vueRiview</a><time datetime="2022-07-31T03:24:00.000Z" title="Created 2022-07-31 11:24:00">2022-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/24/vuecli2AndVueCli3/" title="vuecli2AndVueCli3"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vuecli2AndVueCli3"/></a><div class="content"><a class="title" href="/2022/07/24/vuecli2AndVueCli3/" title="vuecli2AndVueCli3">vuecli2AndVueCli3</a><time datetime="2022-07-24T09:44:17.000Z" title="Created 2022-07-24 17:44:17">2022-07-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By MaxLi</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>