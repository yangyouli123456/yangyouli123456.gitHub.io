<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>newInterView | Hexo</title><meta name="author" content="MaxLi"><meta name="copyright" content="MaxLi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="公司实战面试本文章仅个人学习使用(个人笔记)1. ()&#x3D;&gt; 箭头函数指向问题。箭头函数里面的this什么时候有值？（公司实战面试）12345箭头函数中的this是在函数定义的时候就确定下来的，而不是在函数调用的时候确定的箭头函数中的this指向父级作用域的执行上下文（技巧：因为javascript中除了全局作用域，其他作用域都是由函数创建出来的，所以如果想确定this的指向，则找到离箭头函数">
<meta property="og:type" content="article">
<meta property="og:title" content="newInterView">
<meta property="og:url" content="http://example.com/2022/07/13/newInterView/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="公司实战面试本文章仅个人学习使用(个人笔记)1. ()&#x3D;&gt; 箭头函数指向问题。箭头函数里面的this什么时候有值？（公司实战面试）12345箭头函数中的this是在函数定义的时候就确定下来的，而不是在函数调用的时候确定的箭头函数中的this指向父级作用域的执行上下文（技巧：因为javascript中除了全局作用域，其他作用域都是由函数创建出来的，所以如果想确定this的指向，则找到离箭头函数">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-07-13T07:44:41.000Z">
<meta property="article:modified_time" content="2022-07-29T14:27:08.078Z">
<meta property="article:author" content="MaxLi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/07/13/newInterView/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'newInterView',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-29 22:27:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">newInterView</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-07-13T07:44:41.000Z" title="Created 2022-07-13 15:44:41">2022-07-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-07-29T14:27:08.078Z" title="Updated 2022-07-29 22:27:08">2022-07-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="newInterView"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="公司实战面试"><a href="#公司实战面试" class="headerlink" title="公司实战面试"></a>公司实战面试</h3><h3 id="本文章仅个人学习使用-个人笔记"><a href="#本文章仅个人学习使用-个人笔记" class="headerlink" title="本文章仅个人学习使用(个人笔记)"></a>本文章仅个人学习使用(个人笔记)</h3><h4 id="1-gt-箭头函数指向问题。箭头函数里面的this什么时候有值？（公司实战面试）"><a href="#1-gt-箭头函数指向问题。箭头函数里面的this什么时候有值？（公司实战面试）" class="headerlink" title="1. ()=&gt; 箭头函数指向问题。箭头函数里面的this什么时候有值？（公司实战面试）"></a>1. ()=&gt; 箭头函数指向问题。箭头函数里面的this什么时候有值？（公司实战面试）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">箭头函数中的<span class="variable language_">this</span>是在函数定义的时候就确定下来的，而不是在函数调用的时候确定的</span><br><span class="line">箭头函数中的<span class="variable language_">this</span>指向父级作用域的执行上下文</span><br><span class="line">（技巧：因为javascript中除了全局作用域，其他作用域都是由函数创建出来的，</span><br><span class="line">所以如果想确定<span class="variable language_">this</span>的指向，则找到离箭头函数最近的<span class="keyword">function</span>,与该<span class="keyword">function</span>平级的执行上下文中的<span class="variable language_">this</span>即是箭头函数中的<span class="variable language_">this</span>）</span><br><span class="line">箭头函数无法使用apply、call和bind方法改变<span class="variable language_">this</span>指向，因为其<span class="variable language_">this</span>值在函数定义的时候就被确定下来。</span><br></pre></td></tr></table></figure>
<h4 id="2-vuex-了解？（公司实战面试）"><a href="#2-vuex-了解？（公司实战面试）" class="headerlink" title="2. vuex 了解？（公司实战面试）"></a>2. vuex 了解？（公司实战面试）</h4><h4 id="2-1-vuex-属性："><a href="#2-1-vuex-属性：" class="headerlink" title="2.1 vuex 属性："></a>2.1 vuex 属性：</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vuex 是框架中的状态管理。在main.js 中引用</span><br><span class="line">state：基本数据</span><br><span class="line">getters：从基本数据中派生的数据</span><br><span class="line">mutation：提交更改数据的方法，同步</span><br><span class="line">action：装饰器，包裹mutation，使之可以异步</span><br><span class="line">module：模块化 vuex</span><br></pre></td></tr></table></figure>

<h4 id="2-2-vuex中state的特性？"><a href="#2-2-vuex中state的特性？" class="headerlink" title="2.2 vuex中state的特性？"></a>2.2 vuex中state的特性？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">state就是存储数据的地方，类似于一个厂库。特性就是当mutation修改</span><br><span class="line">state的数据的时候没他会主动的去修改所有的调用这个变量的所有组件里面的值</span><br><span class="line">(若是store中的数据发生改变，依赖这个数据组件也会发生更新)</span><br></pre></td></tr></table></figure>
<h4 id="2-3-vuex-中的getter特性？"><a href="#2-3-vuex-中的getter特性？" class="headerlink" title="2.3 vuex 中的getter特性？"></a>2.3 vuex 中的getter特性？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getter 是用获取数据的，常在计算属性中使用</span><br></pre></td></tr></table></figure>
<h4 id="2-4-vuex中mutation的特性？"><a href="#2-4-vuex中mutation的特性？" class="headerlink" title="2.4 vuex中mutation的特性？"></a>2.4 vuex中mutation的特性？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">action 类似于mutatoon，不同在于：</span><br><span class="line">action 提交的是 mutation，而不是直接更改状态。</span><br><span class="line">action可以包含任意异步操作</span><br></pre></td></tr></table></figure>
<h4 id="使用vuex-会带来什么问题？"><a href="#使用vuex-会带来什么问题？" class="headerlink" title="使用vuex 会带来什么问题？"></a>使用vuex 会带来什么问题？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客维护性下降，想要修改数据要司改三个地方</span><br><span class="line">可读性下降，因为组件里面的数据看不出从哪里来的</span><br><span class="line">增加耦合，大量的上传派发，让耦合性大大的增加，本来vue的</span><br><span class="line">component就是为了减少耦合，</span><br></pre></td></tr></table></figure>

<h4 id="3-mutation-是同步的函数异步的？-（公司实战面试）"><a href="#3-mutation-是同步的函数异步的？-（公司实战面试）" class="headerlink" title="3.mutation 是同步的函数异步的？ （公司实战面试）"></a>3.mutation 是同步的函数异步的？ （公司实战面试）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同步</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-vue-路由模式？为什么？怎么实现的？（公司实战面试）"><a href="#4-vue-路由模式？为什么？怎么实现的？（公司实战面试）" class="headerlink" title="4.vue 路由模式？为什么？怎么实现的？（公司实战面试）"></a>4.vue 路由模式？为什么？怎么实现的？（公司实战面试）</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hash :</span><br><span class="line">	使用URL的hash来模式一个完整的URL，于是当URL改变的时候，页面不会重载</span><br><span class="line">	，其显示的网络路径中会有#号，最安全的模式，因为他兼容所有的浏览器和服务器</span><br><span class="line">history：</span><br><span class="line">	依赖于 h5 的history、pushState API,方法有bakc、forwaed、go三种方法，对浏览器</span><br><span class="line">	的前进、后退、跳转操作。就是浏览器上的脚的 前进后退等按钮进行的操作</span><br><span class="line">	缺点：不怕前进后退，就怕刷新(如果后端没有准备的话)，因为刷新就是实实在在的去服务器请求数据</span><br></pre></td></tr></table></figure>
<h4 id="5-ES6-中-Set-Map？（公司实战面试）来源网址"><a href="#5-ES6-中-Set-Map？（公司实战面试）来源网址" class="headerlink" title="5. ES6 中 Set Map？（公司实战面试）来源网址"></a>5. ES6 中 Set Map？（公司实战面试）<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43359799/article/details/123131917">来源网址</a></h4><h4 id="相关知识点："><a href="#相关知识点：" class="headerlink" title="相关知识点："></a>相关知识点：</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set 和 Map主要的运用场景再看于 数据重构和数据存储</span><br><span class="line">Set 是一种叫做集合的数据结构，Map是一种叫做字典的数据结构</span><br></pre></td></tr></table></figure>
<h4 id="集合和字典的区别？"><a href="#集合和字典的区别？" class="headerlink" title="集合和字典的区别？"></a>集合和字典的区别？</h4><h4 id><a href="#" class="headerlink" title></a></h4><h4 id="6-let-var-const-？（公司实战面试）"><a href="#6-let-var-const-？（公司实战面试）" class="headerlink" title="6.let var const ？（公司实战面试）"></a>6.let var const ？（公司实战面试）</h4><h4 id="原网址"><a href="#原网址" class="headerlink" title="原网址"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43875051/article/details/106189824">原网址</a></h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. var 是ES5提出的，let 是ES6提出的</span><br><span class="line">2. 2. const声明的是常量，必须赋值</span><br><span class="line">1）一旦声明必须赋值，不能使用null占位</span><br><span class="line">2）声明后不能修改</span><br><span class="line">3）如果声明的是符合类型数据，可以修改器属性</span><br><span class="line">3. let 和var 声明的是变量，声明之后可以修改，声明时可以不用赋值</span><br><span class="line">4. var 允许重复声明变量，后面的变量会覆盖前面的变量。let和const</span><br><span class="line">5. 在同一作用域下不允许重复声明变量。会报错。</span><br><span class="line">6. var 的变量存在变量(将变量提升到当前作用域的顶部)。及变量可以在</span><br><span class="line">声明之前调用,值为undefined。let 和const 不存在变量提升，他们所声明</span><br><span class="line">的变量要在声明之后使用。否者会报错 ReferenceError。</span><br><span class="line">7. var 不存在块级作用域。let 和 const 存在块级作用域</span><br><span class="line">8. ES5中作用域有：全局作用域：全局作用域、函数作用域。没有</span><br><span class="line">块级作用域的概念。</span><br><span class="line">9. ES6(简称ES6) 中增加了块级作用域。块级作用域由&#123;&#125;包括。if 和</span><br><span class="line">for 语句里面的&#123;&#125; 也属于会计作用域</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="7-vue中做了那些优化？（公司实战面试）"><a href="#7-vue中做了那些优化？（公司实战面试）" class="headerlink" title="7. vue中做了那些优化？（公司实战面试）"></a>7. vue中做了那些优化？（公司实战面试）</h4><h4 id="原网址-1"><a href="#原网址-1" class="headerlink" title="原网址"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/lemon_LiFu/article/details/117338092">原网址</a></h4><h4 id="7-1-代码层的优化"><a href="#7-1-代码层的优化" class="headerlink" title="7.1 代码层的优化"></a>7.1 代码层的优化</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. v-if 和 v-show 区分使用场景</span><br><span class="line">v-if 是真正的条件渲染，因为它会确保在切换的过程中条件块内的事件监听器和子组件适当的被摧毁</span><br><span class="line">和从建；也是惰性的。如果在初始条件为假时，则什么也不做,一直到条件是第一次变为真时</span><br><span class="line">才会	开始渲染。</span><br><span class="line"></span><br><span class="line">2. v-show 不管初始条件是什么，元素重视呗渲染，并且只是简单的基于css的display</span><br><span class="line">属性进行切换。</span><br><span class="line"></span><br><span class="line">总结：v-if 适用于运行时很少切换条件的场景；v-show 则适用于需要非常频繁的</span><br><span class="line">切换条件的场景</span><br></pre></td></tr></table></figure>
<h4 id="7-2-computed-和-watch-区分使用场景"><a href="#7-2-computed-和-watch-区分使用场景" class="headerlink" title="7.2 computed 和 watch 区分使用场景"></a>7.2 computed 和 watch 区分使用场景</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">computed: </span><br><span class="line">	是计算属性，依赖其他属性值，并且 computed 的值有缓存。</span><br><span class="line">	只有	它依赖的属性值发生改变，下一次获取 computed 的值才会重新计算 </span><br><span class="line">	computed 的值。</span><br><span class="line"></span><br><span class="line">watch：</span><br><span class="line">	更多的是[观察]的作用，类似于某些数据的监听回调，每当监听数据变化时都会</span><br><span class="line">	执行回调后进行后续操作</span><br><span class="line"></span><br><span class="line">	* 使用场景：</span><br><span class="line">	当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，</span><br><span class="line">	因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</span><br><span class="line"></span><br><span class="line">	当我们需要在数据变化时执行异步或开销较大的操作时，</span><br><span class="line">	应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，</span><br><span class="line">	限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。</span><br><span class="line">	这些都是计算属性无法做到的。</span><br></pre></td></tr></table></figure>


<h4 id="7-3-v-for-遍历必须为-item-添加-key。且避免同时使用-v-if"><a href="#7-3-v-for-遍历必须为-item-添加-key。且避免同时使用-v-if" class="headerlink" title="7.3 v-for 遍历必须为 item 添加 key。且避免同时使用 v-if"></a>7.3 v-for 遍历必须为 item 添加 key。且避免同时使用 v-if</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">* * v-<span class="keyword">for</span> 遍历必须为 item 添加 key</span><br><span class="line">	* 在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，</span><br><span class="line">	* 方便 <span class="title class_">Vue</span>.<span class="property">js</span> 内部机制精准找到该条列表数据。当 state 更新时，</span><br><span class="line">	* 新的状态值和旧的状态值对比，较快地定位到 diff 。</span><br><span class="line">* * v-<span class="keyword">for</span> 遍历避免同时使用 v-<span class="keyword">if</span></span><br><span class="line">	* v-<span class="keyword">for</span> 比 v-<span class="keyword">if</span> 优先级高，如果每一次都需要遍历整个数组，</span><br><span class="line">	* 将会影响速度，尤其是当之需要渲染很小一部分的时候，</span><br><span class="line">	* 必要情况下应该替换成 computed 属性。</span><br><span class="line"> 推荐使用：</span><br><span class="line">	 &lt;ul&gt;</span><br><span class="line">	   <span class="language-xml"><span class="tag">&lt;<span class="name">li</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		 <span class="attr">v-for</span>=<span class="string">&quot;user in activeUsers&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		 <span class="attr">:key</span>=<span class="string">&quot;user.id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		 &#123;&#123; user.name &#125;&#125;</span></span><br><span class="line"><span class="language-xml">	   <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">	 &lt;/ul&gt;</span><br><span class="line">	 <span class="attr">computed</span>: &#123;</span><br><span class="line">	   <span class="attr">activeUsers</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">		 <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">users</span>.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">user</span>) &#123;</span><br><span class="line">	  <span class="keyword">return</span> user.<span class="property">isActive</span></span><br><span class="line">		 &#125;)</span><br><span class="line">	   &#125;</span><br><span class="line">	 &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h4 id="7-4-长列表性能优化"><a href="#7-4-长列表性能优化" class="headerlink" title="7.4 长列表性能优化"></a>7.4 长列表性能优化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">冻结对象：</span><br><span class="line">	<span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	  <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">		<span class="attr">users</span>: &#123;&#125;</span><br><span class="line">	  &#125;),</span><br><span class="line">	  <span class="keyword">async</span> <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">const</span> users = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&quot;/api/users&quot;</span>);</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">users</span> = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(users);</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="7-5-事件的销毁"><a href="#7-5-事件的销毁" class="headerlink" title="7.5 事件的销毁"></a>7.5 事件的销毁</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：</span><br><span class="line"><span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="variable language_">this</span>.<span class="property">click</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">beforeDestroy</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="variable language_">this</span>.<span class="property">click</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="7-6-图片懒加载"><a href="#7-6-图片懒加载" class="headerlink" title="7.6 图片懒加载"></a>7.6 图片懒加载</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。</span><br><span class="line">插件：npm install vue-lazyload --save-dev</span><br><span class="line"></span><br><span class="line">man.<span class="property">js</span> ：<span class="keyword">import</span> <span class="title class_">VueLazyload</span> <span class="keyword">from</span> <span class="string">&#x27;vue-lazyload&#x27;</span></span><br><span class="line"></span><br><span class="line">使用：<span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueLazyload</span>)</span><br><span class="line"></span><br><span class="line">在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，</span><br><span class="line">从而将图片显示方式更改为懒加载显示：</span><br><span class="line">&lt;img v-lazy=<span class="string">&quot;/static/img/1.png&quot;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="7-7-路由懒加载"><a href="#7-7-路由懒加载" class="headerlink" title="7.7 路由懒加载"></a>7.7 路由懒加载</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">很多的路由引入 ，这样使用 webpcak 打包后的文件很大，</span><br><span class="line">当进入首页时，加载的资源过多，页面会出现白屏的情况:</span><br><span class="line"></span><br><span class="line">路由懒加载：</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Foo</span> = (<span class="params"></span>) =&gt; <span class="title function_">import</span>(<span class="string">&#x27;./Foo.vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">	&#123; <span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Foo</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="7-8-第三方插件的按需引入"><a href="#7-8-第三方插件的按需引入" class="headerlink" title="7.8 第三方插件的按需引入"></a>7.8 第三方插件的按需引入</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">	我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，</span><br><span class="line">	会导致项目的体积太大，我们可以借助 babel-plugin-component ，</span><br><span class="line">	然后可以只引入需要的组件，以达到减小项目体积的目的。</span><br><span class="line">	以下为项目中引入 element-ui 组件库为例：</span><br><span class="line"></span><br><span class="line">然后，将 .<span class="property">babelrc</span> 修改为：</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="string">&quot;presets&quot;</span>: [[<span class="string">&quot;es2015&quot;</span>, &#123; <span class="string">&quot;modules&quot;</span>: <span class="literal">false</span> &#125;]],</span><br><span class="line">		  <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">			[</span><br><span class="line">			  <span class="string">&quot;component&quot;</span>,</span><br><span class="line">			  &#123;</span><br><span class="line">				<span class="string">&quot;libraryName&quot;</span>: <span class="string">&quot;element-ui&quot;</span>,</span><br><span class="line">				<span class="string">&quot;styleLibraryName&quot;</span>: <span class="string">&quot;theme-chalk&quot;</span></span><br><span class="line">			  &#125;</span><br><span class="line">			]</span><br><span class="line">		  ]</span><br><span class="line">		&#125;</span><br><span class="line">		在 main.<span class="property">js</span> 中引入部分组件：</span><br><span class="line">		<span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line">		<span class="keyword">import</span> &#123; <span class="title class_">Button</span>, <span class="title class_">Select</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Button</span>)</span><br><span class="line">		<span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Select</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="7-9-优化无限列表性能"><a href="#7-9-优化无限列表性能" class="headerlink" title="7.9 优化无限列表性能"></a>7.9 优化无限列表性能</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果你的应用存在非常长或者无限滚动的列表，</span><br><span class="line">那么需要采用 窗口化 的技术来优化性能，</span><br><span class="line">只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。</span><br><span class="line">你可以参考以下开源项目 vue-virtual-scroll-list 和 vue-virtual-scroller</span><br><span class="line">来优化这种无限列表的场景的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="服务端渲染-SSR-or-预渲染"><a href="#服务端渲染-SSR-or-预渲染" class="headerlink" title="服务端渲染 SSR or 预渲染"></a>服务端渲染 SSR or 预渲染</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">		服务端渲染是指 Vue 在客户端将标签渲染成的整个 </span><br><span class="line">		html 片段的工作在服务端完成，服务端形成的 </span><br><span class="line">		html 片段直接返回给客户端这个过程就叫做服务端渲染。</span><br><span class="line"></span><br><span class="line">（1）服务端渲染的优点：</span><br><span class="line">		更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，</span><br><span class="line">		而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，</span><br><span class="line">		所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；</span><br><span class="line">		而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），</span><br><span class="line">		所以搜索引擎爬取工具可以抓取渲染好的页面；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 </span><br><span class="line">		js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，</span><br><span class="line">		所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，</span><br><span class="line">		无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</span><br><span class="line"></span><br><span class="line">（2）服务端渲染的缺点：</span><br><span class="line">		更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，</span><br><span class="line">		这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；</span><br><span class="line">		并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，</span><br><span class="line">		服务端渲染应用程序，需要处于 Node.js server 运行环境；</span><br></pre></td></tr></table></figure>
<h4 id="vue-中-nextTick？"><a href="#vue-中-nextTick？" class="headerlink" title="vue 中$nextTick？"></a>vue 中$nextTick？</h4><h4 id="原网址-2"><a href="#原网址-2" class="headerlink" title="原网址"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_41696687/article/details/124057228">原网址</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">一、$nextTick有什么用？</span><br><span class="line">		Vue是异步渲染的框架。</span><br><span class="line">		data改变之后，DOM不会立刻渲染。</span><br><span class="line">		$nextTick会在DOM渲染之后被触发，以获取最新的DOM节点。</span><br><span class="line">		连续多次的异步渲染，$nextTick只会执行最后一次渲染后的结果。</span><br><span class="line"></span><br><span class="line">二、$nextTick的原理</span><br><span class="line">		$nextTick主要通过事件循环中的任务队列的方式异步执行传入的回调函数，</span><br><span class="line">		首先会判断当前的执行环境是否支持Promise，MutationObserver，</span><br><span class="line">		setImmediate，setTimeout。如果支持则创建对应的异步方法，</span><br><span class="line">		这里的MutationObserver并不是监听DOM，而是利用其微任务特性。</span><br><span class="line">		需要注意的是更新DOM的方法也是通过nextTick进行调用的,</span><br><span class="line">		因此就可以实现传入$.nextTick的回调函数在DOM渲染完成之后执行这些微任务。</span><br><span class="line"></span><br><span class="line">三、循环调用的话nextTick里面有容错机制吗？</span><br><span class="line">		多次调用 nextTick 会将方法存入队列 callbacks 中，通过这个异步方法清空当前队列。</span><br></pre></td></tr></table></figure>
<h4 id="捷宇科技（面试）7-14"><a href="#捷宇科技（面试）7-14" class="headerlink" title="捷宇科技（面试）7.14"></a>捷宇科技（面试）7.14</h4><h4 id="1-父子之间传值？"><a href="#1-父子之间传值？" class="headerlink" title="1.父子之间传值？"></a>1.父子之间传值？</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">props</span><br><span class="line">$emit</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-ref-里面有什么？参考"><a href="#2-ref-里面有什么？参考" class="headerlink" title="2. ref 里面有什么？参考"></a>2. ref 里面有什么？<a target="_blank" rel="noopener" href="https://blog.csdn.net/lefex/article/details/111570722">参考</a></h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">访问组件实例和 DOM 元素</span><br><span class="line">通过定义的名字找到对应的组件或 DOM 元素，而 DOM 元素在 Vue 渲染后会保存到虚拟节点中</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-生命周期有哪些？"><a href="#3-生命周期有哪些？" class="headerlink" title="3 生命周期有哪些？"></a>3 生命周期有哪些？</h4><p><img src="https://img-blog.csdnimg.cn/dbce03f111774abcbb99c6e1657ba331.png" alt="生命周期有哪些"></p>
<h4 id="生命周期整体流程"><a href="#生命周期整体流程" class="headerlink" title="生命周期整体流程"></a>生命周期整体流程</h4><p><img src="https://img-blog.csdnimg.cn/a0c38f75a39f4095b88c894ff2680b6d.png" alt="生命周期流程"></p>
<h4 id="3-1-created-和-mounted？-生命周期"><a href="#3-1-created-和-mounted？-生命周期" class="headerlink" title="3.1 created 和 mounted？(生命周期)"></a>3.1 created 和 mounted？(生命周期)</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate -&gt; created:</span><br><span class="line">	初始化vue实例，进行数据观测</span><br><span class="line">created:</span><br><span class="line">	完成数据观测，属性与方法的运算，watch、event事件回调的配置</span><br><span class="line">	可调用methods中的方法，访问和修改data数据触发响应式渲染dom，可通过computed和watch完成数据计算</span><br><span class="line">	此时vm.$el 并没有被创建</span><br><span class="line"></span><br><span class="line">created -&gt; beforeMount:</span><br><span class="line">	判断是否存在el选项，若不存在则停止编译，直到调用vm.$mount(el)才会继续编译</span><br><span class="line">	优先级：render &gt; template &gt; outerHTML</span><br><span class="line">	vm.el获取到的是挂载DOM的</span><br><span class="line"></span><br><span class="line">beforeMount:</span><br><span class="line">		在此阶段可获取到vm.el</span><br><span class="line">		此阶段vm.el虽已完成DOM初始化，但并未挂载在el选项上</span><br><span class="line"></span><br><span class="line">beforeMount -&gt; mounted:</span><br><span class="line">	此阶段vm.el完成挂载，vm.$el生成的DOM替换了el选项所对应的DOM</span><br><span class="line">mounted:</span><br><span class="line"></span><br><span class="line">	vm.el已完成DOM的挂载与渲染，此刻打印vm.$el，发现之前的挂载点及内容已被替换成新的DOM</span><br><span class="line"></span><br><span class="line">beforeUpdate:</span><br><span class="line">		更新的数据必须是被渲染在模板上的（el、template、render之一）</span><br><span class="line">		此时view层还未更新</span><br><span class="line">		若在beforeUpdate中再次修改数据，不会再次触发更新方法</span><br><span class="line">updated:</span><br><span class="line">		完成view层的更新</span><br><span class="line">		若在updated中再次修改数据，会再次触发更新方法（beforeUpdate、updated）</span><br><span class="line">beforeDestroy:</span><br><span class="line">		实例被销毁前调用，此时实例属性与方法仍可访问</span><br><span class="line">destroyed:</span><br><span class="line">		完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器</span><br><span class="line">		并不能清除DOM，仅仅销毁实例</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-2-生命周期使用场景分析"><a href="#3-2-生命周期使用场景分析" class="headerlink" title="3.2 生命周期使用场景分析"></a>3.2 生命周期使用场景分析</h4><p><img src="/2022/07/13/newInterView/v.png"></p>
<h4 id="4-computed-和-watch？"><a href="#4-computed-和-watch？" class="headerlink" title="4. computed 和 watch？"></a>4. computed 和 watch？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   1. computed：依赖数据发生改变,才会重新进行计算</span><br><span class="line">2. computed不支持异步 ，内有异步操作时无效，无法监听数据的变化;而watch支持异步。</span><br><span class="line">3. computed 中 必须 return watch则不是必须</span><br><span class="line">4. computed：默认第一次加载的时候就开始监听；</span><br><span class="line">	watch：watch默认第一次加载不做监听，如果需要第一次加载做监听，</span><br><span class="line">	添加immediate属性，设置为true（immediate:true）</span><br><span class="line">5. 使用场景：</span><br><span class="line">	computed----当一个属性受多个属性影响的时候，使用computed-----购物车商品结算</span><br><span class="line">	watch–当一条数据影响多条数据的时候，使用watch-----搜索框.</span><br></pre></td></tr></table></figure>
<h4 id="中宏立达-7-14"><a href="#中宏立达-7-14" class="headerlink" title="中宏立达(7.14)"></a>中宏立达(7.14)</h4><h3 id="1-有一只蚂蚁掉进一口深30米的井口-它每天往上爬3米-然后滑下2米-请问这只蚂蚁需要多少天才能爬出这口井？"><a href="#1-有一只蚂蚁掉进一口深30米的井口-它每天往上爬3米-然后滑下2米-请问这只蚂蚁需要多少天才能爬出这口井？" class="headerlink" title="1.有一只蚂蚁掉进一口深30米的井口,它每天往上爬3米,然后滑下2米,请问这只蚂蚁需要多少天才能爬出这口井？"></a>1.有一只蚂蚁掉进一口深30米的井口,它每天往上爬3米,然后滑下2米,请问这只蚂蚁需要多少天才能爬出这口井？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">每天上<span class="number">3</span>下<span class="number">2</span>，则每天实际向上爬了<span class="number">1</span>米，</span><br><span class="line">第<span class="number">27</span>天时爬至距离井口<span class="number">3</span>米处，第<span class="number">28</span>天就能一口气爬完剩余<span class="number">3</span>米，</span><br><span class="line">已经到了地面，不必下滑。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-用十三根火彩拼为-6-个-矩形，现在取走一根，把剩下的火彩拼为-六个等边三角形"><a href="#2-用十三根火彩拼为-6-个-矩形，现在取走一根，把剩下的火彩拼为-六个等边三角形" class="headerlink" title="2. 用十三根火彩拼为 6 个 矩形，现在取走一根，把剩下的火彩拼为 六个等边三角形"></a>2. 用十三根火彩拼为 6 个 矩形，现在取走一根，把剩下的火彩拼为 六个等边三角形</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">先用<span class="number">10</span>根拼成三个连在一起的正方形</span><br><span class="line">再在每个正方形里面用<span class="number">1</span>根将其一分为二就行了</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-如果很多页面都有类似的视图-怎么办？"><a href="#3-如果很多页面都有类似的视图-怎么办？" class="headerlink" title="3. 如果很多页面都有类似的视图,怎么办？"></a>3. 如果很多页面都有类似的视图,怎么办？</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slot</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-子组件的数据很多，怎么传递？"><a href="#4-子组件的数据很多，怎么传递？" class="headerlink" title="4. 子组件的数据很多，怎么传递？"></a>4. 子组件的数据很多，怎么传递？</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/az44yao/article/details/118642288">原网址</a></p>
<h4 id="5-vue-ref-作用？参考"><a href="#5-vue-ref-作用？参考" class="headerlink" title="5. vue ref 作用？参考"></a>5. vue ref 作用？<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangmeixia969/article/details/109777146">参考</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">使用ref获取页面DOM元素</span><br><span class="line">使用 ref获取子组件对象</span><br><span class="line">		</span><br><span class="line">在组件中：</span><br><span class="line">&lt;VueBook :bookName=&quot;name&quot; ref=&quot;vuebook&quot;&gt;&lt;/VueBook&gt;</span><br><span class="line"></span><br><span class="line">使用的时候：</span><br><span class="line"></span><br><span class="line">// 获取组件 VueBook 实例</span><br><span class="line">this.$refs.vuebook.$props;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6-路由传参？"><a href="#6-路由传参？" class="headerlink" title="6.路由传参？"></a>6.路由传参？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Params:</span><br><span class="line">	只能使用name，不能使用path</span><br><span class="line">	参数不会显示在路径上</span><br><span class="line">	浏览器强制刷新参数会被清空，</span><br><span class="line"></span><br><span class="line">// 传递参数</span><br><span class="line">  this.$router.push(&#123;</span><br><span class="line">    name: Home，</span><br><span class="line">    params: &#123;</span><br><span class="line">    	number: 1 ,</span><br><span class="line">    	code: &#x27;999&#x27;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  // 接收参数</span><br><span class="line">  const p = this.$route.params</span><br><span class="line">  </span><br><span class="line">Query:</span><br><span class="line">  参数会显示在路径上，刷新不会被清空</span><br><span class="line">  name 可以使用path路径</span><br><span class="line">  </span><br><span class="line">  // 传递参数</span><br><span class="line">  this.$router.push(&#123;</span><br><span class="line">    name: Home，</span><br><span class="line">    query: &#123;</span><br><span class="line">    number: 1 ,</span><br><span class="line">    code: &#x27;999&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  // 接收参数</span><br><span class="line">  const q = this.$route.query</span><br></pre></td></tr></table></figure>
<h3 id="7-获取路由参数的方式？来源"><a href="#7-获取路由参数的方式？来源" class="headerlink" title="7. 获取路由参数的方式？来源"></a>7. 获取路由参数的方式？<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47013351/article/details/124224089">来源</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$route.params.xxx</span><br><span class="line">this.$route.query.xxx</span><br></pre></td></tr></table></figure>
<h3 id="8-权限管理"><a href="#8-权限管理" class="headerlink" title="8. 权限管理"></a>8. 权限管理</h3><h4 id="路由权限"><a href="#路由权限" class="headerlink" title="路由权限"></a><a target="_blank" rel="noopener" href="https://github1s.com/PanJiaChen/vue-element-admin/blob/HEAD/src/permission.js#L13-L14">路由权限</a></h4><h4 id="路由生成"><a href="#路由生成" class="headerlink" title="路由生成"></a><a target="_blank" rel="noopener" href="https://github1s.com/PanJiaChen/vue-element-admin/blob/HEAD/src/store/modules/permission.js#L50-L51">路由生成</a></h4><h4 id="动态追加路由"><a href="#动态追加路由" class="headerlink" title="动态追加路由"></a><a target="_blank" rel="noopener" href="https://github1s.com/PanJiaChen/vue-element-admin/blob/HEAD/src/permission.js#L43-L44">动态追加路由</a></h4><h3 id="8-把-vue2-转换为-vue3"><a href="#8-把-vue2-转换为-vue3" class="headerlink" title="8. 把 vue2 转换为 vue3"></a>8. 把 vue2 转换为 vue3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue add vue-next</span><br></pre></td></tr></table></figure>
<h3 id="9-vue2-和-vue3-中-v-model-的区别？"><a href="#9-vue2-和-vue3-中-v-model-的区别？" class="headerlink" title="9. vue2 和 vue3 中 v-model 的区别？"></a>9. vue2 和 vue3 中 v-model 的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vue2 中 input 中 v-model 只能有一个</span><br><span class="line"></span><br><span class="line">vue3 中 v-model 可以有多个</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="10-css-选择器的权重问题"><a href="#10-css-选择器的权重问题" class="headerlink" title="10. css 选择器的权重问题"></a>10. css 选择器的权重问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!important -&gt; 行内样式 -&gt; id 选择 -&gt;类选择器、伪类选择器 -&gt;元素选择器 -&gt;继承或者*</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="11-css-中-link-和-import的-区别？"><a href="#11-css-中-link-和-import的-区别？" class="headerlink" title="11. css 中 link 和 import的 区别？"></a>11. css 中 link 和 import的 区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、link是HTML标签，除了加载CSS外，还可定义RSS等其他事务	</span><br><span class="line">@import属于CSS范畴，只能加载CSS。2、link引用CSS时，</span><br><span class="line">在页面载入时同时加载；@import需要页面网页完全载入以后加载。</span><br><span class="line">3、link无兼容问题。</span><br></pre></td></tr></table></figure>
<h3 id="12-浏览器渲染过程？"><a href="#12-浏览器渲染过程？" class="headerlink" title="12. 浏览器渲染过程？"></a>12. 浏览器渲染过程？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 1. 解析 html 标签生成 dom 树</span><br><span class="line"> 2. 解析 css 生成cssOM树</span><br><span class="line"> 3. 合并 dom 树和 css规则树生成render渲染树，</span><br><span class="line">	渲染树只会包括需要显示的节点和这些节点的样式信息，</span><br><span class="line">	如果某个节点的样式设置为 display:none，</span><br><span class="line">	它就不会构建到render 渲染树中。</span><br><span class="line">	</span><br><span class="line">面试：如果dom 树上有十个节点，那么render渲染树上就有十个节点嘛？</span><br><span class="line">答：不一定，因为渲染树render树只会包括要渲染的节点和它的样式，</span><br><span class="line">如果节点中某个或者多个节点样式为 display：none，那么就不会构建到dom</span><br><span class="line">树上。</span><br></pre></td></tr></table></figure>
<h3 id="13-render渲染树的重绘-和-回流"><a href="#13-render渲染树的重绘-和-回流" class="headerlink" title="13. render渲染树的重绘 和 回流"></a>13. render渲染树的重绘 和 回流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">回流：改变高度，宽度，内外边距等，相当于刷新页面这么一个操作，</span><br><span class="line">重回：当元素的属性发生改变，但是不影响布局的时候，比如：</span><br><span class="line">改变背景颜色、透明度、字体的样式等，就会产生重回。相当于不刷新页面</span><br><span class="line">动态的更新内容。</span><br><span class="line">tip：</span><br><span class="line">重回不一定引起回流，但是回流一定会引起重回。在开发过程中，为了</span><br><span class="line">提高性能，都尽量减少重回回流。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="14-组件化-和-模块化的区别？"><a href="#14-组件化-和-模块化的区别？" class="headerlink" title="14. 组件化 和 模块化的区别？"></a>14. 组件化 和 模块化的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">组件化：ui界面的角度来划分的，</span><br><span class="line">	页面上每个独立的区域都可以看作是一个组件化。</span><br><span class="line">	作用：组件化开发能够以便于组件的复用，减少编码量</span><br><span class="line">	</span><br><span class="line">模块化：是从代码逻辑的角度来划分的。保证每个模块的职能单一</span><br><span class="line">，比如登录页的登录功能就是一个模块，注册功能又算是一个模块。</span><br></pre></td></tr></table></figure>
<h4 id="15-为什么token要同时存在vuex-和localStorage中？"><a href="#15-为什么token要同时存在vuex-和localStorage中？" class="headerlink" title="15. 为什么token要同时存在vuex 和localStorage中？"></a>15. 为什么token要同时存在vuex 和localStorage中？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vuex: 存储数据的特点是数据统一，一旦数据在某个组件内更新，</span><br><span class="line">其他组件的数据也会更新。也就是说它是响应式的，但是如果数据</span><br><span class="line">只存储在vuex中，刷新页面的时候，vuex里面的数据会重新</span><br><span class="line">开始初始化，导致数据丢失，恢复到原来的状态。</span><br><span class="line">localStorage：存储数据的特点是 永久存储，除非手动的去删除。</span><br><span class="line">但是·它不是响应式的。当某个组件数据修改的时候，其他组件</span><br><span class="line">无法同步更新。</span><br><span class="line"></span><br><span class="line">vuex 是存储在内存中的，而localStorage是本地存储的，是存储到</span><br><span class="line">磁盘里的，从内存中读取数据的速度是远远高于磁盘中的。所以把</span><br><span class="line">token存储在vuex 中可以提高获取token 的速度。从而提高性能。</span><br><span class="line">通常在实际开发中都是结合这两种使用的。拿到token后把token存储到</span><br><span class="line">localStorage 和vuex中，实现数据课持久化。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="16-说说登录流程？"><a href="#16-说说登录流程？" class="headerlink" title="16. 说说登录流程？"></a>16. 说说登录流程？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 在登录页点击登录的时候，前端会带着用户和密码去调用后端接口。</span><br><span class="line">2. 后端收到请求后，会验证用户和密码，如果验证失败，会返回相关</span><br><span class="line">的错误信息，前端提示相应的错误信息；如果验证成功就会给前端</span><br><span class="line">返回一个 token值</span><br><span class="line">3. 前端拿到token值之后，将这个token存储到vuex 和 localStorage中</span><br><span class="line">并跳转页面即登录成功，</span><br><span class="line">4. 前端每一次跳转到需要具备登录状态的页面的时候，都需要判断当前</span><br><span class="line">token 值是否存在，如果不存在就跳转到登录页面，存在就正常跳转，</span><br><span class="line">通常我们会把这个封装的路由守卫中，再向后端发送其他请求的时候，</span><br><span class="line">我们一般需要在请求头中带上这个token值，在项目中我们通常</span><br><span class="line">是把它封装在一个请求拦截器中，后端判断请求头中有无token，有的话</span><br><span class="line">就验证该token，验证成功的话会正常的返回数据，验证失败，比如过期</span><br><span class="line">，就会返回相应的错误代码，前端拿到错误信息后清除token，并再回退到</span><br><span class="line">登录页面</span><br></pre></td></tr></table></figure>
<h3 id="17-父组件监听子组件的生命周期？"><a href="#17-父组件监听子组件的生命周期？" class="headerlink" title="17. 父组件监听子组件的生命周期？"></a>17. 父组件监听子组件的生命周期？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">一、通过 $emit 实现</span><br><span class="line">		这里以 mounted 为例，在父组件 <span class="title class_">Parent</span> 和子组件 <span class="title class_">Child</span> 中，</span><br><span class="line">		如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，</span><br><span class="line">		可以通过以下写法实现：</span><br><span class="line">		<span class="comment">// 父组件 Parent.vue中</span></span><br><span class="line">		&lt;<span class="title class_">Child</span> @mounted=<span class="string">&quot;doSomething&quot;</span>/&gt;</span><br><span class="line">		    </span><br><span class="line">		<span class="comment">// 子组件 Child.vue中</span></span><br><span class="line">		<span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">		  <span class="variable language_">this</span>.$emit(<span class="string">&quot;mounted&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">以上方法虽然可行，但每次都需要手动写一次 $emit 触发父组件的事件。</span><br><span class="line">更简单的方式可以在父组件引用子组件时通过 @hook 来监听生命周期。</span><br><span class="line"></span><br><span class="line">二、通过 @hook 实现</span><br><span class="line"></span><br><span class="line">	还是父组件 <span class="title class_">Parent</span> 和子组件 <span class="title class_">Child</span>，@hook 的写法如下：</span><br><span class="line">	<span class="comment">//  Parent.vue</span></span><br><span class="line">	&lt;<span class="title class_">Child</span> @<span class="attr">hook</span>:mounted=<span class="string">&quot;doSomething&quot;</span> &gt;&lt;/<span class="title class_">Child</span>&gt;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">	   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;父组件监听到 mounted 钩子函数 ...&#x27;</span>);</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  Child.vue</span></span><br><span class="line">	<span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">	   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子组件触发 mounted 钩子函数 ...&#x27;</span>);</span><br><span class="line">	&#125;,    </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以上输出顺序为：</span></span><br><span class="line">	<span class="comment">// 子组件触发 mounted 钩子函数 ...</span></span><br><span class="line">	<span class="comment">// 父组件监听到 mounted 钩子函数 ...     </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="18-普通函数和-箭头函数中的this"><a href="#18-普通函数和-箭头函数中的this" class="headerlink" title="18. 普通函数和 箭头函数中的this"></a>18. 普通函数和 箭头函数中的this</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&#x27;app&#x27;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 1. 普通函数中的 this</span><br><span class="line">    // 1. 谁调用了函数或者方法，</span><br><span class="line">    // 那么这个函数或者对象中的this就指向谁</span><br><span class="line"></span><br><span class="line">    // let getThis = function () &#123;</span><br><span class="line">    //     console.log(this);</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    // let obj = &#123;</span><br><span class="line">    //     name: &#x27;Jack&#x27;,</span><br><span class="line">    //     getThis: function () &#123;</span><br><span class="line">    //         console.log(this);</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;</span><br><span class="line">    // getThis()</span><br><span class="line">    // //getThis()方法是由window在全局作用域中调用的，所以this指向调用该方法的对象，即window</span><br><span class="line">    // getThis()//window</span><br><span class="line">    // obj.getThis() //obj</span><br><span class="line"></span><br><span class="line">    // 匿名函数中的this：匿名函数的执行具有全局性</span><br><span class="line">    // 则匿名函数中的this指向的是window，而不是调用该匿名函数的对象</span><br><span class="line"></span><br><span class="line">    // let obj1 = &#123;</span><br><span class="line">    //     getThis1: function () &#123;</span><br><span class="line"></span><br><span class="line">    //         return function () &#123;</span><br><span class="line">    //             console.log(this);</span><br><span class="line">    //         &#125;</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;</span><br><span class="line">    // obj1.getThis1()() // window</span><br><span class="line">    /*</span><br><span class="line">     上面代码中，getThis() 方法是由obj调用，但是obj.getThis()</span><br><span class="line">     返回的是一个匿名函数，而匿名函数中的this指向window。如果想在</span><br><span class="line">     上述代码中使用this指向搞方法的对象，可以把this传值给另外一个变量</span><br><span class="line">     (_this 或 that)</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    </span><br><span class="line">   1. 箭头函数中的 this</span><br><span class="line">     1.1 箭头函数中的this是在函数定义的时候定义下来的，</span><br><span class="line">     而不是在函数调用的时候确定的</span><br><span class="line">     1.2 箭头函数中的this 指向父级作用域的执行上下文</span><br><span class="line">     (技巧：因为 javascript 中除了全局作用域，其他的作用域都是由</span><br><span class="line">     函数创建出来的，所以如果想确定this指向，则找到里箭头函数最近的</span><br><span class="line">     function，与function平级的执行上下文中的this即是箭头函数中的this</span><br><span class="line">     )</span><br><span class="line">     1.3 箭头函数无法使用apply、call和bind方法改变this，因为其this</span><br><span class="line">     值在函数定义的时候就被确定下来。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    // let obj = &#123;</span><br><span class="line">    //     getThis: function () &#123;</span><br><span class="line">    //         return () =&gt; &#123;</span><br><span class="line">    //             console.log(this)</span><br><span class="line">    //         &#125;</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;</span><br><span class="line">    // obj.getThis()()  // obj</span><br><span class="line"></span><br><span class="line">    // 列2:该段代码中存在2两个箭头函数，</span><br><span class="line">    // this找不到对应的function()&#123;&#125;,所以一直往上照到指向window</span><br><span class="line">    let obj = &#123;</span><br><span class="line">        getThis: () =&gt; &#123;</span><br><span class="line">            return () =&gt; &#123;</span><br><span class="line">                console.log(this)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    obj.getThis()();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="19-防抖节流"><a href="#19-防抖节流" class="headerlink" title="19.防抖节流"></a>19.防抖节流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body style=&quot;height: 2000px;&quot;&gt;</span><br><span class="line">    &lt;div id=&#x27;app&#x27;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;input type=&quot;text&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    var input = document.querySelector(&#x27;input&#x27;)</span><br><span class="line"></span><br><span class="line">    input.oninput = debounce(function () &#123;</span><br><span class="line"></span><br><span class="line">        // console.log(e.value);</span><br><span class="line">        console.log(this.value);</span><br><span class="line">    &#125;, 200)</span><br><span class="line">    // 防抖: 用户触发事件过于频繁，只要最后一次事件的操作</span><br><span class="line">    // 防抖 是只执行最后一次</span><br><span class="line"></span><br><span class="line">    function debounce(fn, delay) &#123;</span><br><span class="line">        let t = null</span><br><span class="line">        return function () &#123;</span><br><span class="line">            // 内部函数使用外部函数的变量</span><br><span class="line">            if (t !== null) &#123;</span><br><span class="line">                clearTimeout(t)</span><br><span class="line">            &#125;</span><br><span class="line">            t = setTimeout(() =&gt; &#123;</span><br><span class="line">                // console.log(this);</span><br><span class="line">                fn.call(this)</span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 节流</span><br><span class="line">    //  控制执行次数</span><br><span class="line">    // 节流的作用：控制高评率时间执行次数</span><br><span class="line"></span><br><span class="line">    window.onscroll = throttle(function () &#123;</span><br><span class="line">        console.log(&#x27;hellow&#x27;);</span><br><span class="line">    &#125;, 500)</span><br><span class="line"></span><br><span class="line">    function throttle(fn, delay) &#123;</span><br><span class="line">        let flag = true</span><br><span class="line">        return function (   ) &#123;</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                setTimeout(() =&gt; &#123;</span><br><span class="line">                    fn.call(this)</span><br><span class="line">                    flag = true</span><br><span class="line">                &#125;, delay)</span><br><span class="line">            &#125;</span><br><span class="line">            flag = false</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="20-项目优化"><a href="#20-项目优化" class="headerlink" title="20 .项目优化"></a>20 .项目优化</h3><h4 id="项目优化分为三部分"><a href="#项目优化分为三部分" class="headerlink" title="项目优化分为三部分"></a>项目优化分为三部分</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">1. v-for 遍历为 item 添加key</span><br><span class="line">在列表数据进行遍历渲染时，需要为每一项item设置唯一 key值，</span><br><span class="line">方便vue.js 机制精准找到该列表数据</span><br><span class="line"></span><br><span class="line">2. v-for  遍历避免同时使用 v-if</span><br><span class="line">v-for 比 v-if 优先级高，</span><br><span class="line"></span><br><span class="line">3. v-if 和 v-show 分场景使用</span><br><span class="line">4. computed 和 watch 分场景使用</span><br><span class="line">5. keep-alive</span><br><span class="line">	利用keep-alive 包裹，将不活动的组件缓存起来</span><br><span class="line">	在组件切换过程中奖状态保留在内存中，防止重复渲染 dom</span><br><span class="line">	，减少加载时间及性能消耗，提高用户体验</span><br><span class="line">6. 图片懒加载(使用插件) Vue 的 vue-lazyload 插件。</span><br><span class="line">7. 路由懒加载:</span><br><span class="line"></span><br><span class="line">		路由过多，加载的资源过多，页面会出现白屏的情况，不利于用户体验。</span><br><span class="line">		所以我们把不同路由对应的组件分割成不同的代码块，</span><br><span class="line">		然后当路由被访问的时候才加载对应的组件：</span><br><span class="line"></span><br><span class="line">		在 vue-router 配置路由的时候，采用动态加载路由的形式：</span><br><span class="line">		routes:[ </span><br><span class="line">			path: &#x27;Blogs&#x27;,</span><br><span class="line">			name: &#x27;ShowBlogs&#x27;,</span><br><span class="line">			component: () =&gt; import(&#x27;./components/ShowBlogs.vue&#x27;)</span><br><span class="line">		]</span><br><span class="line"></span><br><span class="line">		以这种函数的形式加载路由，这样就可以把各自的路由文件分别打包，</span><br><span class="line">		只有在解析给定的路由时，才会加载路由组件。</span><br><span class="line">8. 第三方库按需引入：</span><br><span class="line"></span><br><span class="line">		在日常使用UI框架，例如element-UI、iView，</span><br><span class="line">		我们经常性直接引用整个UI库。但实际上我用到的组件只有按钮，</span><br><span class="line">		分页，表格等很少一部分，所以我们要按需引用：</span><br><span class="line"></span><br><span class="line">二、Webpack 层面的优化</span><br><span class="line">		1 Webpack 对图片进行压缩</span><br><span class="line">		对有些较大的图片资源，在请求资源的时候，加载会很慢，</span><br><span class="line">		我们可以用 image-webpack-loader 来压缩图片</span><br><span class="line"></span><br><span class="line">		2 模板预编译</span><br><span class="line">		打包时，直接把组件中的模板转换为render函数，这叫做模板预编译。</span><br><span class="line">		这样一来，运行时就不再需要编译模板了，提高了运行效率</span><br><span class="line"></span><br><span class="line">三、基础的 Web 技术优化</span><br><span class="line">		1 浏览器缓存</span><br><span class="line">		为了提高用户加载页面的速度，对静态资源进行缓存是非常必要的。</span><br></pre></td></tr></table></figure>
<h3 id="21-已知一个高度和宽度确定的父元素里面有一个宽度和高度不确定的子元素"><a href="#21-已知一个高度和宽度确定的父元素里面有一个宽度和高度不确定的子元素" class="headerlink" title="21. 已知一个高度和宽度确定的父元素里面有一个宽度和高度不确定的子元素,"></a>21. 已知一个高度和宽度确定的父元素里面有一个宽度和高度不确定的子元素,</h3><h3 id="子元素内容长度的由后端数据来决定-内容长度不定-怎么让子元素相对父元素垂直"><a href="#子元素内容长度的由后端数据来决定-内容长度不定-怎么让子元素相对父元素垂直" class="headerlink" title="子元素内容长度的由后端数据来决定(内容长度不定),怎么让子元素相对父元素垂直"></a>子元素内容长度的由后端数据来决定(内容长度不定),怎么让子元素相对父元素垂直</h3><h3 id="水平就居中？"><a href="#水平就居中？" class="headerlink" title="水平就居中？"></a>水平就居中？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">			#outer&#123;</span><br><span class="line">				position: relative;</span><br><span class="line">				overflow: hidden;</span><br><span class="line">			&#125;</span><br><span class="line">			#inBox&#123;</span><br><span class="line">				position: absolute;</span><br><span class="line">				left: 50%;</span><br><span class="line">				top: 50%;</span><br><span class="line">				transform: translate(-50%,-50%);</span><br><span class="line">			&#125;</span><br><span class="line">		&lt;/style&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&lt;div id=&quot;outer&quot; style=&quot; width: 400px;height: 400px; border: 1px solid red; text-align: center; margin: 100px auto;&quot;&gt;</span><br><span class="line">		&lt;div id=&quot;inBox&quot; style=&quot; border: 1px solid red;&quot;&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;script&gt;</span><br><span class="line">		let M=Math.floor(Math.random()*6 +2)</span><br><span class="line">		let  list= new Array(M).fill(`&lt;span style=&quot;text-align: center;width: auto; margin: 10px;&quot;&gt;$&#123;(Math.random()*9).toFixed()&#125;&lt;/span&gt;`)</span><br><span class="line">		var inbox= document.querySelector(&#x27;#inBox&#x27;);</span><br><span class="line">		list.forEach((item)=&gt;&#123;</span><br><span class="line">			inbox.innerHTML +=item</span><br><span class="line">		&#125;)	</span><br><span class="line">	      /* 面试 ： 假设 inBox 没有宽高，而 里面的内容是通过后端数据请求来的，</span><br><span class="line">	          也就是里面的内容长度是不确定的。怎么能让其相对父元素垂直水平居中？</span><br><span class="line">			  </span><br><span class="line">			  答：</span><br><span class="line">			  父： position: relative;</span><br><span class="line">			  </span><br><span class="line">			  子：#inBox&#123;</span><br><span class="line">				position: absolute;</span><br><span class="line">				left: 50%;</span><br><span class="line">				top: 50%;</span><br><span class="line">				transform: translate(-50%,-50%);</span><br><span class="line">			    &#125;</span><br><span class="line">			  */</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-vue-cli到底做了哪些事"><a href="#2-vue-cli到底做了哪些事" class="headerlink" title="2.vue-cli到底做了哪些事"></a>2.vue-cli到底做了哪些事</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. ES6代码转换成ES5代码 2. scss/sass/less/stylus转css 3. vue文件转换成js文件 </span><br><span class="line">4. 使用 jpg、png，font等资源文件 5. 自动添加css各浏览器产商的前缀 </span><br><span class="line">6. 代码热更新 7. 资源预加载 8. 每次构建代码清除之前生成的代码 </span><br><span class="line">9. 定义环境变量 10. 区分开发环境打包跟生产环境打包</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="22-为什么-vue要-异步渲染？-四久八网络科技"><a href="#22-为什么-vue要-异步渲染？-四久八网络科技" class="headerlink" title="22. 为什么 vue要 异步渲染？(四久八网络科技)"></a>22. 为什么 vue要 异步渲染？(四久八网络科技)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当数据变化后会调用notify方法，将watcher遍历，调用update方法通知watcher进行更新，</span><br><span class="line">这时候watcher并不会立即去执行，在update中会调用queueWatcher方法将watcher放到了一个队列里，</span><br><span class="line">在queueWatcher会根据watcher的进行去重，多个属性依赖一个watcher，</span><br><span class="line">如果队列中没有该watcher就会将该watcher添加到队列中，</span><br><span class="line">然后通过nextTick异步执行flushSchedulerQueue方法刷新watcher队列。</span><br><span class="line">flushSchedulerQueue中开始会触发一个before的方法，</span><br><span class="line">其实就是beforeUpdate，然后watcher.run() 才开始真正执行watcher，</span><br><span class="line">执行完页面就渲染完成啦，更新完成后会调用updated钩子。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="23-vue虚拟dom的产生过程？-四久八网络科技"><a href="#23-vue虚拟dom的产生过程？-四久八网络科技" class="headerlink" title="23. vue虚拟dom的产生过程？(四久八网络科技)"></a>23. vue虚拟dom的产生过程？(四久八网络科技)</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yiyueqinghui/article/details/108768254">https://blog.csdn.net/yiyueqinghui/article/details/108768254</a></p>
<h3 id="24-vue2中只能有一个根标签，但是在vue3中根组件已经可以有多个根节点了？-四久八网络科技"><a href="#24-vue2中只能有一个根标签，但是在vue3中根组件已经可以有多个根节点了？-四久八网络科技" class="headerlink" title="24. vue2中只能有一个根标签，但是在vue3中根组件已经可以有多个根节点了？   (四久八网络科技)"></a>24. vue2中只能有一个根标签，但是在vue3中根组件已经可以有多个根节点了？   (四久八网络科技)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在vue2中只所以这么做是因为vdom是一颗单根树形结构，patch方法在遍历的时候从根节点开始遍历，</span><br><span class="line">它要求只有一个根节点，组件也会转换为一个vdom,自然满足这个要求</span><br><span class="line"></span><br><span class="line">vue3中值所以可以有多个节点，是因为引入了Fragment的概念，这是一个抽象的节点，如果发现组件有多个根，</span><br><span class="line">就创建一个Fragment节点，把多个根节点作为它的children,将来path的时候，如果发现是一个Fragement节点，</span><br><span class="line">则直接遍历children创建或更新。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="24-vue2-和-vue3-的区别？-附加"><a href="#24-vue2-和-vue3-的区别？-附加" class="headerlink" title="24. vue2 和 vue3 的区别？(附加)"></a>24. vue2 和 vue3 的区别？(附加)</h3><h3 id="https-blog-csdn-net-weixin-54722719-article-details-123069837"><a href="#https-blog-csdn-net-weixin-54722719-article-details-123069837" class="headerlink" title="https://blog.csdn.net/weixin_54722719/article/details/123069837"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_54722719/article/details/123069837">https://blog.csdn.net/weixin_54722719/article/details/123069837</a></h3><h3 id="25-webpack-做什么优化？"><a href="#25-webpack-做什么优化？" class="headerlink" title="25. webpack 做什么优化？"></a>25. webpack 做什么优化？</h3><h3 id="https-blog-csdn-net-lb6514052-article-details-124145599"><a href="#https-blog-csdn-net-lb6514052-article-details-124145599" class="headerlink" title="https://blog.csdn.net/lb6514052/article/details/124145599"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/lb6514052/article/details/124145599">https://blog.csdn.net/lb6514052/article/details/124145599</a></h3><h3 id="vue2-怎么源码怎么监听数组的？"><a href="#vue2-怎么源码怎么监听数组的？" class="headerlink" title="vue2 怎么源码怎么监听数组的？"></a>vue2 怎么源码怎么监听数组的？</h3><h3 id="https-www-cnblogs-com-cuteyuchen-p-16440521-html"><a href="#https-www-cnblogs-com-cuteyuchen-p-16440521-html" class="headerlink" title="https://www.cnblogs.com/cuteyuchen/p/16440521.html"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cuteyuchen/p/16440521.html">https://www.cnblogs.com/cuteyuchen/p/16440521.html</a></h3><h4 id="26-ES6-中-Set-Map？（公司实战面试）来源网址"><a href="#26-ES6-中-Set-Map？（公司实战面试）来源网址" class="headerlink" title="26. ES6 中 Set Map？（公司实战面试）来源网址"></a>26. ES6 中 Set Map？（公司实战面试）<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43359799/article/details/123131917">来源网址</a></h4><h4 id="相关知识点：-1"><a href="#相关知识点：-1" class="headerlink" title="相关知识点："></a>相关知识点：</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set 和 Map主要的运用场景再看于 数据重构和数据存储</span><br><span class="line">Set 是一种叫做集合的数据结构，Map是一种叫做字典的数据结构</span><br></pre></td></tr></table></figure>
<h2 id="27-css-样式锁？-https-blog-csdn-net-weixin-42140625-article-details-119369451"><a href="#27-css-样式锁？-https-blog-csdn-net-weixin-42140625-article-details-119369451" class="headerlink" title="27. css 样式锁？(https://blog.csdn.net/weixin_42140625/article/details/119369451)"></a>27. css 样式锁？(<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42140625/article/details/119369451">https://blog.csdn.net/weixin_42140625/article/details/119369451</a>)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 1. minf: 最小font-size</span><br><span class="line">* 2. maxf: 最大font-size</span><br><span class="line">* 3. minw: 视窗最小宽度</span><br><span class="line">* 4. maxw: 视窗最大宽度</span><br><span class="line">*/</span><br><span class="line">font-size: calc([minf]px + ([maxf] - [minf]) * ( (100vw - [minw]px) / ([maxw] - [minw]) ));</span><br><span class="line">@media only screen and (max-width: [minw]px) &#123; font-size: [minf]px; &#125;;</span><br><span class="line">@media only screen and (min-width: [maxw]px) &#123; font-size: [maxf]px; &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="28-原生小程序打包为app的时候-字面解决video-的层级问题？"><a href="#28-原生小程序打包为app的时候-字面解决video-的层级问题？" class="headerlink" title="28. 原生小程序打包为app的时候,字面解决video 的层级问题？"></a>28. 原生小程序打包为app的时候,字面解决video 的层级问题？</h2><pre><code>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（https://blog.csdn.net/weixin_43873198/article/details/122526120）</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="29-nodejs-有哪些全局变量？-https-www-php-cn-js-tutorial-484679-html"><a href="#29-nodejs-有哪些全局变量？-https-www-php-cn-js-tutorial-484679-html" class="headerlink" title="29. nodejs 有哪些全局变量？(https://www.php.cn/js-tutorial-484679.html)"></a>29. nodejs 有哪些全局变量？(<a target="_blank" rel="noopener" href="https://www.php.cn/js-tutorial-484679.html">https://www.php.cn/js-tutorial-484679.html</a>)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）__filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，</span><br><span class="line">  且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。</span><br><span class="line"></span><br><span class="line">2）_dirname：指向当前运行的脚本所在的目录。</span><br></pre></td></tr></table></figure>
<h2 id="30-keep-alive-生命周期？"><a href="#30-keep-alive-生命周期？" class="headerlink" title="30. keep-alive 生命周期？"></a>30. keep-alive 生命周期？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">keep-alive：主要用于保留组件状态或避免重新渲染。</span><br><span class="line">包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。</span><br><span class="line"></span><br><span class="line">当组件在 keep-alive内被切换，它的 activated 和 deactivated </span><br><span class="line">这两个生命周期钩子函数将会被对应执行。</span><br><span class="line"></span><br><span class="line">1.activated：页面第一次进入的时候，钩子触发的顺序是created-&gt;mounted-&gt;activated</span><br><span class="line">2.deactivated ：页面退出的时候会触发deactivated，当再次前进或者后退的时候只触发activated</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="31-vue-中nextTick-https-blog-csdn-net-qq-54527592-article-details-119548787"><a href="#31-vue-中nextTick-https-blog-csdn-net-qq-54527592-article-details-119548787" class="headerlink" title="31. vue 中nextTick ?(https://blog.csdn.net/qq_54527592/article/details/119548787)"></a>31. vue 中nextTick ?(<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54527592/article/details/119548787">https://blog.csdn.net/qq_54527592/article/details/119548787</a>)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">语法：this.$nextTick(回调函数)</span><br><span class="line">作用：在下一次 DOM 更新结束后执行其指定的回调。</span><br><span class="line">什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</span><br><span class="line">methods: &#123;</span><br><span class="line">    show() &#123;</span><br><span class="line">      this.isShow = true</span><br><span class="line">      /* 我们在这里直接写获取焦点是获取不到的  因为在Vue中是要等函数执行完了在更新页面的 </span><br><span class="line">	   我们在函数内部使用了获取焦点事件此时页面还没有更新</span><br><span class="line">	   input框还没有显示 所以我们需要使用官方提供的API $nextTick()</span><br><span class="line">       this.$refs.textInput.focus()</span><br><span class="line">	   */</span><br><span class="line"> </span><br><span class="line">      // 这个时候就可以实现效果了</span><br><span class="line">      this.$nextTick(function () &#123;</span><br><span class="line">        // 页面更新后调用</span><br><span class="line">        this.$refs.textInput.focus()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="32-浏览器的渲染机制？"><a href="#32-浏览器的渲染机制？" class="headerlink" title="32.浏览器的渲染机制？"></a>32.浏览器的渲染机制？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 解析 html生成 Dom</span><br><span class="line">2. 解析css 生成 cssOM 树</span><br><span class="line">3. 合并dom树和 css规则树，生成render渲染树，渲染树</span><br><span class="line">   只会包括需要显示的节点和这些节点的样式信息，如果某个节点的</span><br><span class="line">   样式为 display：none，它就不会构建到render树中</span><br><span class="line">4. 根据render渲染树进行布局与绘制：</span><br><span class="line">   回流：高度宽度，内外边距等就会生回流</span><br><span class="line">   重回：样式背景</span><br></pre></td></tr></table></figure>
<h3 id="33-ajax-请求被拦截，怎么解决？-https-www-cnblogs-com-maochenhua-p-13370349-html"><a href="#33-ajax-请求被拦截，怎么解决？-https-www-cnblogs-com-maochenhua-p-13370349-html" class="headerlink" title="33. ajax 请求被拦截，怎么解决？(https://www.cnblogs.com/maochenhua/p/13370349.html)"></a>33. ajax 请求被拦截，怎么解决？(<a target="_blank" rel="noopener" href="https://www.cnblogs.com/maochenhua/p/13370349.html">https://www.cnblogs.com/maochenhua/p/13370349.html</a>)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方法一：ajax改成同步</span><br><span class="line">       缺点：会堵塞ui，比如ajax调之前，显示loading，loading是显示不出来的</span><br><span class="line">方法二：ajax调用前先弹窗（空地址），ajax之后，修改弹窗地址</span><br><span class="line">       缺点：ajax未返回前，窗口也存在。应用场景不广，比如ajax返回后需要调用第三方的方法，</span><br><span class="line">       第三方方法中会弹窗，这个就没法处理。</span><br><span class="line">方法三：设定1个定时器，在ajax的返回后，在定时器中弹窗</span><br><span class="line">       缺点：需要自行控制逻辑，容易漏场景</span><br></pre></td></tr></table></figure>
<h3 id="34-网络安全？-https-blog-csdn-net-qq-37288477-article-details-86601005"><a href="#34-网络安全？-https-blog-csdn-net-qq-37288477-article-details-86601005" class="headerlink" title="34. 网络安全？(https://blog.csdn.net/qq_37288477/article/details/86601005)"></a>34. 网络安全？(<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37288477/article/details/86601005">https://blog.csdn.net/qq_37288477/article/details/86601005</a>)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xss </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="35-websocket-https-baike-baidu-com-item-WebSocket-1953845-fr-aladdin"><a href="#35-websocket-https-baike-baidu-com-item-WebSocket-1953845-fr-aladdin" class="headerlink" title="35. websocket ?(https://baike.baidu.com/item/WebSocket/1953845?fr=aladdin)"></a>35. websocket ?(<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/WebSocket/1953845?fr=aladdin">https://baike.baidu.com/item/WebSocket/1953845?fr=aladdin</a>)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">MaxLi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/07/13/newInterView/">http://example.com/2022/07/13/newInterView/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/14/aboutSoveBockProblems/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">aboutSoveBockProblems</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/03/aboutLessAndSassAndCss/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">aboutLessAndSassAndCss</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MaxLi</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%8F%B8%E5%AE%9E%E6%88%98%E9%9D%A2%E8%AF%95"><span class="toc-number">1.</span> <span class="toc-text">公司实战面试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E6%96%87%E7%AB%A0%E4%BB%85%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8-%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0"><span class="toc-number">2.</span> <span class="toc-text">本文章仅个人学习使用(个人笔记)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-gt-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98%E3%80%82%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E9%87%8C%E9%9D%A2%E7%9A%84this%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%9C%89%E5%80%BC%EF%BC%9F%EF%BC%88%E5%85%AC%E5%8F%B8%E5%AE%9E%E6%88%98%E9%9D%A2%E8%AF%95%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">1. ()&#x3D;&gt; 箭头函数指向问题。箭头函数里面的this什么时候有值？（公司实战面试）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-vuex-%E4%BA%86%E8%A7%A3%EF%BC%9F%EF%BC%88%E5%85%AC%E5%8F%B8%E5%AE%9E%E6%88%98%E9%9D%A2%E8%AF%95%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">2. vuex 了解？（公司实战面试）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-vuex-%E5%B1%9E%E6%80%A7%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">2.1 vuex 属性：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-vuex%E4%B8%ADstate%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">2.2 vuex中state的特性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-vuex-%E4%B8%AD%E7%9A%84getter%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">2.3 vuex 中的getter特性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-vuex%E4%B8%ADmutation%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">2.4 vuex中mutation的特性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8vuex-%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">使用vuex 会带来什么问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-mutation-%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%82%E6%AD%A5%E7%9A%84%EF%BC%9F-%EF%BC%88%E5%85%AC%E5%8F%B8%E5%AE%9E%E6%88%98%E9%9D%A2%E8%AF%95%EF%BC%89"><span class="toc-number">2.8.</span> <span class="toc-text">3.mutation 是同步的函数异步的？ （公司实战面试）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-vue-%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%EF%BC%88%E5%85%AC%E5%8F%B8%E5%AE%9E%E6%88%98%E9%9D%A2%E8%AF%95%EF%BC%89"><span class="toc-number">2.9.</span> <span class="toc-text">4.vue 路由模式？为什么？怎么实现的？（公司实战面试）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-ES6-%E4%B8%AD-Set-Map%EF%BC%9F%EF%BC%88%E5%85%AC%E5%8F%B8%E5%AE%9E%E6%88%98%E9%9D%A2%E8%AF%95%EF%BC%89%E6%9D%A5%E6%BA%90%E7%BD%91%E5%9D%80"><span class="toc-number">2.10.</span> <span class="toc-text">5. ES6 中 Set Map？（公司实战面试）来源网址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A"><span class="toc-number">2.11.</span> <span class="toc-text">相关知识点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%92%8C%E5%AD%97%E5%85%B8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.12.</span> <span class="toc-text">集合和字典的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.13.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-let-var-const-%EF%BC%9F%EF%BC%88%E5%85%AC%E5%8F%B8%E5%AE%9E%E6%88%98%E9%9D%A2%E8%AF%95%EF%BC%89"><span class="toc-number">2.14.</span> <span class="toc-text">6.let var const ？（公司实战面试）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%BD%91%E5%9D%80"><span class="toc-number">2.15.</span> <span class="toc-text">原网址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-vue%E4%B8%AD%E5%81%9A%E4%BA%86%E9%82%A3%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F%EF%BC%88%E5%85%AC%E5%8F%B8%E5%AE%9E%E6%88%98%E9%9D%A2%E8%AF%95%EF%BC%89"><span class="toc-number">2.16.</span> <span class="toc-text">7. vue中做了那些优化？（公司实战面试）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%BD%91%E5%9D%80-1"><span class="toc-number">2.17.</span> <span class="toc-text">原网址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E4%BB%A3%E7%A0%81%E5%B1%82%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">2.18.</span> <span class="toc-text">7.1 代码层的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-computed-%E5%92%8C-watch-%E5%8C%BA%E5%88%86%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.19.</span> <span class="toc-text">7.2 computed 和 watch 区分使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-v-for-%E9%81%8D%E5%8E%86%E5%BF%85%E9%A1%BB%E4%B8%BA-item-%E6%B7%BB%E5%8A%A0-key%E3%80%82%E4%B8%94%E9%81%BF%E5%85%8D%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8-v-if"><span class="toc-number">2.20.</span> <span class="toc-text">7.3 v-for 遍历必须为 item 添加 key。且避免同时使用 v-if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-%E9%95%BF%E5%88%97%E8%A1%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">2.21.</span> <span class="toc-text">7.4 长列表性能优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">2.22.</span> <span class="toc-text">7.5 事件的销毁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.23.</span> <span class="toc-text">7.6 图片懒加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.24.</span> <span class="toc-text">7.7 路由懒加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-8-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6%E7%9A%84%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5"><span class="toc-number">2.25.</span> <span class="toc-text">7.8 第三方插件的按需引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-9-%E4%BC%98%E5%8C%96%E6%97%A0%E9%99%90%E5%88%97%E8%A1%A8%E6%80%A7%E8%83%BD"><span class="toc-number">2.26.</span> <span class="toc-text">7.9 优化无限列表性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93-SSR-or-%E9%A2%84%E6%B8%B2%E6%9F%93"><span class="toc-number">2.27.</span> <span class="toc-text">服务端渲染 SSR or 预渲染</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue-%E4%B8%AD-nextTick%EF%BC%9F"><span class="toc-number">2.28.</span> <span class="toc-text">vue 中$nextTick？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%BD%91%E5%9D%80-2"><span class="toc-number">2.29.</span> <span class="toc-text">原网址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%B7%E5%AE%87%E7%A7%91%E6%8A%80%EF%BC%88%E9%9D%A2%E8%AF%95%EF%BC%897-14"><span class="toc-number">2.30.</span> <span class="toc-text">捷宇科技（面试）7.14</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%88%B6%E5%AD%90%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%80%BC%EF%BC%9F"><span class="toc-number">2.31.</span> <span class="toc-text">1.父子之间传值？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ref-%E9%87%8C%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8F%82%E8%80%83"><span class="toc-number">2.32.</span> <span class="toc-text">2. ref 里面有什么？参考</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.33.</span> <span class="toc-text">3 生命周期有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">2.34.</span> <span class="toc-text">生命周期整体流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-created-%E5%92%8C-mounted%EF%BC%9F-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.35.</span> <span class="toc-text">3.1 created 和 mounted？(生命周期)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-number">2.36.</span> <span class="toc-text">3.2 生命周期使用场景分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-computed-%E5%92%8C-watch%EF%BC%9F"><span class="toc-number">2.37.</span> <span class="toc-text">4. computed 和 watch？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%AE%8F%E7%AB%8B%E8%BE%BE-7-14"><span class="toc-number">2.38.</span> <span class="toc-text">中宏立达(7.14)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%89%E4%B8%80%E5%8F%AA%E8%9A%82%E8%9A%81%E6%8E%89%E8%BF%9B%E4%B8%80%E5%8F%A3%E6%B7%B130%E7%B1%B3%E7%9A%84%E4%BA%95%E5%8F%A3-%E5%AE%83%E6%AF%8F%E5%A4%A9%E5%BE%80%E4%B8%8A%E7%88%AC3%E7%B1%B3-%E7%84%B6%E5%90%8E%E6%BB%91%E4%B8%8B2%E7%B1%B3-%E8%AF%B7%E9%97%AE%E8%BF%99%E5%8F%AA%E8%9A%82%E8%9A%81%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E5%A4%A9%E6%89%8D%E8%83%BD%E7%88%AC%E5%87%BA%E8%BF%99%E5%8F%A3%E4%BA%95%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">1.有一只蚂蚁掉进一口深30米的井口,它每天往上爬3米,然后滑下2米,请问这只蚂蚁需要多少天才能爬出这口井？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%94%A8%E5%8D%81%E4%B8%89%E6%A0%B9%E7%81%AB%E5%BD%A9%E6%8B%BC%E4%B8%BA-6-%E4%B8%AA-%E7%9F%A9%E5%BD%A2%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%8F%96%E8%B5%B0%E4%B8%80%E6%A0%B9%EF%BC%8C%E6%8A%8A%E5%89%A9%E4%B8%8B%E7%9A%84%E7%81%AB%E5%BD%A9%E6%8B%BC%E4%B8%BA-%E5%85%AD%E4%B8%AA%E7%AD%89%E8%BE%B9%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">4.</span> <span class="toc-text">2. 用十三根火彩拼为 6 个 矩形，现在取走一根，把剩下的火彩拼为 六个等边三角形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A6%82%E6%9E%9C%E5%BE%88%E5%A4%9A%E9%A1%B5%E9%9D%A2%E9%83%BD%E6%9C%89%E7%B1%BB%E4%BC%BC%E7%9A%84%E8%A7%86%E5%9B%BE-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">3. 如果很多页面都有类似的视图,怎么办？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BE%88%E5%A4%9A%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">4. 子组件的数据很多，怎么传递？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-vue-ref-%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%8F%82%E8%80%83"><span class="toc-number">5.2.</span> <span class="toc-text">5. vue ref 作用？参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">6.路由传参？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%8E%B7%E5%8F%96%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F%E6%9D%A5%E6%BA%90"><span class="toc-number">7.</span> <span class="toc-text">7. 获取路由参数的方式？来源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">8. 权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%9D%83%E9%99%90"><span class="toc-number">8.1.</span> <span class="toc-text">路由权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%94%9F%E6%88%90"><span class="toc-number">8.2.</span> <span class="toc-text">路由生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%BF%BD%E5%8A%A0%E8%B7%AF%E7%94%B1"><span class="toc-number">8.3.</span> <span class="toc-text">动态追加路由</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%8A%8A-vue2-%E8%BD%AC%E6%8D%A2%E4%B8%BA-vue3"><span class="toc-number">9.</span> <span class="toc-text">8. 把 vue2 转换为 vue3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-vue2-%E5%92%8C-vue3-%E4%B8%AD-v-model-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">9. vue2 和 vue3 中 v-model 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-css-%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E6%9D%83%E9%87%8D%E9%97%AE%E9%A2%98"><span class="toc-number">11.</span> <span class="toc-text">10. css 选择器的权重问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-css-%E4%B8%AD-link-%E5%92%8C-import%E7%9A%84-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">11. css 中 link 和 import的 区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">12. 浏览器渲染过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-render%E6%B8%B2%E6%9F%93%E6%A0%91%E7%9A%84%E9%87%8D%E7%BB%98-%E5%92%8C-%E5%9B%9E%E6%B5%81"><span class="toc-number">14.</span> <span class="toc-text">13. render渲染树的重绘 和 回流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E7%BB%84%E4%BB%B6%E5%8C%96-%E5%92%8C-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">14. 组件化 和 模块化的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E4%B8%BA%E4%BB%80%E4%B9%88token%E8%A6%81%E5%90%8C%E6%97%B6%E5%AD%98%E5%9C%A8vuex-%E5%92%8ClocalStorage%E4%B8%AD%EF%BC%9F"><span class="toc-number">15.1.</span> <span class="toc-text">15. 为什么token要同时存在vuex 和localStorage中？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-%E8%AF%B4%E8%AF%B4%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">15.2.</span> <span class="toc-text">16. 说说登录流程？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">17. 父组件监听子组件的生命周期？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%92%8C-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this"><span class="toc-number">17.</span> <span class="toc-text">18. 普通函数和 箭头函数中的this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81"><span class="toc-number">18.</span> <span class="toc-text">19.防抖节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96"><span class="toc-number">19.</span> <span class="toc-text">20 .项目优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E5%88%86%E4%B8%BA%E4%B8%89%E9%83%A8%E5%88%86"><span class="toc-number">19.1.</span> <span class="toc-text">项目优化分为三部分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%B7%B2%E7%9F%A5%E4%B8%80%E4%B8%AA%E9%AB%98%E5%BA%A6%E5%92%8C%E5%AE%BD%E5%BA%A6%E7%A1%AE%E5%AE%9A%E7%9A%84%E7%88%B6%E5%85%83%E7%B4%A0%E9%87%8C%E9%9D%A2%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AE%BD%E5%BA%A6%E5%92%8C%E9%AB%98%E5%BA%A6%E4%B8%8D%E7%A1%AE%E5%AE%9A%E7%9A%84%E5%AD%90%E5%85%83%E7%B4%A0"><span class="toc-number">20.</span> <span class="toc-text">21. 已知一个高度和宽度确定的父元素里面有一个宽度和高度不确定的子元素,</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%85%83%E7%B4%A0%E5%86%85%E5%AE%B9%E9%95%BF%E5%BA%A6%E7%9A%84%E7%94%B1%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%9D%A5%E5%86%B3%E5%AE%9A-%E5%86%85%E5%AE%B9%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%AE%9A-%E6%80%8E%E4%B9%88%E8%AE%A9%E5%AD%90%E5%85%83%E7%B4%A0%E7%9B%B8%E5%AF%B9%E7%88%B6%E5%85%83%E7%B4%A0%E5%9E%82%E7%9B%B4"><span class="toc-number">21.</span> <span class="toc-text">子元素内容长度的由后端数据来决定(内容长度不定),怎么让子元素相对父元素垂直</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%B0%B1%E5%B1%85%E4%B8%AD%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">水平就居中？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-vue-cli%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B"><span class="toc-number">23.</span> <span class="toc-text">2.vue-cli到底做了哪些事</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E4%B8%BA%E4%BB%80%E4%B9%88-vue%E8%A6%81-%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93%EF%BC%9F-%E5%9B%9B%E4%B9%85%E5%85%AB%E7%BD%91%E7%BB%9C%E7%A7%91%E6%8A%80"><span class="toc-number">24.</span> <span class="toc-text">22. 为什么 vue要 异步渲染？(四久八网络科技)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-vue%E8%99%9A%E6%8B%9Fdom%E7%9A%84%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B%EF%BC%9F-%E5%9B%9B%E4%B9%85%E5%85%AB%E7%BD%91%E7%BB%9C%E7%A7%91%E6%8A%80"><span class="toc-number">25.</span> <span class="toc-text">23. vue虚拟dom的产生过程？(四久八网络科技)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-vue2%E4%B8%AD%E5%8F%AA%E8%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%A0%B9%E6%A0%87%E7%AD%BE%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9C%A8vue3%E4%B8%AD%E6%A0%B9%E7%BB%84%E4%BB%B6%E5%B7%B2%E7%BB%8F%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%A0%B9%E8%8A%82%E7%82%B9%E4%BA%86%EF%BC%9F-%E5%9B%9B%E4%B9%85%E5%85%AB%E7%BD%91%E7%BB%9C%E7%A7%91%E6%8A%80"><span class="toc-number">26.</span> <span class="toc-text">24. vue2中只能有一个根标签，但是在vue3中根组件已经可以有多个根节点了？   (四久八网络科技)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-vue2-%E5%92%8C-vue3-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-%E9%99%84%E5%8A%A0"><span class="toc-number">27.</span> <span class="toc-text">24. vue2 和 vue3 的区别？(附加)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#https-blog-csdn-net-weixin-54722719-article-details-123069837"><span class="toc-number">28.</span> <span class="toc-text">https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_54722719&#x2F;article&#x2F;details&#x2F;123069837</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-webpack-%E5%81%9A%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">25. webpack 做什么优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#https-blog-csdn-net-lb6514052-article-details-124145599"><span class="toc-number">30.</span> <span class="toc-text">https:&#x2F;&#x2F;blog.csdn.net&#x2F;lb6514052&#x2F;article&#x2F;details&#x2F;124145599</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue2-%E6%80%8E%E4%B9%88%E6%BA%90%E7%A0%81%E6%80%8E%E4%B9%88%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84%E7%9A%84%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">vue2 怎么源码怎么监听数组的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#https-www-cnblogs-com-cuteyuchen-p-16440521-html"><span class="toc-number">32.</span> <span class="toc-text">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;cuteyuchen&#x2F;p&#x2F;16440521.html</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#26-ES6-%E4%B8%AD-Set-Map%EF%BC%9F%EF%BC%88%E5%85%AC%E5%8F%B8%E5%AE%9E%E6%88%98%E9%9D%A2%E8%AF%95%EF%BC%89%E6%9D%A5%E6%BA%90%E7%BD%91%E5%9D%80"><span class="toc-number">32.1.</span> <span class="toc-text">26. ES6 中 Set Map？（公司实战面试）来源网址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A-1"><span class="toc-number">32.2.</span> <span class="toc-text">相关知识点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-css-%E6%A0%B7%E5%BC%8F%E9%94%81%EF%BC%9F-https-blog-csdn-net-weixin-42140625-article-details-119369451"><span class="toc-number"></span> <span class="toc-text">27. css 样式锁？(https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_42140625&#x2F;article&#x2F;details&#x2F;119369451)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E5%8E%9F%E7%94%9F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E4%B8%BAapp%E7%9A%84%E6%97%B6%E5%80%99-%E5%AD%97%E9%9D%A2%E8%A7%A3%E5%86%B3video-%E7%9A%84%E5%B1%82%E7%BA%A7%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">28. 原生小程序打包为app的时候,字面解决video 的层级问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-nodejs-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%9F-https-www-php-cn-js-tutorial-484679-html"><span class="toc-number"></span> <span class="toc-text">29. nodejs 有哪些全局变量？(https:&#x2F;&#x2F;www.php.cn&#x2F;js-tutorial-484679.html)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-keep-alive-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">30. keep-alive 生命周期？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31-vue-%E4%B8%ADnextTick-https-blog-csdn-net-qq-54527592-article-details-119548787"><span class="toc-number">1.</span> <span class="toc-text">31. vue 中nextTick ?(https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_54527592&#x2F;article&#x2F;details&#x2F;119548787)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">32.浏览器的渲染机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-ajax-%E8%AF%B7%E6%B1%82%E8%A2%AB%E6%8B%A6%E6%88%AA%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F-https-www-cnblogs-com-maochenhua-p-13370349-html"><span class="toc-number">3.</span> <span class="toc-text">33. ajax 请求被拦截，怎么解决？(https:&#x2F;&#x2F;www.cnblogs.com&#x2F;maochenhua&#x2F;p&#x2F;13370349.html)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%EF%BC%9F-https-blog-csdn-net-qq-37288477-article-details-86601005"><span class="toc-number">4.</span> <span class="toc-text">34. 网络安全？(https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_37288477&#x2F;article&#x2F;details&#x2F;86601005)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-websocket-https-baike-baidu-com-item-WebSocket-1953845-fr-aladdin"><span class="toc-number">5.</span> <span class="toc-text">35. websocket ?(https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;WebSocket&#x2F;1953845?fr&#x3D;aladdin)</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/02/0802review/" title="0802review"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="0802review"/></a><div class="content"><a class="title" href="/2022/08/02/0802review/" title="0802review">0802review</a><time datetime="2022-08-01T23:54:46.000Z" title="Created 2022-08-02 07:54:46">2022-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/02/0801interview/" title="0801interview"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="0801interview"/></a><div class="content"><a class="title" href="/2022/08/02/0801interview/" title="0801interview">0801interview</a><time datetime="2022-08-01T23:47:14.000Z" title="Created 2022-08-02 07:47:14">2022-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/01/vue-diff/" title="vue_diff"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vue_diff"/></a><div class="content"><a class="title" href="/2022/08/01/vue-diff/" title="vue_diff">vue_diff</a><time datetime="2022-08-01T12:19:42.000Z" title="Created 2022-08-01 20:19:42">2022-08-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/31/0731vueRiview/" title="0731vueRiview"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="0731vueRiview"/></a><div class="content"><a class="title" href="/2022/07/31/0731vueRiview/" title="0731vueRiview">0731vueRiview</a><time datetime="2022-07-31T03:24:00.000Z" title="Created 2022-07-31 11:24:00">2022-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/24/vuecli2AndVueCli3/" title="vuecli2AndVueCli3"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vuecli2AndVueCli3"/></a><div class="content"><a class="title" href="/2022/07/24/vuecli2AndVueCli3/" title="vuecli2AndVueCli3">vuecli2AndVueCli3</a><time datetime="2022-07-24T09:44:17.000Z" title="Created 2022-07-24 17:44:17">2022-07-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By MaxLi</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>